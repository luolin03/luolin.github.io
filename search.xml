<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>string的一个小特性</title>
      <link href="/2021/11/08/string-de-yi-ge-xiao-te-xing/"/>
      <url>/2021/11/08/string-de-yi-ge-xiao-te-xing/</url>
      
        <content type="html"><![CDATA[<p>贴一下今天一日一题的题目：</p><p><a href="https://leetcode-cn.com/problems/bulls-and-cows/">299. 猜数字游戏 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>今天写一日一题的时候，思路异常简单。</p><p>思路解释：</p><p>先一次循环，将bull的值给确定，后来就是将两个string放进hash表里面就可以了，然后find函数，找到了就res++，最后将res转换成string类型，然后加入到ans即可。</p><p>但是有string的变量加入string数组的时候，我采用的是</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;int main()&#123;    string a ;     int num = 456 ;     string res = to_string(num) ;    a.push_back(res) ;     cout << a << endl ;    return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>小细节：</p><p>好吧，这样是不行的，将<code>a.push_back(res)</code> ，应该将<code>a += res ; </code> </p><p>算了，写都写了，贴个代码吧：</p><p>我一开始是用hash table来进行find的，最后只击败5%的人，原始代码如下：</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    string getHint(string secret, string guess) &#123;        int n = secret.size() ;         string ans = "" ;         multiset<char> ha1 , ha2 ;           int res = 0 ;         for(int i = 0; i < n ; ++ i)        &#123;            if(secret[i] == guess[i])            &#123;                res ++ ;                secret[i] = guess[i] = -1 ;             &#125;        &#125;        string num = to_string(res) ;          ans+=num ;         ans.push_back('A') ;        for(int i = 0 ; i < n ; ++ i)        &#123;            if(secret[i] != -1 && guess[i] != -1)            &#123;                ha1.insert(secret[i]) ;                ha2.insert(guess[i]) ;              &#125;        &#125;         int cnt = 0  ;        for(char c : ha1)        &#123;            auto it = ha2.find(c) ;             if(it != ha2.end())            &#123;                cnt ++ ;                 ha2.erase(it)  ;                 &#125;        &#125;         string cn = to_string(cnt) ;         ans+=cn ;        ans.push_back('B') ;        return ans ;     &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>后来看到大佬是可以直接用数组来优化的，学习了.</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    string getHint(string secret, string guess) &#123;        int n = secret.size();        int A = 0;        int B = 0;                int CA[10];        int CB[10];        memset(CA, 0, sizeof(CA));        memset(CB, 0, sizeof(CB));        for (int i = 0; i < n; i++) &#123;            if (secret[i] == guess[i]) A++;            CA[secret[i] - '0']++;            CB[guess[i] - '0']++;        &#125;        for (int i = 0; i < 10; i++) &#123;            B += min(CA[i], CB[i]);        &#125;        B -= A;        string ans = "";        ans = to_string(A) + "A" + to_string(B) + "B";        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>就是mark一下，一个小细节而已，虽然不起眼，但是有时候确实能把你卡死。</p><p>最近在学新东西，下次在更，拜拜。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 小细节 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树状数组</title>
      <link href="/2021/11/06/shu-zhuang-shu-zu/"/>
      <url>/2021/11/06/shu-zhuang-shu-zu/</url>
      
        <content type="html"><![CDATA[<h2 id="树状数组详解"><a href="#树状数组详解" class="headerlink" title="树状数组详解"></a>树状数组详解</h2><p>什么是树状数组：是一种维护前缀和并且可以支持查询，添加的操作的一种数据结构。</p><p>为什么使用树状数组？他的add操作与sum操作时间复杂度都是logn。相比于传统的前缀和数组，创建是一个O(n)的复杂度，但是查询却是O(1)的复杂度，树状数组取了一个中，使得两种操作的耗时比较平均。</p><h3 id="lowbit的概念："><a href="#lowbit的概念：" class="headerlink" title="lowbit的概念："></a>lowbit的概念：</h3><p>二进制理解：就是该数x，转化为二进制数之后，从右向左数，遇到第一个1，这一段数字的大小，就是最低位的1的大小，这么说有点抽象….hh</p><p>举个例子：比如说8，他的二进制是1000，所以返回的就是1000，即8.</p><p>在比如说12，他的二进制是1100，那么他返回的就是100，就是4.</p><p>直白理解：对于奇数来说，lowbit就是1，因为他的二进制数的第一位绝对是1，开始即结束，对于偶数来说，lowbit其实就是他的最大2的次方的因子。</p><p>计算方式：</p><pre class="line-numbers language-c++"><code class="language-c++">int lowbit(int x)&#123;    return x & -x ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这是树状数组的精华所在，所谓树状数组，说白了，其实就是用数组来实现树的某些功能，只不过不用建树而已，这里的lowbit其实就是划分父子节点的关键所在,同时这也是树状数组可以将查询操作与建立操作控制在logn的关键。</p><p>小声bb，这其实让我想到了背包问题，好像是多重背包问题的二进制优化，也是通过这样的思想，让本来O(N)的复杂度，变成logn。</p><h3 id="树状数组的查询与建立操作"><a href="#树状数组的查询与建立操作" class="headerlink" title="树状数组的查询与建立操作"></a>树状数组的查询与建立操作</h3><p>知道了lowbit之后，其实树状数组就是很好理解了。</p><p>也就是说，其实树状数组的序号以及序号之间的关系就已经定下来了，需要根据不同的题目来确定value以及序号的实际含义而已。</p><p>那我们如何建立一个树状数组呢，哎，可以通过普通的数组来进行建立一个树状数组。</p><p>代码如下:</p><pre class="line-numbers language-c++"><code class="language-c++">void add(int x , int k)&#123;    for(int i = x ; i <= n ; i += lowbit(i))    &#123;        tr[i] += k ;     &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为类似于前缀和数组，他的每一个子节点的改变，都会使得他的父节点有改变，所以我们一直往上改变。</p><p>好了，那如何查询一个节点的前缀和呢?</p><pre class="line-numbers language-c++"><code class="language-c++">int sum(int x)&#123;    int res = 0 ;    for(int i = x ; i ; i -= lowbit(i))    &#123;        res += tr[i] ;     &#125;    return res ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好了，以上两项是树状数组的基本操作，知道了这两种操作之后，我们可以玩很多花样，比如后面的例题。</p><p>可以在value上做一些花样，比如说存的是次数(其实是因为题目有局限性，因为横坐标与纵坐标是范围一致的)，所以我们可以用树状数组的序号来存普通数组的值。</p><p>也可以在存的数值上做一些改变，比如想要快速改变一段区间的值，我们甚至可以存目标数组的差分数组，这样同时也可以快速的查询单点值，因为差分数组的区间和就是普通数组的一个单点值吗。</p><p>ok，下面是一些例题。</p><h3 id="楼兰图腾"><a href="#楼兰图腾" class="headerlink" title="楼兰图腾"></a>楼兰图腾</h3><hr><p>在完成了分配任务之后，西部 314 来到了楼兰古城的西部。</p><p>相传很久以前这片土地上(比楼兰古城还早)生活着两个部落，一个部落崇拜尖刀(<code>V</code>)，一个部落崇拜铁锹(<code>∧</code>)，他们分别用 <code>V</code> 和 <code>∧</code> 的形状来代表各自部落的图腾。</p><p>西部 314 在楼兰古城的下面发现了一幅巨大的壁画，壁画上被标记出了 n个点，经测量发现这 n个点的水平位置和竖直位置是两两不同的。</p><p>西部 314认为这幅壁画所包含的信息与这 n 个点的相对位置有关，因此不妨设坐标分别为 (1,y1),(2,y2),…,(n,yn)，其中y1∼yn 是 1 到 n 的一个排列。</p><p>西部 314 打算研究这幅壁画中包含着多少个图腾。</p><p>如果三个点 (i,yi),(j,yj),(k,yk) 满足 1≤i&lt;j&lt;k≤n 且 yi&gt;yj,yj&lt;yk，则称这三个点构成 <code>V</code> 图腾;</p><p>如果三个点 (i,yi),(j,yj),(k,yk) 满足 1≤i&lt;j&lt;k≤n 且 yi&lt;yj,yj&gt;yk，则称这三个点构成 <code>∧</code> 图腾;</p><p>西部 314 想知道，这 n 个点中两个部落图腾的数目。</p><p>因此，你需要编写一个程序来求出 <code>V</code> 的个数和 <code>∧</code> 的个数。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行一个数 n。</p><p>第二行是 n个数，分别代表y1，y2,…,yn。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>两个数，中间用空格隔开，依次为 <code>V</code> 的个数和 <code>∧</code> 的个数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>对于所有数据，n≤200000，且输出答案不会超过 int64。<br>y1∼yn 是 11 到 n 的一个排列。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>51 5 3 2 4</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>3 4</code></pre><hr><p>思路解释：炸一看此题，感觉思路比较自然，就是对于每一个节点来说，先将其看成最低点，分别找两边大于他的点的个数，两边一乘，就是此点v的值，然后将每个点的v的值加起来，就是总共的v的值，倒v也是如此。</p><p>最白的思路就是直接暴力，我们暴力来看一下。</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 2e5 + 10 ; int n ; typedef long long LL ; int a[N] ,  le[N] ,  ri[N] ; LL res = 0 , ans = 0 ; int main()&#123;    cin >> n ;     for(int i = 1 ; i <= n ;  ++ i)    &#123;        cin >> a[i] ;     &#125;    for(int i = 2 ; i <= n-1 ; ++ i)    &#123;        int l = 0 , r = 0 ;        int tar = a[i] ;          for(int j = 1 ; j < i ; ++ j)        &#123;            if(a[j] > tar)            &#123;                l ++ ;             &#125;        &#125;        for(int j = i + 1 ; j <= n ; ++ j)        &#123;            if(a[j] > tar)            &#123;                r++ ;             &#125;        &#125;        le[i] = l , ri[i] = r ;             res += (LL)l * r ;    &#125;     memset(le , 0 , sizeof le) ;     memset(ri , 0 , sizeof ri) ;     for(int i = 2 ; i <= n-1 ; ++ i)    &#123;        int l = 0 , r = 0 ;        int tar = a[i] ;          for(int j = 1 ; j < i ; ++ j)        &#123;            if(a[j] < tar)            &#123;                l ++ ;             &#125;        &#125;        for(int j = i + 1 ; j <= n ; ++ j)        &#123;            if(a[j] < tar)            &#123;                r++ ;             &#125;        &#125;        le[i] = l , ri[i] = r ;             ans += (LL)l * r ;    &#125;        cout << res << " " << ans << endl ;     return  0 ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不出所料，是n方的复杂度，n最大是20万，肯定会TLE。</p><p>我们于是想如何用树状数组来进行存储，我们于是有注意到一点，yn的排列也是1-n，也就是说，这在逻辑上可以看成是一个正方形，什么意思呢？也就是说，我们可以将其与sum函数连接起来，sum可以查询在sum之前所有value的值。</p><p>那我们的思路自然就出来了，用树状数组的下标，存的是yn，每一个的value存的是yn出现的次数。在申明一个low和great数组，每一个存放比当前节点高或者是低的节点的数量即可。</p><p>贴个代码：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 2e5 + 10 ; typedef long long LL ; int a[N] ,tr[N] , low[N] , high[N];int n ; int lowbit(int x)&#123;    return x & -x ;&#125;void add(int x , int k)&#123;    for(int i = x ; i <= n ; i += lowbit(i))    &#123;        tr[i] += k ;     &#125;&#125;int sum(int x)&#123;    int res = 0 ;        for(int i = x ; i ; i -= lowbit(i))    &#123;        res += tr[i] ;     &#125;    return res ; &#125;int main()&#123;    cin >> n ;        for(int i = 1;  i <= n ; ++ i)    &#123;        cin >> a[i] ;     &#125;        for(int i = 1 ; i <= n ; ++ i)    &#123;        int y = a[i] ;         low[i] = sum(y-1) ;         high[i] = sum(n) - sum(y) ;         add(y,1) ;     &#125;        memset(tr , 0 , sizeof tr) ;         LL ans = 0 , res = 0 ;         for(int i = n ; i >= 1 ; -- i)    &#123;        int y  = a[i];        ans += (LL) low[i] * (sum(y-1)) ;         res += (LL) high[i] * (sum(n) - sum(y)) ;         add(y,1) ;     &#125;    cout << res << " " << ans << endl ;     return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="一个简单的整数问题"><a href="#一个简单的整数问题" class="headerlink" title="一个简单的整数问题"></a>一个简单的整数问题</h3><hr><p>给定长度为 N的数列A，然后输入 M 行操作指令。</p><p>第一类指令形如 <code>C l r d</code>，表示把数列中第 l∼r 个数都加 dd。</p><p>第二类指令形如 <code>Q x</code>，表示询问数列中第 x 个数的值。</p><p>对于每个询问，输出一个整数表示答案。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 N 和 M。</p><p>第二行包含 N 个整数 A[i]。</p><p>接下来 M 行表示 M 条指令，每条指令的格式如题目描述所示。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个询问，输出一个整数表示答案。</p><p>每个答案占一行。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N,M≤105,<br>|d|≤10000,<br>|A[i]|≤109</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>10 51 2 3 4 5 6 7 8 9 10Q 4Q 1Q 2C 1 6 3Q 2</code></pre><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>4125</code></pre><hr><p>这一题题意很简单，Q是查询下标对应值，C是对数组的一个区间进行修改操作。</p><p>我们的正常思路应该是，循环add，但是那样的话，这一题很显然就超时了，而且这根本就不会这样考的。</p><p>所以，我们立刻想到了一种O(n)的修改区间值的方法，没错，就是差分，他比较适合于用两个端点的值来进行修改一整段区间的值。</p><p>代码如下：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 1e5 + 10 ; int a[N] , tr[N] ; int n , m  ; int lowbit(int x)&#123;    return x & -x  ;&#125;void add(int x , int k)&#123;    for(int i = x ; i <= n ; i += lowbit(i))    &#123;        tr[i] += k ;     &#125;&#125;int sum(int x)&#123;    int res = 0 ;     for(int i = x ; i ;  i -= lowbit(i))    &#123;        res += tr[i] ;     &#125;    return res ; &#125;int main()&#123;    cin >> n >> m ;         for(int i = 1 ; i <= n ; ++ i)    &#123;        cin >> a[i] ;        add(i , a[i] - a[i-1]) ;     &#125;        while(m--)    &#123;        string op ;         cin >> op ;         if(op[0] == 'C')        &#123;            int l , r , d ;             cin >> l >> r >> d ;             add(l , d) , add(r+1 , -d) ;         &#125;        else        &#123;            int num ;             cin >> num ;             int res = sum(num) ;             cout << res << endl ;         &#125;    &#125;    return  0 ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="一个简单的整数问题II"><a href="#一个简单的整数问题II" class="headerlink" title="一个简单的整数问题II"></a>一个简单的整数问题II</h3><hr><p>给定一个长度为 N 的数列 A，以及 M 条指令，每条指令可能是以下两种之一：</p><ol><li><code>C l r d</code>，表示把 A[l],A[l+1],…,A[r] 都加上 d。</li><li><code>Q l r</code>，表示询问数列中第 l∼r 个数的和。</li></ol><p>对于每个询问，输出一个整数表示答案。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数 N,M。</p><p>第二行 N 个整数A[i]。</p><p>接下来 M 行表示 M 条指令，每条指令的格式如题目描述所示。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个询问，输出一个整数表示答案。</p><p>每个答案占一行。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N,M≤105,<br>|d|≤10000,<br>|A[i]|≤109</p><h4 id="输入样例：-2"><a href="#输入样例：-2" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>10 51 2 3 4 5 6 7 8 9 10Q 4 4Q 1 10Q 2 4C 3 6 3Q 2 4</code></pre><h4 id="输出样例：-2"><a href="#输出样例：-2" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>455915</code></pre><hr><p>基本思路：与上一题相比的话，这里是在Q的时候，是一个区间查询，而不是单点和，这就比较蛋疼。为什么呢？因为我们知道，我们在C的时候，采用了用树状数组来维护一个差分数组的方法，但是这个区间和的查询本来应该是前缀和的事情，但是这等于是组了三个等级，我们如果在申请一个前缀和数组的话，维护起来比较麻烦，于是我们通过数学推导。</p><p>如何可以从差分数组中得出一段区间的和，那这样的话，我们只需要再次申请一个差分数组的变种即可。</p><p>推导如下：</p><pre class="line-numbers language-c++"><code class="language-c++">a1 = b1 a2 = b2 + b1a3 = b3 + b2 + b1    ...an = bn + bn-1 + ... + b1    那我们如果要求a1 + a2 + a3 + ... + an = b1 +b1 + b2b1 + b2 + b3  ...b1 + ... +  ... + ....  bn    我们把矩阵补全，b1 + ... + ... + ... + bnb1 +  ........ . . . . . b1 + b2 .... . . . . . . b1 + b2 + b3 ......  . .  ...   .. . . . . . .. b1 + ... +  ... + ....  bn    经推导可以得到：Sn = (n+1) * Sb(n) - S(i*b(i))    也就是说我们只需要在申请差分数组之外，在申请一个差分数组*i的差分数组即可。            对于这个tri数组来说，add的就是tr数组的值*i。其余与tr数组并无大异。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>逻辑就是这样，下面是代码展示：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 1e5 + 10 ; typedef long long LL ; int a[N] ; LL tr[N] , tri[N] ; int n , m  ; int lowbit(int x)&#123;    return x & -x ; &#125;void add(int x , LL k , LL num[])&#123;    for(int i = x ; i <= n ; i += lowbit(i))    &#123;        num[i] += k ;     &#125;&#125;LL sum(int x , LL num[])&#123;    LL res = 0 ;     for(int i = x ; i ;  i -= lowbit(i))    &#123;        res += num[i] ;     &#125;    return res ; &#125;LL getsum(int x)&#123;    return sum(x , tr) * (x+1) - sum(x , tri) ; &#125;int main()&#123;    cin >> n >> m ;         for(int i = 1 ; i <= n ; ++ i)    &#123;        cin >> a[i] ;        add(i , a[i] - a[i-1] ,tr) ;         add(i , (LL)(a[i] - a[i-1]) * i , tri) ;     &#125;        while(m--)    &#123;        string op ;         cin >> op ;         if(op[0] == 'C')        &#123;            int l , r , d ;  cin >> l >> r >> d ;             add(l , d , tr) , add(r+1 , -d , tr) ;             add(l , d *l , tri) , add(r+1 , (-d)*(r+1) , tri) ;         &#125;        else        &#123;            int l , r ;             cin >> l >> r ;             LL res = getsum(r) - getsum(l-1) ;             printf("%lld\n" , res) ;         &#125;    &#125;    return  0 ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>今天就更到这，下次在更…….</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论的基础算法知识点</title>
      <link href="/2021/10/29/tu-lun-de-zhi-shi-dian/"/>
      <url>/2021/10/29/tu-lun-de-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<h1 id="最短路问题"><a href="#最短路问题" class="headerlink" title="最短路问题"></a>最短路问题</h1><p>(其实写完之后才发现有图片的话会更加直观，我也就不用打那么多字了，但是觉得上传图片有点麻烦了，先将脉络mark一下，之后有时间在上传图片)。</p><p>最短路问题可以大致分为单源最短路问题，多源最短路问题。</p><h2 id="单源最短路问题："><a href="#单源最短路问题：" class="headerlink" title="单源最短路问题："></a>单源最短路问题：</h2><h3 id="全是正边权："><a href="#全是正边权：" class="headerlink" title="全是正边权："></a>全是正边权：</h3><h4 id="朴素dijkstra："><a href="#朴素dijkstra：" class="headerlink" title="朴素dijkstra："></a>朴素dijkstra：</h4><p>基本思路：</p><p>首先需要一个集合，用于存储已经确定距离起点最小距离的点。</p><p>逻辑就是在遍历每个点，找到在集合外面同时距离起点最近的点，把这个点t放进集合中。然后用这个点来更新其他的点的距离。</p><p>时间复杂度是O(n2) .</p><h4 id="堆优化版dijkstra"><a href="#堆优化版dijkstra" class="headerlink" title="堆优化版dijkstra"></a>堆优化版dijkstra</h4><p>基本思路：</p><p>相比于朴素版，在选取t的时候做了一些优化。用的是小根堆进行排列，每次从堆中移除堆头，该店就是t，同时更新与t相邻的点的距离。</p><p>时间复杂度是在O(mlogn) .</p><h3 id="存在负边权"><a href="#存在负边权" class="headerlink" title="存在负边权"></a>存在负边权</h3><h4 id="bell-ford算法："><a href="#bell-ford算法：" class="headerlink" title="bell-ford算法："></a>bell-ford算法：</h4><p>基本思路：其实就是暴力求解，在存储图的时候，不一定非要是邻接表或者是邻接矩阵。只要可以每一次迭代的时候，可以遍历全部的边就可以。</p><p>他的逻辑就是，外层循环直接迭代n次，(n为点的数量)，内层循环迭代m次(m为边的数量)。每次按边的权重差来进行更新，故外层循环n次是一定够的。每一个节点更新与否，取决于他的临点更不更新。</p><p>时间复杂度大概是O(mn)</p><h4 id="spfa算法"><a href="#spfa算法" class="headerlink" title="spfa算法"></a>spfa算法</h4><p>是bell_ford算法的优化版。是根据bellman的纯暴力算法，体现在更新节点严重依赖于前继节点上。所以spfa算法用了一个容器，可以是队列，优先队列，栈，来充当一个集合，用来存储待更新的节点，一旦需要用这个节点来进行更新，就出队就可以了，用false标记一下，然后在把用这个节点更新的其他节点，如果不在队列里面的话，就直接入队，在的话，就不用管他。</p><p>时间复杂度是一般是O(m) ,最坏的情况是O(mn) 。</p><p>这里就会有一些争议。我最近在网上冲浪看到的，有些比较恶心的出题人，会卡spfa的数据，什么网格图，菊花图什么的。</p><p>这种情况一般出现在全是正权边的情况下，负边权的话一般都不会卡，因为只有spfa这种解决方案。所以在正权边的时候，我们需要考虑到底是采用朴素，堆优化的dijkstra，还是用spfa。</p><p>还有顺便提一下，并不是朴素的djkstra算法一定差于堆优化版的djkstra算法，这要根据实际情况来。一般来说，我们是稠密图用邻接矩阵来存，然后采用朴素dijkstra算法，相当于是O(m),若此时用heap优化的话，是O(mlogn)。从这种意义来看，朴素版是要比heap版是更优的。</p><h2 id="多源最短路问题："><a href="#多源最短路问题：" class="headerlink" title="多源最短路问题："></a>多源最短路问题：</h2><h4 id="floyd算法"><a href="#floyd算法" class="headerlink" title="floyd算法"></a>floyd算法</h4><p>基本思路：其实是基于dp的一种做法，也是极其暴力，三层循环就搞定了。</p><p>状态转移方程是f[i] [j] = min(f[i] [k]+ f[k] [j]) ;  </p><p>下面分别来进行介绍一下各种算法的实际应用：</p><h1 id="朴素dijisktra算法"><a href="#朴素dijisktra算法" class="headerlink" title="朴素dijisktra算法"></a>朴素dijisktra算法</h1><h3 id="Dijkstra求最短路I"><a href="#Dijkstra求最短路I" class="headerlink" title="Dijkstra求最短路I"></a>Dijkstra求最短路I</h3><hr><p>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为正值。</p><p>请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n和 m。</p><p>接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示 1 号点到 n 号点的最短距离。</p><p>如果路径不存在，则输出 −1。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤500,<br>1≤m≤105,<br>图中涉及边长均不超过10000。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>3 31 2 22 3 11 3 4</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>3</code></pre><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 520 ; int g[N][N] , dist[N] ; bool st[N] ; int n , m ; void dijkstra()&#123;    memset(dist , 0x3f , sizeof dist) ;         dist[1] = 0 ;         for(int i = 0 ; i < n ; ++ i)    &#123;        int t = -1 ;         for(int j = 1 ; j <= n ; ++ j)        &#123;            if(!st[j] && (t == -1 || dist[t] > dist[j]))            &#123;                t = j  ;             &#125;        &#125;        st[t] = true ;                 for(int i = 1 ; i <= n ; ++ i)        &#123;            dist[i] = min(dist[i] , dist[t] + g[t][i]) ;         &#125;    &#125;&#125;int main()&#123;    cin >> n >> m ;         memset(g , 0x3f , sizeof g) ;         while(m--)    &#123;        int a , b , c ;         cin >> a >> b >> c ;        g[a][b] = min(g[a][b] , c) ;     &#125;        dijkstra() ;         if(dist[n] == 0x3f3f3f3f)        cout << -1 << endl ;     else        cout << dist[n] << endl ;     return  0 ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有几个细节点要注意一下。</p><p>这里的t==-1，是为了赶紧找到第一个参照。因为t的含义是，在集合外面找一个dist最小的点，并放进集合里面，然后依次来更新其余个点的距离。</p><p>一开始，我就有一个疑问，为什么这里的算法，在初始化的时候，g[i] [i]为什么不标零。 </p><p>其实最好是要标一下的，但是在这个算法当中，唯一用到g的地方，其实是用t来更新的时候。我们假设这样一种情况，</p><p>当t == i的时候，<code>dist[i] = min(dist[i] , dist[t] + g[t][i])</code> ，dist[i] &lt;= dist[i] + g[i] [i]，所以对于这一题其实没有什么影响。 </p><h3 id="Dijkstra求最短路II"><a href="#Dijkstra求最短路II" class="headerlink" title="Dijkstra求最短路II"></a>Dijkstra求最短路II</h3><p>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为非负值。</p><p>请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n 和 m。</p><p>接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示 1 号点到 n 号点的最短距离。</p><p>如果路径不存在，则输出 −1。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n,m≤1.5×105,<br>图中涉及边长均不小于 0，且不超过 10000。</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>3 31 2 22 3 11 3 4</code></pre><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>3</code></pre><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 1e6 ; int idx , h[N] ,ne[N] ,e[N],w[N] ; int dist[N] ; int n , m ; typedef pair<int ,int > PII ; bool st[N] ; void add(int a , int b , int c)&#123;    e[idx] = b , ne[idx] = h[a] , w[idx] = c,  h[a] = idx ++ ; &#125;int dijkstra()&#123;    memset (dist , 0x3f , sizeof dist) ;     dist[1] = 0 ;     priority_queue<PII , vector<PII> , greater<PII> > heap ;     heap.push(&#123;0,1&#125;) ;     while(heap.size())    &#123;        PII t = heap.top()  ;         heap.pop() ;         int index = t.second  ;        int distance = t.first ;         if(st[index])        continue ;        else        st[index] = true ;         for(int i = h[index] ; i != -1 ; i = ne[i])        &#123;            int j = e[i] ;             if(dist[j] > distance + w[i])            &#123;                dist[j] = distance + w[i] ;                 heap.push(&#123;dist[j] , j&#125;) ;             &#125;        &#125;    &#125;    if(dist[n] == 0x3f3f3f3f)    return -1 ;     return dist[n] ;&#125;int main()&#123;    cin >> n >> m ;         memset(h , -1 , sizeof h) ;     while(m--)    &#123;        int a , b , c ;         scanf("%d%d%d",&a,&b,&c) ;         add(a,b,c) ;     &#125;        cout << dijkstra() << endl ;     return 0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="有边数限制的最短路"><a href="#有边数限制的最短路" class="headerlink" title="有边数限制的最短路"></a>有边数限制的最短路</h2><p>给定一个 n个点 m 条边的有向图，图中可能存在重边和自环， <strong>边权可能为负数</strong>。</p><p>请你求出从 1 号点到 n 号点的最多经过 k 条边的最短距离，如果无法从 1 号点走到 n 号点，输出 <code>impossible</code>。</p><p>注意：图中可能 <strong>存在负权回路</strong> 。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含三个整数 n,m,k。</p><p>接下来 m 行，每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示从1 号点到 n 号点的最多经过 k 条边的最短距离。</p><p>如果不存在满足条件的路径，则输出 <code>impossible</code>。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n,k≤500,<br>1≤m≤10000,<br>任意边长的绝对值不超过10000。</p><h4 id="输入样例：-2"><a href="#输入样例：-2" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>3 3 11 2 12 3 11 3 3</code></pre><h4 id="输出样例：-2"><a href="#输出样例：-2" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>3</code></pre><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 510 , M = 10010 ; struct edge&#123;    int a, b ,c ;&#125;edges[M] ; int n , m  , k; int dist[N]  , backup[N]; void bellman_ford()&#123;    memset(dist , 0x3f , sizeof dist) ;     dist[1] = 0  ;        for(int i = 0 ; i < k ; ++ i)    &#123;        memcpy(backup , dist , sizeof dist) ;                 for(int i = 1;  i <= m ; ++ i)        &#123;            int a = edges[i].a ;             int b = edges[i].b ;             int w = edges[i].c ;             dist[b] = min(dist[b] , backup[a] + w) ;         &#125;    &#125;&#125;int main()&#123;    cin >> n >> m >>  k;     for(int i = 1 ; i <= m  ; ++ i)    &#123;        int a ,b ,c ;         cin >> a >> b >> c ;        edges[i] = &#123;a , b , c&#125; ;     &#125;    bellman_ford() ;     if(dist[n] > 0x3f3f3f3f / 2)        puts("impossible") ;     else        cout << dist[n] << endl ;     return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="spfa求最短路"><a href="#spfa求最短路" class="headerlink" title="spfa求最短路"></a>spfa求最短路</h2><p>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， <strong>边权可能为负数</strong>。</p><p>请你求出 1 号点到 n 号点的最短距离，如果无法从 1号点走到 n 号点，则输出 <code>impossible</code>。</p><p>数据保证不存在负权回路。</p><h4 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n 和 m。</p><p>接下来 m 行每行包含三个整数x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。</p><h4 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示 1号点到 n 号点的最短距离。</p><p>如果路径不存在，则输出 <code>impossible</code>。</p><h4 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n,m≤105,<br>图中涉及边长绝对值均不超过10000。</p><h4 id="输入样例：-3"><a href="#输入样例：-3" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>3 31 2 52 3 -31 3 4</code></pre><h4 id="输出样例：-3"><a href="#输出样例：-3" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>2</code></pre><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 1e5 + 10  ; int idx , e[N] ,ne[N] ,h[N] ,w[N]  ; int dist[N] ;bool st[N] ; int n , m ; void add(int a , int b ,int c)&#123;    e[idx] = b , ne[idx] = h[a] , w[idx] = c  , h[a] = idx++ ; &#125;void spfa()&#123;    memset(dist , 0x3f , sizeof dist) ;     dist[1] =  0 ;     queue<int> q ;     q.push(1) ;     st[1] = true ;     while(q.size())    &#123;        int t = q.front() ;         q.pop() ;         st[t] = false ;                 for(int i = h[t] ; i != -1 ; i = ne[i])        &#123;            int j = e[i] ;             if(dist[j] > dist[t] + w[i])            &#123;                dist[j] = dist[t] + w[i] ;                 if(!st[j])                &#123;                    q.push(j) ;                     st[j] = true ;                 &#125;            &#125;        &#125;    &#125;   &#125;int main()&#123;    cin >> n >> m ;         memset(h , -1 , sizeof h) ;     while(m--)    &#123;        int a , b , c ;         cin >> a >> b >> c ;         add(a,b,c) ;     &#125;        spfa() ;         if(dist[n] == 0x3f3f3f3f)        puts("impossible") ;     else        cout << dist[n] << endl ;     return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后解决一下为什么spfa和bellman_ford算法可以解决负权边的问题。</p><p>因为对于dijkstra算法，他是一锤子买卖，之所以不可以解决负的问题我们用图来进行解释。</p><p>是因为如图所示，如果按照dijkstra算法的尿性，入集合的顺序是1，2,4,6 ， 但是其实是应该是1,3,5,6.是因为在2与3进行纠结的时候，把2push到了集合里面，之后就不会放出来了。而后续的所有直到所有的节点的距离之和都不会大于1到3的距离，所以说他是一锤子买卖，一旦选定了当时距离起点最近的点之后，就push进集合，不出来了，然后就用这个点来进行更新，所以一旦有负全边，他根本看不见，可以理解为是1到3的距离，直接蒙蔽了dijkstra的眼睛，让他看不见之后的-100的权值。</p><p>那我们再来看，bellman_ford，spfa和bellman_ford原理相同，我们就拿bellman_ford做例子。</p><p>他是完全暴力，按照边来更新的，不像dijkstra是按点来更新的，所以他每一次迭代，都会重新刷新一遍所有点，取其中最小的边，来进行后继的更新，所以被更新后的点，可以再次被更新，所以他完全可以看见负权边的存在。</p><h2 id="Floyd算法求最短路问题"><a href="#Floyd算法求最短路问题" class="headerlink" title="Floyd算法求最短路问题"></a>Floyd算法求最短路问题</h2><p>给定一个 n 个点 m条边的有向图，图中可能存在重边和自环，边权可能为负数。</p><p>再给定 k 个询问，每个询问包含两个整数 x 和 y，表示查询从点 x 到点 y 的最短距离，如果路径不存在，则输出 <code>impossible</code>。</p><p>数据保证图中不存在负权回路。</p><h4 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含三个整数 n,m,k。</p><p>接下来 m 行，每行包含三个整数x,y,z，表示存在一条从点 x到点 y的有向边，边长为 z。</p><p>接下来 k行，每行包含两个整数 x,y，表示询问点 x 到点 y 的最短距离。</p><h4 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 k 行，每行输出一个整数，表示询问的结果，若询问两点间不存在路径，则输出 <code>impossible</code>。</p><h4 id="数据范围-4"><a href="#数据范围-4" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤200,<br>1≤k≤n2，<br>1≤m≤20000,<br>图中涉及边长绝对值均不超过10000。</p><h4 id="输入样例：-4"><a href="#输入样例：-4" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>3 3 21 2 12 3 21 3 12 11 3</code></pre><h4 id="输出样例：-4"><a href="#输出样例：-4" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>impossible1</code></pre><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;int n , m , k  ; const int N = 210 ; int g[N][N] ; void floyd()&#123;    for(int k = 1;  k <= n ; ++ k)    &#123;        for(int i = 1 ; i <= n ; ++ i)        &#123;            for(int j = 1 ; j <= n ; ++ j)            &#123;                g[i][j] = min(g[i][j] , g[i][k] + g[k][j]) ;             &#125;        &#125;    &#125;&#125;int main()&#123;    scanf("%d%d%d" , &n ,&m,&k) ;         memset(g , 0x3f , sizeof g) ;         for(int i = 1 ; i <= n ;  ++ i)        g[i][i] = 0 ;         while(m--)    &#123;        int a , b , c ;         scanf("%d%d%d",&a,&b,&c) ;        g[a][b] = min(g[a][b] , c) ;     &#125;        floyd() ;        while(k--)    &#123;        int x,y ;         cin >> x >> y ;         if(g[x][y] > 0x3f3f3f3f / 2)            puts("impossible") ;         else            cout << g[x][y] << endl ;     &#125;    return  0 ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这没有什么好说的，完全是暴力dp，感觉其实和bellman_ford算法有异曲同工之妙。至于原理，之后有时间在推一下。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dfs求组合数题型</title>
      <link href="/2021/10/26/dfs-qiu-zu-he-shu-ti-xing/"/>
      <url>/2021/10/26/dfs-qiu-zu-he-shu-ti-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="dfs求组合数"><a href="#dfs求组合数" class="headerlink" title="dfs求组合数"></a>dfs求组合数</h1><p>这种题型套路比较固定，应该是比较好总结的，但是我自从昨天刚刚接触，我人已经麻了。</p><p>感觉对dfs的机理，以及何时开始调用，内部的执行顺序不会知道的非常透彻。</p><p>误打误撞了ac了leetcode的几道题，今天先mark一下。之后写的题目多了之后，我继续再总结。</p><p>—————————————————————-10.27—————————————————————</p><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p><a href="https://leetcode-cn.com/problems/combinations/">77. 组合 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>题目非常简洁，只有两个参数，n与k。给一个1到n的范围，每一个组合有k个数，列举出所有的可能。</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    vector<int> path ;     vector<vector<int>> res ;         vector<vector<int>> combine(int n, int k) &#123;        dfs(1 , 0 , n , k) ;         return res ;     &#125;            void dfs(int start , int u , int n , int k)    &#123;        if(u == k)        &#123;            res.push_back(path) ;             return  ;         &#125;                for(int i = start ; i <= n  ; ++ i)        &#123;            path.push_back(i) ;             dfs(i+1 , u +1 , n , k) ;            path.pop_back() ;         &#125;    &#125;    return  ; &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h2><p><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>y总的思路，u的含义是遍历candidate数组的每一个下标。对每一个下标而言，用一个循环判断需要使用多少个该元素,对于每一轮改变target的值，恢复现场即可。</p><p>贴个代码：</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    vector<int> ans ;     vector<vector<int>> res ;             vector<vector<int>> combinationSum(vector<int>& candidates, int target) &#123;        dfs(0 , candidates , target) ;         return res ;     &#125;        void dfs(int u , vector<int> candidates , int target)    &#123;        if(target == 0)        &#123;            res.push_back(ans) ;             return  ;        &#125;                if(u == candidates.size())        &#123;            return  ;         &#125;                for(int i = 0 ; i * candidates[u] <= target ; ++ i)        &#123;            dfs(u + 1 , candidates , target - i * candidates[u]) ;             ans.push_back(candidates[u]) ;         &#125;                for(int i = 0 ; i * candidates[u] <= target ; ++ i)        &#123;            ans.pop_back() ;         &#125;     return ;        &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="组合总和II"><a href="#组合总和II" class="headerlink" title="组合总和II"></a>组合总和II</h2><p><a href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>与上面一题的区别是，数组中有了重复元素，但是只能用已有的元素，就是将个数限定死了，不是想上面一题类似于完全背包问题。</p><p>我们只需要在找数量的时候，加一条限制，不超过所给的数量即可。但是有一点要注意，要进行去重，否则答案会出现很多重复答案。</p><p>贴个代码：</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    vector<int> ans ;    vector<vector<int>> res ;    unordered_map<int,int> ha ;         vector<vector<int>> combinationSum2(vector<int>& candidates, int target) &#123;        sort(candidates.begin() , candidates.end()) ;         for(int num : candidates)        &#123;            ha[num] ++ ;         &#125;        candidates.erase(unique(candidates.begin() , candidates.end()) , candidates.end()) ;         dfs(0 , candidates , target) ;        return res ;     &#125;        void dfs(int u , vector<int> candidates ,int target)    &#123;        if(target == 0)        &#123;            res.push_back(ans) ;             return  ;         &#125;                if(u == candidates.size())        &#123;            return ;         &#125;                for(int i = 0 ; i * candidates[u] <= target && i <= ha[candidates[u]] ; ++ i)        &#123;            dfs(u+1 , candidates , target - i * candidates[u]) ;             ans.push_back(candidates[u]) ;                 &#125;        for(int i = 0 ; i * candidates[u] <= target && i <= ha[candidates[u]] ; ++ i)                &#123;            ans.pop_back() ;         &#125;        return ;     &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="组合总和III"><a href="#组合总和III" class="headerlink" title="组合总和III"></a>组合总和III</h2><p><a href="https://leetcode-cn.com/problems/combination-sum-iii/">216. 组合总和 III - 力扣（LeetCode） (leetcode-cn.com)</a></p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    vector<int> ans ;    vector<vector<int>> res ;             vector<vector<int>> combinationSum3(int k, int n) &#123;        dfs(1 , 0 , k , n) ;        return res ;     &#125;        void dfs(int start , int u , int k , int n)    &#123;        if(u == k)        &#123;            int num = accumulate(ans.begin() , ans.end() , 0) ;             if(num == n)            &#123;                res.push_back(ans) ;                 return  ;             &#125;        &#125;           for(int i = start ; i <= 9; ++ i)        &#123;            if(i > n)                return  ;             ans.push_back(i) ;             dfs(i + 1 , u + 1 , k , n ) ;             ans.pop_back() ;         &#125;        return ;     &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ok,今天就mark到这，我人已经麻了………</p>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 240</title>
      <link href="/2021/10/25/leetcode-240/"/>
      <url>/2021/10/25/leetcode-240/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>题目意思比较明确，在一个行升序且列升序的二维矩阵中，查找一个数。</p><p>由于leetcode的很多题目，范围给的不是很明确。</p><p>但是很显然，这既然是一个中等难度的题目，暴力肯定是过不去的，虽然有时候leetcode的难度的标注是比较玄学的。</p><p>那我们想到了一个可以稍微简化一点的操作，那就是二分。</p><p>我想到的是，先对行考虑，二分每行的末尾元素，找到第一个大于等于target的行数。</p><p>在此行往下，对每一行进行二分操作，查找是否有与target相等的元素。</p><p>贴个代码：</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    bool binary(int m , vector<int> a , int target)    &#123;        int l = 0 ; int r = m  ;         while(l < r)        &#123;            int mid = l + r >> 1 ;            if(a[mid] == target)            &#123;                return true ;             &#125;            else if(a[mid] > target)            &#123;                r = mid ;             &#125;            else            &#123;                l = mid + 1 ;             &#125;        &#125;        return false ;     &#125;    bool searchMatrix(vector<vector<int>>& matrix, int target) &#123;        int n = matrix.size() ;         int m = matrix[0].size() ;         int l = 0 ;  int r = n -1 ;         while(l < r)        &#123;            int mid = l + r >> 1 ;             if(matrix[mid][m-1] >= target)            &#123;                r = mid ;             &#125;            else            &#123;                l = mid + 1 ;             &#125;        &#125;        for(int i = l ; i < n  ; ++ i)        &#123;            if(binary(m , matrix[i] , target))            &#123;                return true ;             &#125;        &#125;        return false ;     &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是情况不是很乐观，时间只打败了5%……</p><p>最后翻阅题解，找到了一种很容易理解，而且时间更短的做法。</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution&#123;    public:    bool searchMatrix(vector<vector<int>>& matrix, int target)&#123;        int n = matrix.size() ;        int m = matrix[0].size() ;         int i = n - 1 ;         int j = 0  ;         while(i >= 0 && j < m)        &#123;            if(matrix[i][j] == target)            &#123;                return true ;             &#125;            else if(matrix[i][j] > target)            &#123;                j ++  ;             &#125;            else            &#123;                i -- ;            &#125;        &#125;           return false ;     &#125;&#125; ; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实就是有点像z字抖动。起点是从左下角开始，如果遇到的值比target小 ， 就往右走，反之，就往上走。</p><p>是好方法，mark一下，等之后，遇到了扩展问题希望可以想起来。</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>thrift-learning</title>
      <link href="/2021/10/24/thrift-learning/"/>
      <url>/2021/10/24/thrift-learning/</url>
      
        <content type="html"><![CDATA[<p>在学习thrift的时候，看到了一篇非常详细的文章，特地mark一下，学习之后，自己也会出一篇blog，专门说一下thrift。</p><blockquote><p>个人整理thrift笔记</p></blockquote><ul><li><a href="#%E7%AC%AC%E5%85%AD%E8%AE%B2-thrift">第六讲 thrift</a><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#thrift-idl">Thrift IDL</a></li><li><a href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAthrift%E6%9C%8D%E5%8A%A1">如何创建一个Thrift服务?</a></li></ul></li><li><a href="#%E6%8E%A5%E4%B8%8B%E6%9D%A5%E5%86%99%E4%B8%AA%E6%A0%97%E5%AD%90%E6%9D%A5%E7%86%9F%E6%82%89thrift%E7%9A%84%E4%BD%BF%E7%94%A8">接下来写个栗子来熟悉thrift的使用</a><ul><li><a href="#%E4%B8%80%E4%B8%AA%E6%B8%B8%E6%88%8F%E7%9A%84%E5%8C%B9%E9%85%8D%E6%9C%8D%E5%8A%A1%E5%88%86%E6%9E%90">一个游戏的匹配服务分析</a><ul><li><a href="#%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93">分析总结:</a></li></ul></li><li><a href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%B8%B8%E6%88%8F%E7%9A%84%E5%8C%B9%E9%85%8D%E6%9C%8D%E5%8A%A1">实现一个游戏的匹配服务</a><ul><li><a href="#%E5%90%8D%E5%AD%97%E7%A9%BA%E9%97%B4namespace">①名字空间NameSpace</a></li><li><a href="#%E7%BB%93%E6%9E%84%E4%BD%93struct">②结构体struct</a></li><li><a href="#-%E6%9C%8D%E5%8A%A1%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8Bservice">③ 服务定义类型Service</a></li><li><a href="#-%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E4%B9%8B%E5%90%8E%E5%85%88%E5%AE%9E%E7%8E%B0match-server">④ 定义服务接口之后，先实现match-server</a></li><li><a href="#-%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91thrift%E7%94%9F%E6%88%90%E7%9A%84c%E4%BB%A3%E7%A0%81">⑤ 如何编译thrift生成的C++代码?</a></li><li><a href="#-%E5%AE%9E%E7%8E%B0match-client">⑥ 实现match-client</a></li><li><a href="#-%E5%B0%86match-client%E7%9A%84%E4%BB%A3%E7%A0%81%E6%94%B9%E6%88%90%E4%BB%8E%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E4%B8%AD%E8%8E%B7%E5%8F%96%E4%BF%A1%E6%81%AF">⑦ 将match-client的代码改成从标准输入中获取信息</a></li><li><a href="#-%E5%AE%8C%E5%96%84match-server">⑧ 完善match-server</a></li><li><a href="#-%E5%AE%9E%E7%8E%B0save_client">⑨ 实现save_client</a></li><li><a href="#-%E5%8D%87%E7%BA%A7match-server">⑩ 升级match-server</a></li><li><a href="#-%E5%B0%86thrift%E7%9A%84%E5%8D%95%E7%8B%ACserver%E6%A8%A1%E5%BC%8F%E6%94%B9%E6%88%90%E5%A4%9A%E7%BA%BF%E7%A8%8Bserver%E6%A8%A1%E5%BC%8F">⑪ 将thrift的单独Server模式改成多线程Server模式</a></li><li><a href="#-%E6%B7%BB%E5%8A%A0match-server%E7%9A%84%E8%A7%84%E5%88%99">⑫ 添加match-server的规则</a></li></ul></li></ul></li><li><a href="#%E7%9F%A5%E8%AF%86%E7%82%B9">知识点:</a><ul><li><a href="#c-%E5%A4%B4%E6%96%87%E4%BB%B6">C 头文件</a></li><li><a href="#using-namespace-std%E7%9A%84%E4%BD%9C%E7%94%A8">using namespace std的作用</a></li><li><a href="#localhost127001-%E5%92%8C-%E6%9C%AC%E6%9C%BAip-%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB">localhost，127.0.0.1 和 本机IP 三者的区别</a></li><li><a href="#%E7%AB%AF%E5%8F%A3">端口)</a></li><li><a href="#include-thread"><code>#include &lt;thread&gt;</code></a></li><li><a href="#%E4%BA%92%E6%96%A5%E9%94%81">互斥锁</a></li><li><a href="#include-condition_variable">#include <condition_variable></a></li><li><a href="#c%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89">C++中类的定义</a></li><li><a href="#vector%E7%9A%84size%E6%98%AF%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B">vector的size()是无符号整数类型。</a></li><li><a href="#vector%E7%9A%84erase%E6%98%AF%E5%B7%A6%E9%97%AD%E5%8F%B3%E5%BC%80">vector的erase()是左闭右开。</a></li><li><a href="#%E6%B1%82%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84md5%E5%80%BC">求一个字符串的md5值。</a></li><li><a href="#%E8%8B%B1%E8%AF%AD%E7%9F%A5%E8%AF%86">英语知识</a></li></ul></li></ul><hr><h1 id="第六讲-thrift"><a href="#第六讲-thrift" class="headerlink" title="第六讲 thrift"></a>第六讲 thrift</h1><blockquote><p>我们写一个应用时，这个应用程序并不止一个服务，而且不同的服务分配到不同服务器(或者进程)上，也就是我们常说的<a href="https://baike.baidu.com/item/%E5%BE%AE%E6%9C%8D%E5%8A%A1/18758759?fr=aladdin">微服务</a> 。</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://thrift.apache.org/">thrift官网</a><br><strong>官网教程:进入官网-&gt;Tutorial-&gt;tutorial.thrift</strong></p><p><strong>Apache Thrift</strong>软件框架用于可伸缩的跨语言服务开发，它将<strong>软件栈</strong>和<strong>代码生成引擎</strong>结合在一起，以构建在C++、Java、Python、PHP、Ruby、Erlang、Perl、Haskell、C#、Cocoa、JavaScript、Node.js、Smalltalk、OCaml和Delphi等语言之间高效、无缝地工作的服务。</p><p><strong>Thrift使用C++进行编写</strong>，在安装使用的时候需要安装依赖，windows安装方式见官网即可。安装方式：<a href="http://thrift.apache.org/docs/install/">thrift官网介绍安装方式</a> </p><pre><code>thrift -version //查看thrift版本</code></pre><hr><h2 id="Thrift-IDL"><a href="#Thrift-IDL" class="headerlink" title="Thrift IDL"></a>Thrift IDL</h2><p>Thrift 采用IDL（Interface Definition Language）来定义通用的服务接口，然后通过Thrift提供的编译器，可以将服务接口编译成不同语言编写的代码，通过这个方式来实现跨语言的功能。</p><ul><li>通过命令调用Thrift提供的编译器将服务接口编译成不同语言编写的代码。</li><li>这些代码又分为服务端和客户端，将所在不同进程(或服务器)的功能连接起来。</li></ul><pre><code>thrift -r --gen &lt;language&gt; &lt;Thrift filename&gt;</code></pre><hr><h2 id="如何创建一个Thrift服务"><a href="#如何创建一个Thrift服务" class="headerlink" title="如何创建一个Thrift服务?"></a>如何创建一个Thrift服务?</h2><ol><li>定义服务接口(存放接口的文件夹就是thrift文件)</li><li>作为服务端的服务，需要生成server。</li><li>作为请求端的服务，需要生成client。</li></ol><hr><h1 id="接下来写个栗子来熟悉thrift的使用"><a href="#接下来写个栗子来熟悉thrift的使用" class="headerlink" title="接下来写个栗子来熟悉thrift的使用"></a>接下来写个栗子来熟悉thrift的使用</h1><h2 id="一个游戏的匹配服务分析"><a href="#一个游戏的匹配服务分析" class="headerlink" title="一个游戏的匹配服务分析"></a>一个游戏的匹配服务分析</h2><p><strong>一般情况如图所示</strong></p><p><img src="https://cdn.acwing.com/media/article/image/2021/10/05/97206_32d5aa8525-%E6%97%A0%E6%A0%87%E9%A2%98.png" alt="无标题.png"> </p><p><strong>分析图示内容</strong><br>这个游戏的功能可能运行在一个或多个服务器(或进程)上，而thrift就是将不同服务器不同语言的功能连接起来。<br>图中的三个节点(功能)是完全独立的，既可以在同一个服务器上，也可以在不同服务器上。<br>每一个节点就是一个进程，每个进程可以使用不同的语言来实现。</p><ul><li>在GAME节点上实现客户端通过调用匹配系统的服务端中实现的两个服务接口函数获取功能，实现跨语言跨服务的工作。</li><li>每个节点(功能)之间通过thrift定义的服务接口作为有向边进行连接。<br>弧尾所在的节点创建客户端，弧头所在的节点创建服务端。</li><li>匹配系统节点实现服务端，其中有一个匹配池：不断的接收玩家和删除玩家，同时根据一定的规则给每个玩家安排一局游戏。</li><li>匹配系统节点实现客户端，通过调用数据存储节点的服务端中实现的一个服务接口函数获取功能，实现跨语言跨服务的工作。</li><li>每个功能(节点)之间通过thrift定义的服务接口作为有向边进行连接。<br>弧尾所在的节点创建客户端，弧头所在的节点创建服务端。</li><li>数据存储节点实现服务端。别人已经将服务接口和服务端实现好了。</li><li>服务接口功能介绍:<br>add_user：向匹配池中添加玩家。<br>remove_user：从匹配池中删除玩家。<br>save_data：将匹配信息存储起来。</li></ul><p><strong>补充</strong></p><ul><li>有向边也称弧,边的始点称为弧尾,终点称为弧头。</li><li>当做项目时，可能有人已经将服务接口实现好了，即将服务端实现了，我们只需要创建客户端即可。</li></ul><h3 id="分析总结"><a href="#分析总结" class="headerlink" title="分析总结:"></a>分析总结:</h3><p>在实现服务之前，最好先画个图分析，这样目标明确、思路清晰。</p><p><strong>图中的要素</strong></p><ol><li>不同服务作为节点</li><li>每个服务是在哪个服务器上实现的</li><li>每个服务通过什么语言实现</li><li>服务之间通过怎样的服务接口进行连接。</li><li>通过业务逻辑确认每个服务需要创建哪些服务端和客户端。</li></ol><hr><h2 id="实现一个游戏的匹配服务"><a href="#实现一个游戏的匹配服务" class="headerlink" title="实现一个游戏的匹配服务"></a>实现一个游戏的匹配服务</h2><p>这里为了方便我们需要创建两个文件夹表示game节点(game)和匹配服务节点(match_system)，其实也可以放在不同的服务器上，不过条件不允许啊😉，而数据存储节点的服务端已经实现好了，只要调用服务接口实现的函数即可。</p><p>接下来创建一个thrift文件夹存储.thrift文件，.thrift文件定义服务接口。其中有两个.thrift文件分别表示两条有向边，一条有向边可以包含多个服务接口。</p><p>先定义服务接口。<br>定义添加玩家和删除玩家的两个接口。<br>在thrift文件夹中，创建match.thrift文件。然后进行接下来的内容。</p><hr><h3 id="①名字空间NameSpace"><a href="#①名字空间NameSpace" class="headerlink" title="①名字空间NameSpace"></a>①名字空间NameSpace</h3><p>Thrift中的命名空间类似于C++中的namespace和java中的package，它们提供了一种组织（隔离）代码的简便方式。名字空间也可以用于解决类型定义中的名字冲突。</p><p>由于每种语言均有自己的命名空间定义方式（如:python中有module）, thrift允许开发者针对特定语言定义namespace。</p><p>简单的demo：</p><pre><code>namespace java com.xtxxtx.test</code></pre><p>转换成</p><pre><code>package com.xtxxtx.test</code></pre><p><strong>教程中的介绍:</strong></p><pre><code>/** * Thrift files can namespace, package, or prefix their output in various * target languages. */namespace cl tutorialnamespace cpp tutorial  namespace d tutorialnamespace dart tutorialnamespace java tutorialnamespace php tutorialnamespace perl tutorialnamespace haxe tutorialnamespace netstd tutorial//匹配系统我们用C++实现。//语法:namespace 使用的语言 空间名称namespace cpp match_dao</code></pre><hr><h3 id="②结构体struct"><a href="#②结构体struct" class="headerlink" title="②结构体struct"></a>②结构体struct</h3><p>数据类型在结构体中定义。<br>struct有以下一些约束：</p><ol><li>struct不能继承，但是可以嵌套，不能嵌套自己。(0.12.0版本可以支持嵌套自己本身)</li><li>其成员都是有明确类型</li><li>成员是被正整数编号过的，其中的编号使不能重复的，这个是为了在传输过程中编码使用。</li><li>成员分割符可以是逗号（,）或是分号（;），而且可以混用</li><li>字段会有optional和required之分和protobuf一样，但是如果不指定则为无类型–可以不填充该值，但是在序列化传输的时候也会序列化进去，optional是不填充则部序列化，required是必须填充也必须序列化。</li><li>每个字段可以设置默认值</li><li>同一文件可以定义多个struct，也可以定义在不同的文件，进行include引入。</li></ol><p><strong>教程中介绍:</strong></p><pre><code>/** * Structs are the basic complex data structures. They are comprised of fields * which each have an integer identifier, a type, a symbolic name, and an * optional default value. * * Fields can be declared &quot;optional&quot;, which ensures they will not be included * in the serialized output if they aren&#39;t set.  Note that this requires some * manual management in some languages. */ struct Work &#123;  1: i32 num1 = 0, //默认值  2: i32 num2, //默认字段类型是optional  3: Operation op,  4: optional string comment,  5: required string name, //本字段必须填充&#125;//这里我们定义结构体用来存储用户信息。其中i32表示int，string表示字符串。struct User &#123;    1: i32 id,    2: string name,    3: i32 score,&#125;</code></pre><p>规则：</p><ul><li>如果required标识的域没有赋值，Thrift将给予提示；</li><li>如果optional标识的域没有赋值，该域将不会被序列化传输；</li><li>如果某个optional标识域有缺省值而用户没有重新赋值，则该域的值一直为缺省值；</li><li>如果某个optional标识域有缺省值或者用户已经重新赋值，而不设置它的__isset为true，也不会被序列化传输。</li></ul><hr><h3 id="③-服务定义类型Service"><a href="#③-服务定义类型Service" class="headerlink" title="③ 服务定义类型Service"></a>③ 服务定义类型Service</h3><p>服务的定义方法在语义上等同于面向对象语言中的接口。比如java中的接口，只是参数需要加上编号。</p><p><strong>教程中介绍:</strong></p><pre><code>/** * Ahh, now onto the cool part, defining a service. Services just need a name * and can optionally inherit from another service using the extends keyword. */service Calculator extends shared.SharedService &#123;  /**   * A method definition looks like C code. It has a return type, arguments,   * and optionally a list of exceptions that it may throw. Note that argument   * lists and exception lists are specified using the exact same syntax as   * field lists in struct or exception definitions.   */   void ping(),   i32 add(1:i32 num1, 2:i32 num2),   i32 calculate(1:i32 logid, 2:Work w) throws (1:InvalidOperation ouch),   /**    * This method has a oneway modifier. That means the client only makes    * a request and does not listen for any response at all. Oneway methods    * must be void.    */   oneway void zip()&#125;/**  * 我们需要定义两个接口方法:add_user(), remove_user()  * 其中`2: string info`表示额外信息。  * 作用:以后想要更改接口时，不用更改接口，你可以直接将想传的信息传入到info中，  * 然后对info进行序列化一个jinsen即可。  */service Match &#123;    i32 add_user(1: User user, 2: string info),    i32 remove_user(1: User user, 2: string info),&#125;</code></pre><hr><h3 id="④-定义服务接口之后，先实现match-server"><a href="#④-定义服务接口之后，先实现match-server" class="headerlink" title="④ 定义服务接口之后，先实现match-server"></a>④ 定义服务接口之后，先实现match-server</h3><p><strong>如何通过接口生成C++版本的服务端?</strong></p><pre><code>//通过这个命令就可以实现，不过在此之前需要做一些准备工作。//tutorial.thrift表示从当前目录到定义接口的路径。thrift -r --gen cpp tutorial.thrift</code></pre><p>具体操作如图所示:<br><img src="https://cdn.acwing.com/media/article/image/2021/10/03/97206_24b6e98123-2021-10-02_213443.png" alt="2021-10-02_213443.png"> </p><ul><li>做到这里我们发现:有了接口之后，通过命令就可以生成C++版本的服务端相关的代码。但是具体业务我们还是需要具体写哦!</li><li>$\color{red}{好习惯:写thrift服务的时候，先编译成功，然后再逐步向文件中添加模块。}$</li></ul><hr><h3 id="⑤-如何编译thrift生成的C-代码"><a href="#⑤-如何编译thrift生成的C-代码" class="headerlink" title="⑤ 如何编译thrift生成的C++代码?"></a>⑤ 如何编译thrift生成的C++代码?</h3><p>因为$Thrift$由<code>C++</code>编写，所以编译的过程与<code>C++</code>一样。<br>本质就是编译一堆<code>C++</code>源文件(.cpp)。<br>$\color{green}{C++编译过程:}$<br>$\color{red}{①编译}$<br><img src="https://cdn.acwing.com/media/article/image/2021/10/03/97206_13c8927a23-2021-10-03_092958.png" alt="2021-10-03_092958.png"><br>$\color{red}{②链接}$<br><img src="https://cdn.acwing.com/media/article/image/2021/10/03/97206_26c2852823-2021-10-03_095345.png" alt="2021-10-03_095345.png"><br><img src="https://cdn.acwing.com/media/article/image/2021/10/03/97206_5ee3260f23-2021-10-03_100004.png" alt="2021-10-03_100004.png"><br><img src="https://cdn.acwing.com/media/article/image/2021/10/03/97206_d47a471223-2021-10-03_103957.png" alt="2021-10-03_103957.png"> </p><ul><li>好习惯:可执行文件和编译好的文件最好不要加进去，只加.cpp和.h文件。</li></ul><p>C++编译很慢，链接很快。所以每次修改项目，重新编译时，只需要编译修改过的.cpp文件即可，防止编译时间过长。<br>即修改哪个文件就编译哪个文件。<br>基于这一点考虑就有了make和cmake工具。但没啥用。</p><pre><code>//前面加上time查看编译和链接的时间。time g++ -c .cpp文件time g++ -o .o文件 -lthrift -pthread</code></pre><hr><h3 id="⑥-实现match-client"><a href="#⑥-实现match-client" class="headerlink" title="⑥ 实现match-client"></a>⑥ 实现match-client</h3><pre><code>//使用该命令创建python版本的服务端，然后通过修改得到客户端。//这个命令python2和python3是兼容的。thrift -r --gen py tutorial.thrift</code></pre><p><img src="https://cdn.acwing.com/media/article/image/2021/10/03/97206_48b9a10724-2021-10-03_152548.png" alt="2021-10-03_152548.png"><br><img src="https://cdn.acwing.com/media/article/image/2021/10/04/97206_0dfd243725-2021-10-03_131330.png" alt="2021-10-03_131330.png"><br><img src="https://cdn.acwing.com/media/article/image/2021/10/03/97206_90e9ef8424-2021-10-03_154417.png" alt="2021-10-03_154417.png"><br><img src="https://cdn.acwing.com/media/article/image/2021/10/03/97206_e47583d524-2021-10-03_155550.png" alt="2021-10-03_155550.png"> </p><ul><li>$\color{red}{好习惯:每完成一个客户(服务)端时，推荐使用git进行持久化。}$</li></ul><hr><blockquote><p>现在client端还不是很方便。因为每次都需要运行一下代码，而且代码是写死的。</p></blockquote><h3 id="⑦-将match-client的代码改成从标准输入中获取信息"><a href="#⑦-将match-client的代码改成从标准输入中获取信息" class="headerlink" title="⑦ 将match-client的代码改成从标准输入中获取信息"></a>⑦ 将match-client的代码改成从标准输入中获取信息</h3><p><img src="https://cdn.acwing.com/media/article/image/2021/10/03/97206_c14535c824-2021-10-03_161948.png" alt="2021-10-03_161948.png"><br>至此，game的client端就完成了。最后将其持久化作为最终版。</p><ul><li>$\color{red}{好习惯:在编译和运行时，产生的文件都不要持久化，这没有意义，只会占用网络带宽，会显得你的仓库不专业。}$</li></ul><hr><blockquote><p>写server端需要分析业务模型。<br>需要进行监控，支持增加用户和删除用户。同时还要有一个线程去不停地进行匹配。<br>这个时候，我们发现需要实现两个功能，添加删除用户和匹配用户，根据微服务的概念需要开两个进程实现两个功能。</p></blockquote><h3 id="⑧-完善match-server"><a href="#⑧-完善match-server" class="headerlink" title="⑧ 完善match-server"></a>⑧ 完善match-server</h3><p>完善server端需要并利用<code>C++</code>实现多线程。视频定位：55:30</p><p>项目代码中有注解。</p><p>编译C++时，如果你用到了线程，需要加上线程的动态链接库的参数<code>-pthread</code>。<br><code>-lthrift</code>参数将所有thrift动态连接文件连接起来。</p><pre><code>g++ *.o -o main -lthrift -pthread</code></pre><hr><h3 id="⑨-实现save-client"><a href="#⑨-实现save-client" class="headerlink" title="⑨ 实现save_client"></a>⑨ 实现save_client</h3><p>因为一个节点(功能)只能由一个main方法作为程序的入口，所以匹配系统中的客户端和服务端写在同一个main方法中。我们这里根据逻辑将其实现在一个函数中。</p><ul><li>注意:复制教程中的代码时，一些细节需要更改。例如:其中带Calculator的字段都需要更改。</li><li>一些thrift接口和服务端有人会帮我们实现，这时我们只需调用接口实现的函数即可。例如:这里使用已经实现好的save_data()接口。</li></ul><hr><blockquote><p>我们现在的匹配系统是傻瓜式匹配，从队头逮到两个人就匹配成功，所以需要制定一些规则进行升级。<br>这里我们指定分差50以内的进行匹配。</p></blockquote><h3 id="⑩-升级match-server"><a href="#⑩-升级match-server" class="headerlink" title="⑩ 升级match-server"></a>⑩ 升级match-server</h3><hr><blockquote><p>一个线程处理输入输出，如果以后要处理并发量时，需要开多个线程处理。</p></blockquote><h3 id="⑪-将thrift的单独Server模式改成多线程Server模式"><a href="#⑪-将thrift的单独Server模式改成多线程Server模式" class="headerlink" title="⑪ 将thrift的单独Server模式改成多线程Server模式"></a>⑪ 将thrift的单独Server模式改成多线程Server模式</h3><p><img src="https://cdn.acwing.com/media/article/image/2021/10/05/97206_d6beb85525-2021-10-05_092449.png" alt="2021-10-05_092449.png"> </p><hr><h3 id="⑫-添加match-server的规则"><a href="#⑫-添加match-server的规则" class="headerlink" title="⑫ 添加match-server的规则"></a>⑫ 添加match-server的规则</h3><p>匹配机制：等待时间越长，阈值越大。即匹配的范围随时间的推移而变大<br>故需要记录当前玩家在匹配池中等待的秒数。</p><p>至此，游戏的匹配服务就全部完成了。</p><hr><hr><hr><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点:"></a>知识点:</h1><h2 id="C-头文件"><a href="#C-头文件" class="headerlink" title="C 头文件"></a><a href="https://www.runoob.com/cprogramming/c-header-files.html">C 头文件</a></h2><p>C 语言中 include &lt;&gt; 与include “” 的区别?<br><code>#include &lt; &gt;</code>:引用的是编译器的类库路径里面的头文件。<br><code>#include &quot; &quot;</code>:引用的是你程序目录的相对路径中的头文件，如果在程序目录没有找到引用的头文件则到编译器的类库路径的目录下找该头文件。</p><h2 id="using-namespace-std的作用"><a href="#using-namespace-std的作用" class="headerlink" title="using namespace std的作用"></a><a href="https://baike.baidu.com/item/using%20namespace%20std/10360651?fr=aladdin">using namespace std的作用</a></h2><p>C++标准程序库中的所有标识符都被定义于一个名为std的namespace中。 由于namespace的概念，使用C++标准程序库的任何标识符时，可以有三种选择，具体看百度百科。<br>但是如果加上这段代码，就不用前缀。<br>比如:<br><code>std::cout &lt;&lt; std::endl;</code>加上using namespace std后，就可以写成这样<code>cout &lt;&lt; endl</code>。<br><code>std::ios::sync_with_stdio(false);</code>加上using namespace std后，就可以写成这样<code>ios::sync_with_stdio(false);</code>。(想了解<a href="https://blog.csdn.net/weixin_51333606/article/details/116738816">ios::sync_with_stdio(false);</a> 用法开这篇文章)</p><h2 id="localhost，127-0-0-1-和-本机IP-三者的区别"><a href="#localhost，127-0-0-1-和-本机IP-三者的区别" class="headerlink" title="localhost，127.0.0.1 和 本机IP 三者的区别"></a>localhost，127.0.0.1 和 本机IP 三者的区别</h2><h2 id="端口"><a href="#端口" class="headerlink" title="端口)"></a><a href="https://baike.baidu.com/item/%E7%AB%AF%E5%8F%A3/103505?fr=aladdin">端口</a>)</h2><p>如果把IP地址比作一间房子 ，端口就是出入这间房子的门。真正的房子只有几个门，但是一个IP地址的端口可以有65536（即：2^16）个之多！端口是通过端口号来标记的，端口号只有整数，范围是从0 到65535（2^16-1）。<br>同一个端口只能由一个进程来监听。所以我们一旦启动了一个服务，那么这个服务就不能在被另一个进程启动了。<br>服务器的端口号要与客户端的端口号相同。</p><hr><blockquote><p>每执行一个程序就是开了一个进程。每一个进程可以开一堆线程。<br>开多线程的开销是很小的，开多进程的开销是很大的。</p></blockquote><h2 id="include-lt-thread-gt"><a href="#include-lt-thread-gt" class="headerlink" title="#include &lt;thread&gt;"></a><code>#include &lt;thread&gt;</code></h2><p>C++中有一个thread的库，可以用来开线程。<br>通过定义一个变量将函数名作为参数，就能开一个线程了。<br>首先定义线程的操作。<br>并行中经典的生产者和消费者模型。<br>生产者、消费者是两个线程。<br>生产者:add_user()、remove_user()<br>消费者:匹配用户的功能。<br>生产者和消费者之间需要一个媒介。<br>这个媒介可以有很多种方法。比如:消费队列。<br>很多语言都有自己实现的消费队列，也可以自己实现消费队列。<br>实现消费队列，就需要用到一些锁(mutex)。<br>并行编程的基本概念:锁。</p><hr><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>在编程中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。每个对象都对应于一个可称为” 互斥锁” 的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。</p><p>锁🔒有两个操作。一个P操作(上锁)，一个V操作(解锁)。<br>定义互斥锁:mutex m;<br>锁一般使用信号量来实现的，mutex其实就是一个信号量(它特殊也叫互斥量)。互斥量就是同一时间能够分给一个人，即S=1。<br>信号量S:S=10表示可以将信号量分给10个人来用。</p><p>P操作的主要动作是:<br>①S减1；<br>②若S减1后仍大于或等于0，则进程继续执行；<br>③若S减1后小于0，则该进程被阻塞后放入等待该信号量的等待队列中，然后转进程调度。<br>V操作的主要动作是：<br>①S加1；<br>②若相加后结果大于0，则进程继续执行；<br>③若相加后结果小于或等于0，则从该信号的等待队列中释放一个等待进程，然后再返回原进程继续执行或转进程调度。</p><p>对于P和V都是原子操作，就是在执行P和V操作时，不会被插队。从而实现对共享变量操作的原子性。<br>特殊:S=1表示互斥量，表示同一时间，信号量只能分配给一个线程。</p><p>多线程为啥要用锁? 因为多线程可能共享一个内存空间，导致出现重复读取并修改的现象。</p><hr><h2 id="include"><a href="#include" class="headerlink" title="#include "></a>#include <condition_variable></h2><hr><h2 id="C-中类的定义"><a href="#C-中类的定义" class="headerlink" title="C++中类的定义"></a>C++中类的定义</h2><hr><h2 id="vector的size-是无符号整数类型。"><a href="#vector的size-是无符号整数类型。" class="headerlink" title="vector的size()是无符号整数类型。"></a>vector的size()是无符号整数类型。</h2><hr><h2 id="vector的erase-是左闭右开。"><a href="#vector的erase-是左闭右开。" class="headerlink" title="vector的erase()是左闭右开。"></a>vector的erase()是左闭右开。</h2><hr><h2 id="求一个字符串的md5值。"><a href="#求一个字符串的md5值。" class="headerlink" title="求一个字符串的md5值。"></a>求一个字符串的md5值。</h2><p>输入命令”md5sum”，输入字符串回车然后<code>Ctrl + d</code>就行了。<br>md5加密</p><hr><blockquote><p>随着学习的深入，用到英语的地方越来越多，很多技术都是外国实现，中国的计算机技术还需要我辈去完善创新。<br>先从英语开始吧。每篇一记。</p></blockquote><h2 id="英语知识"><a href="#英语知识" class="headerlink" title="英语知识"></a>英语知识</h2><ul><li>IDL:接口定义语言（Interface Definition Language）</li><li>RPC:远程过程调用（Remote Procedure Call）</li><li>client:客户，客户端</li></ul><p><font face="楷书" color=red>最后说一句，会了英语学编程真香，不说了，我去学英语了。</font></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tmux</title>
      <link href="/2021/10/22/tmux/"/>
      <url>/2021/10/22/tmux/</url>
      
        <content type="html"><![CDATA[<h1 id="tmux-终端复用工具"><a href="#tmux-终端复用工具" class="headerlink" title="tmux-终端复用工具"></a>tmux-终端复用工具</h1><h2 id="一、tmux介绍"><a href="#一、tmux介绍" class="headerlink" title="一、tmux介绍"></a>一、tmux介绍</h2><p>tmux是一款终端复用工具。我们在做项目或者在维护服务器的时候，如果用自身所带的工具，终端关闭直接就结束进程，这是很不安全的做法。因为一旦你在工作的时候，发生了一些小事故，如停电，或者是电脑发生了故障，那么你没有保存的工作可能会发生丢失。</p><p>同时，正常来说，一个终端只可以连接一个server，只会有一个session，一个window，一个pane。</p><p>但是tmux可以同时连接多个服务器，可以开若干个session，若干个window，若干个pane。大大增加了工作的效率与便捷性。</p><p>同时，tmux可以将当前的行为挂在后台，即使关闭了当前的terminal，进程依然会在后台进行，使得工作的进度得以保留下来，之后如果想要查找的时候，直接<code>tmux a</code> 即可找回。</p><h2 id="二、优点"><a href="#二、优点" class="headerlink" title="二、优点"></a>二、优点</h2><p>（1）它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。</p><p>（2） 它可以让新窗口”接入”已经存在的会话。</p><p>（3）它允许每个会话有多个连接窗口，因此可以多人实时共享会话。</p><p>（4）它还支持窗口任意的垂直和水平拆分。</p><h2 id="三、常用命令"><a href="#三、常用命令" class="headerlink" title="三、常用命令"></a>三、常用命令</h2><p><code>tmux</code> 新建一个session，这个session里面有一个window，window里面有一个pane，pane里面有shell语句。</p><p>申明一下，tmux的前缀建是<code>ctrl + b</code> ，以下命令未进行申明前缀建的用法都是按下后松开。有少数是需要前缀键和命令键需要同时按下的。</p><h3 id="pane"><a href="#pane" class="headerlink" title="pane"></a>pane</h3><p><code>ctrl + b + %</code>  将当前选中的pane平分成左右两个pane</p><p><code>ctrl + b + &quot;</code> 将当前选中的pane平分成上下两个pane</p><p><code>ctrl + d </code> 关闭当前选中的pane，如果当前的pane是window仅有的一个pane，那么直接会关闭window。同理，关闭session</p><p><code>ctrl + b + 方向键</code> 切换选中的pane</p><p><code>ctrl + b + 方向键(同时)</code> 移动pane之间的分割线，按一次动一下</p><p><code>ctrl + b + z</code> 将当前选中的pane变成全屏,再按一下即可恢复。</p><p><code>ctrl + b + pageup</code> tmux阅读的时候比较麻烦。可以用鼠标或者是方向键进行翻阅内容，按ESC进行退出</p><h3 id="window"><a href="#window" class="headerlink" title="window"></a>window</h3><p><code>ctrl + b + c</code> 在当前的session中再创建一个window。</p><p><code>ctrl + b + w</code> 选择当前session的window</p><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p><code>ctrl + b + d</code> 将当前的session放在后台</p><p><code>ctrl + b + s</code> 选择其他session</p><p><code>tmux a</code> 挂起之前的session</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>n-皇后问题</title>
      <link href="/2021/10/21/n-huang-hou-wen-ti/"/>
      <url>/2021/10/21/n-huang-hou-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="n-皇后问题"><a href="#n-皇后问题" class="headerlink" title="n-皇后问题"></a>n-皇后问题</h1><hr><p>n−皇后问题是指将 n 个皇后放在 n×n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。</p><p><img src="https://cdn.acwing.com/media/article/image/2019/06/08/19_860e00c489-1_597ec77c49-8-queens.png" alt="1_597ec77c49-8-queens.png"></p><p>现在给定整数 n，请你输出所有的满足条件的棋子摆法。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>共一行，包含整数 n。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>每个解决方案占 n 行，每行输出一个长度为 n 的字符串，用来表示完整的棋盘状态。</p><p>其中 <code>.</code> 表示某一个位置的方格状态为空，<code>Q</code> 表示某一个位置的方格上摆着皇后。</p><p>每个方案输出完成后，输出一个空行。</p><p><strong>注意：行末不能有多余空格。</strong></p><p>输出方案的顺序任意，只要不重复且没有遗漏即可。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤9</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>4</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>.Q.....QQ.....Q...Q.Q......Q.Q..</code></pre><hr><p>dfs的经典题目。</p><p>直接贴一个代码：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 20  ;char a[N][N] ; int n ; bool col[N] , dg[N] , udg[N] ; void dfs(int u)&#123;    if(u == n)    &#123;        for(int i = 0 ; i < n ;++ i)        &#123;            puts(a[i]) ;         &#125;        puts("") ;     &#125;    for(int i = 0 ; i < n ; ++ i)    &#123;        if(!col[i] && !dg[u + i ] && !udg[u - i + n])        &#123;            a[u][i] = 'Q' ;             col[i] = dg[u+i] = udg[u-i+n] = true  ;             dfs(u+1) ;             col[i] = dg[u+i] = udg[u-i+n] = false  ;            a[u][i] = '.' ;         &#125;    &#125;    return  ; &#125;int main()&#123;    cin >> n ;         for(int i = 0 ; i < n ; ++ i)    &#123;        for(int j = 0 ; j < n ; ++ j)        &#123;            a[i][j] = '.' ;         &#125;    &#125;    dfs(0) ;        return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全排列</title>
      <link href="/2021/10/21/quan-pai-lie/"/>
      <url>/2021/10/21/quan-pai-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="排列数字"><a href="#排列数字" class="headerlink" title="排列数字"></a>排列数字</h1><hr><p>给定一个整数 n，将数字 1∼n 排成一排，将会有很多种排列方法。</p><p>现在，请你按照字典序将所有的排列方法输出。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>共一行，包含一个整数 n。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>按字典序输出所有排列方案，每个方案占一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤7</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>3</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>1 2 31 3 22 1 32 3 13 1 23 2 1</code></pre><hr><p>dfs的分析方法</p>]]></content>
      
      
      
        <tags>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 66</title>
      <link href="/2021/10/21/leetcode-66/"/>
      <url>/2021/10/21/leetcode-66/</url>
      
        <content type="html"><![CDATA[<h1 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h1><p><a href="https://leetcode-cn.com/problems/plus-one/">66. 加一 - 力扣（LeetCode） (leetcode-cn.com)</a></p><h1 id="贴个代码"><a href="#贴个代码" class="headerlink" title="贴个代码"></a>贴个代码</h1><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    vector<int> plusOne(vector<int>& digits) &#123;        int n = digits.size() ;                 for(int i = n-1 ; i >= 0 ; --i)        &#123;            digits[i] ++ ;             if(digits[i] <= 9)                return digits ;             digits[i] = 0 ;         &#125;        digits.insert(digits.begin() , 1) ;         return digits ;     &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很麻利，思路清晰。</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一种简单但是很费时间的贪心题模板</title>
      <link href="/2021/10/20/yi-chong-jian-dan-dan-shi-hen-fei-shi-jian-de-tan-xin-ti-mo-ban/"/>
      <url>/2021/10/20/yi-chong-jian-dan-dan-shi-hen-fei-shi-jian-de-tan-xin-ti-mo-ban/</url>
      
        <content type="html"><![CDATA[<h1 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h1><hr><p>给定 n 个区间 [li,ri]，要求合并所有有交集的区间。</p><p>注意如果在端点处相交，也算有交集。</p><p>输出合并完成后的区间个数。</p><p>例如：[1,3] 和 [2,6] 可以合并为一个区间[1,6]。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n。</p><p>接下来 n 行，每行包含两个整数 l 和 r。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含一个整数，表示合并区间完成后的区间个数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤100000,<br>−109≤li≤ri≤109</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>51 22 45 67 87 9</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>3</code></pre><hr><p>题目的意思比较简单，就是有一些区间，给你他的起始点和终止点，让你将遇到的小区间合并成一个大区间，并最终返回大区间的个数。</p><p>思路一般是先将这些起始点和终点按照起始点有小到大排序，如果遇到起始点相同的，就排序他的终点，终点也是有小到大进行排序，这样可以省去一些麻烦。</p><p>思路比较简单，但是实现起来有一些细节要注意一下：</p><p>算了，先上代码：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 100010 ; struct region&#123;    int start ;     int end ; &#125; re[N]; int main()&#123;    int n ;     cin >> n  ;         for(int i = 1 ; i <= n ; ++ i )    &#123;        cin >> re[i].start >> re[i].end ;    &#125;        sort(re + 1  , re + n + 1 , [] (region x , region y)         &#123;             if(x.start == y.start)             &#123;                 return x.end < y.end ;              &#125;             return x.start < y.start ;          &#125;) ;         re[n+1].start = re[n].end + 1  ;  //个人觉得比较妙的一步，他直接限制了下面的for循环必须是if结尾的，就省去了一些麻烦        int start = re[1].start  ;     int end = re[1].end ;     int num =  1  ;         for(int i = 2 ; i <= n + 1 ; ++ i)    &#123;         if(re[i].start > end)        &#123;            num ++ ;             start = re[i].start ;             end = re[i].end ;         &#125;        else        &#123;            end = max(end , re[i].end) ;         &#125;    &#125;        cout << num << endl ;         return  0;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同理，我们再来看与她极其相似的一道题</p><h1 id="校门外的树"><a href="#校门外的树" class="headerlink" title="校门外的树"></a>校门外的树</h1><hr><p>某校大门外长度为 L 的马路上有一排树，每两棵相邻的树之间的间隔都是 1 米。</p><p>我们可以把马路看成一个数轴，马路的一端在数轴 0 的位置，另一端在 L 的位置；数轴上的每个整数点，即0，1，2，……，L，都种有一棵树。</p><p>由于马路上有一些区域要用来建地铁。</p><p>这些区域用它们在数轴上的起始点和终止点表示。</p><p>已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。</p><p>现在要把这些区域中的树（包括区域端点处的两棵树）移走。</p><p>你的任务是计算将这些树都移走后，马路上还有多少棵树。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入文件的第一行有两个整数 L和 M，L 代表马路的长度，M 代表区域的数目，L 和 M 之间用一个空格隔开。</p><p>接下来的 M 行每行包含两个不同的整数，用一个空格隔开，表示一个区域的起始点和终止点的坐标。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出文件包括一行，这一行只包含一个整数，表示马路上剩余的树的数目。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤L≤10000,<br>1≤M≤100</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>500 3150 300100 200470 471</code></pre><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>298</code></pre><hr><p>这一题我一开始没仔细看题目，就直接盯着样例看了老半天。</p><p>我一开始想的是，<code>这一共500棵树</code>，我怎么算都是297呀，为什么是298呢？？？</p><p>原来是，0-500…….哈哈，那没事了。</p><p>所以一共是501棵树。</p><p>思路与上题几乎一样</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 110 ; struct region&#123;    int start  ;     int end ; &#125; re[N]; int main()&#123;    int n , m  ;     cin >> n >> m ;     n ++ ;        for(int i = 1 ; i <= m ; ++ i)    &#123;          cin >> re[i].start >> re[i].end ;       &#125;        sort(re + 1 , re + 1 + m , [] (region x , region y)         &#123;             if(x.start == y.start)             &#123;                 return x.end < y.end ;              &#125;             return x.start < y.start ;          &#125;) ;         re[m+1].start = 10001 ; //将x        int start  = re[1].start ;     int end = re[1].end ;         int res = 0 ;         for(int i = 2 ; i <= m + 1 ; ++ i)    &#123;        if(re[i].start > end)        &#123;            res += (end - start + 1) ;             start = re[i].start ;             end = re[i].end ;         &#125;        else        &#123;            end = max(end , re[i].end) ;         &#125;    &#125;    cout << n - res << endl ;     return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑雪场设计</title>
      <link href="/2021/10/17/hua-xue-chang-she-ji/"/>
      <url>/2021/10/17/hua-xue-chang-she-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="滑雪场设计"><a href="#滑雪场设计" class="headerlink" title="滑雪场设计"></a>滑雪场设计</h1><hr><p>农夫约翰的农场上有 N个山峰，每座山的高度都是整数。</p><p>在冬天，约翰经常在这些山上举办滑雪训练营。</p><p>不幸的是，从明年开始，国家将实行一个关于滑雪场的新税法。</p><p>如果滑雪场的最高峰与最低峰的高度差大于17，国家就要收税。</p><p>为了避免纳税，约翰决定对这些山峰的高度进行修整。</p><p>已知，增加或减少一座山峰 x 单位的高度，需要花费 x2 的金钱。</p><p>约翰<strong>只愿意改变整数单位</strong>的高度，且每座山峰<strong>只能修改一次</strong>。</p><p>请问，约翰最少需要花费多少钱，才能够使得最高峰与最低峰的高度差不大于17。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 N。</p><p>接下来 N 行，每行包含一个整数，表示一座山的高度。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最少花费的金钱。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤1000,<br>数据保证，每座山的初始高度都在 0∼100 之间。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>520412421</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>18</code></pre><h4 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h4><p>最佳方案为，将高度为 1 的山峰，增加 3 个单位高度，将高度为 24 的山峰，减少 3 个单位高度。</p><hr><p>其实这一题的话，如果你想不到用枚举来做的话，是很难想的。因为这一题，你进行将最小的加上去之后，可能他就不是最小的了，最大的减去之后，他有可能就不是最大的了。可能会有新的两座山峰不满足情况，也就是说，这一题中的两座山峰是动态变化的，所以想要通过找最大和最小来做的方法基本就GG了。</p><p>那我们怎么做呢？我们要学着在动中找变，正好我们观察一下数据，<code>每座山峰的高度在1~100之间</code>。</p><p>我们可以进行枚举修剪后最矮山峰的高度low , low显然是在1-83以内，然后让超过的山峰满足在17以内，低于low的山峰，修改到low，依次来计算一下费用。然后比较一下，输出最小费就行了。</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 1010 ; int a[N] ; int main()&#123;    int n ;     cin >> n ;         for(int i = 1 ; i <= n  ; ++ i)    &#123;        cin >> a[i] ;     &#125;        //枚举一下 low    int res = 1e9 ;     for(int low = 1 ; low <= 83 ; ++ low)    &#123;        int fee = 0  ;        for(int i = 1 ; i <= n ; ++ i)        &#123;             if(a[i] < low)            &#123;                fee += pow(low - a[i] , 2) ;             &#125;            if(a[i] > low + 17)            &#123;                fee  += pow(a[i] - low - 17 , 2) ;              &#125;        &#125;        res = min (fee , res) ;     &#125;    cout << res << endl ;     return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有时候当一个思路受阻的时候，要学着换一种思路，不要一条根本不通的路想要走到黑，只是浪费时间而已。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分巧克力</title>
      <link href="/2021/10/17/fen-qiao-ke-li/"/>
      <url>/2021/10/17/fen-qiao-ke-li/</url>
      
        <content type="html"><![CDATA[<h1 id="分巧克力"><a href="#分巧克力" class="headerlink" title="分巧克力"></a>分巧克力</h1><hr><p>儿童节那天有 K 位小朋友到小明家做客。</p><p>小明拿出了珍藏的巧克力招待小朋友们。</p><p>小明一共有 N 块巧克力，其中第 i 块是Hi×Wi 的方格组成的长方形。</p><p>为了公平起见，小明需要从这 N 块巧克力中切出 K 块巧克力分给小朋友们。</p><p>切出的巧克力需要满足：</p><ol><li>形状是正方形，边长是整数</li><li>大小相同</li></ol><p>例如一块 6×5 的巧克力可以切出 6 块 2×2 的巧克力或者 2 块 3×3 的巧克力。</p><p>当然小朋友们都希望得到的巧克力尽可能大，你能帮小明计算出最大的边长是多少么？</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 N 和 K。</p><p>以下 N 行每行包含两个整数 Hi 和 Wi。</p><p>输入保证每位小朋友至少能获得一块 1×1 的巧克力。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出切出的正方形巧克力最大可能的边长。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N,K≤105,<br>1≤Hi,Wi≤105</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>2 106 55 6</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>2</code></pre><hr><p>本题可以简化成</p><p>在1-1e5之中，找一个最大的mid，使得check(mid) 的值&gt;=target，最后返回这样一个最大的值即可。</p><p>由于上升序列，我们可以用二分来进行查找。(属于二分的妙用了)。</p><p>说真的，到现在我还是不怎么会真正的将二分给活用，唉，用的比较机械，对边界条件还是需要花时间来进行考虑，还是要多加练习吧。</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 1e5 + 5 ; int n , m ;int a[N] , b[N] ; int check(int num)&#123;    int res = 0  ;    for(int i = 1 ; i <= n ; ++ i)    &#123;        int ans = (a[i]/num)*(b[i]/num) ;         res += ans ;     &#125;    return res ; &#125;int main()&#123;    cin >> n >> m ;        for(int i = 1 ; i <= n ; ++ i)    &#123;        cin >> a[i] >> b[i] ;     &#125;        int l  = 1 ; int r = 100000 ;     while(l < r)    &#123;        int mid = l + r + 1 >> 1 ;         if(check(mid) >= m)        &#123;            l = mid ;         &#125;        else        &#123;            r = mid -1  ;        &#125;    &#125;    cout << l << endl ;         return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要的经验是，一是可以对题目进行深度提炼。</p><p>二是，查找的时候，二分可以查找符合条件的第一个与最后一个，像本题就是查找最后一个。翻译成中文就是从1到100000里面找一个数，这个数要符合check的条件，同时这个数要是这个集合中最大的，对于上升序列来说，其实就是查找符合条件的最右边的数字。</p>]]></content>
      
      
      
        <tags>
            
            <tag> acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维前缀和</title>
      <link href="/2021/10/16/er-wei-qian-zhui-he/"/>
      <url>/2021/10/16/er-wei-qian-zhui-he/</url>
      
        <content type="html"><![CDATA[<h1 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h1><p>列举一下最近遇到的二维前缀和的题目：</p><p>大同小异，可以总结一下模板</p><p>注意二维前缀和计算以及运用的共同之处。</p><h2 id="最大的和"><a href="#最大的和" class="headerlink" title="最大的和"></a>最大的和</h2><hr><p>给定一个包含整数的二维矩阵，子矩形是位于整个阵列内的任何大小为 1×1 或更大的连续子阵列。</p><p>矩形的总和是该矩形中所有元素的总和。</p><p>在这个问题中，具有最大和的子矩形被称为最大子矩形。</p><p>例如，下列数组：</p><pre><code>0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 </code></pre><p>其最大子矩形为：</p><pre><code>9 2 -4 1 -1 8 </code></pre><p>它拥有最大和 15。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入中将包含一个 N×N 的整数数组。</p><p>第一行只输入一个整数 N，表示方形二维数组的大小。</p><p>从第二行开始，输入由空格和换行符隔开的 N2 个整数，它们即为二维数组中的 N2 个元素，输入顺序从二维数组的第一行开始向下逐行输入，同一行数据从左向右逐个输入。</p><p>数组中的数字会保持在 [−127,127]的范围内。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，代表最大子矩形的总和。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤100</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>40 -2 -7 0 9 2 -6 2-4 1 -4  1 -18  0 -2</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>15</code></pre><hr><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 110 ; int s[N][N] ; int main()&#123;    int n ;     cin >> n ;         for(int i = 1 ; i <= n ; ++ i)    &#123;        for(int j = 1 ; j <= n ; ++ j)        &#123;            cin >> s[i][j] ;            s[i][j] += s[i-1][j] + s[i][j-1]  - s[i-1][j-1] ;        &#125;    &#125;        int res = -128 ;         for(int x1 = 1 ; x1 <= n ; ++ x1)    &#123;        for(int y1 = 1 ; y1 <= n ; ++ y1)        &#123;            for(int x2 = x1 ; x2 <= n ; ++ x2)            &#123;                for(int y2 = y1 ; y2 <= n ; ++ y2)                &#123;                    int ans = s[x2][y2] + s[x1-1][y1-1] - s[x1-1][y2] - s[x2][y1-1] ;                     res = max(res , ans) ;                 &#125;            &#125;        &#125;    &#125;        cout << res << endl ;     return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="激光炸弹"><a href="#激光炸弹" class="headerlink" title="激光炸弹"></a>激光炸弹</h2><hr><p>地图上有 N 个目标，用整数 Xi,Yi 表示目标在地图上的位置，每个目标都有一个价值 Wi。</p><p><strong>注意</strong>：不同目标可能在同一位置。</p><p>现在有一种新型的激光炸弹，可以摧毁一个包含 R×R 个位置的正方形内的所有目标。</p><p>激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个正方形的边必须和 x，y 轴平行。</p><p>求一颗炸弹最多能炸掉地图上总价值为多少的目标。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入正整数 N 和 R，分别代表地图上的目标数目和正方形的边长，数据用空格隔开。</p><p>接下来 N 行，每行输入一组数据，每组数据包括三个整数Xi,Yi,Wi，分别代表目标的 x 坐标，y 坐标和价值，数据用空格隔开。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>0≤R≤109<br>0&lt;N≤10000<br>0≤Xi,Yi≤5000<br>0≤Wi≤1000</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>2 10 0 11 1 1</code></pre><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>1</code></pre><hr><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 5011 ; int s[N][N] ; int main()&#123;    int n  , r;    cin >> n >> r;        r = min(r , 5010) ;         int x = r ;  int y = r ;         for(int i = 1 ; i <= n ; ++ i)    &#123;        int a , b , c ;         cin >> a >> b >> c ;         s[a+1][b+1] += c ;        x = max(x , a  + 1)  ;  y = max(y , b + 1) ;    &#125;        for(int i = 1 ; i <= x ; ++ i)    &#123;        for(int j = 1 ; j <= y ;++ j)        &#123;            s[i][j] = s[i][j] + s[i-1][j] + s[i][j-1] - s[i-1][j-1] ;        &#125;    &#125;        int res = 0 ;         for(int i = r ; i <= x ; ++ i)    &#123;        for(int j = r ; j <= y ;++ j)        &#123;           int x1 = i - r + 1 ;            int y1 = j - r + 1 ;                       int ans = s[i][j] + s[x1-1][y1-1] - s[x1-1][j] - s[i][y1-1] ;                         res = max(res , ans) ;         &#125;    &#125;    cout <<  res << endl ;         return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="子矩阵的和"><a href="#子矩阵的和" class="headerlink" title="子矩阵的和"></a>子矩阵的和</h2><hr><p>输入一个 n 行 m 列的整数矩阵，再输入 q个询问，每个询问包含四个整数 x1,y1,x2,y2，表示一个子矩阵的左上角坐标和右下角坐标。</p><p>对于每个询问输出子矩阵中所有数的和。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含三个整数 n，m，q。</p><p>接下来 n 行，每行包含 m 个整数，表示整数矩阵。</p><p>接下来 q 行，每行包含四个整数 x1,y1,x2,y2，表示一组询问。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 q 行，每行输出一个询问的结果。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n,m≤1000,<br>1≤q≤200000,<br>1≤x1≤x2≤n,<br>1≤y1≤y2≤m,<br>−1000≤矩阵内元素的值≤1000</p><h4 id="输入样例：-2"><a href="#输入样例：-2" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>3 4 31 7 2 43 6 2 82 1 2 31 1 2 22 1 3 41 3 3 4</code></pre><h4 id="输出样例：-2"><a href="#输出样例：-2" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>172721</code></pre><hr><pre class="line-numbers language-c++"><code class="language-c++">#include<bits/stdc++.h>using namespace std ;const int N = 1010 ; int w[N][N] ; int main()&#123;    int n , m , q ;     cin >> n >>  m >> q ;         for(int i = 1 ; i <= n ; ++ i)    &#123;        for(int j = 1 ; j <= m ; ++ j)        &#123;            cin >> w[i][j] ;             w[i][j] += w[i-1][j] + w[i][j-1] - w[i-1][j-1] ;         &#125;    &#125;            for(int i = 1 ; i <= q ; i ++)    &#123;        int x1 , y1 , x2 , y2 ;         cin >> x1 >> y1 >> x2 >> y2 ;                 int res = w[x2][y2] - w[x1-1][y2] - w[x2][y1-1] + w[x1-1][y1-1] ;         cout << res << endl ;     &#125;    return 0 ;     &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结一下三道题目共同点：</p><h2 id="存储前缀和"><a href="#存储前缀和" class="headerlink" title="存储前缀和"></a>存储前缀和</h2><p>在计算二维前缀和的时候，在初始化的时候，只有在一个位置只有一个数字的情况下，可以只用一个数组来完成。</p><p>例如第一题和第三题，可以只开一个数组节省空间。</p><p>但是第二题，细节比较多，因为他是相同位置会有不同的值，所以不可以只用一个数组来进行存储。</p><h2 id="利用前缀和"><a href="#利用前缀和" class="headerlink" title="利用前缀和"></a>利用前缀和</h2><p>一般都是求矩形内二维元素的和。</p><p>我们可以用模板来说明一下。</p><pre class="line-numbers language-c++"><code class="language-c++">for(int i = 1 ; i <= n  ; ++ i)&#123;    for(int j = 1 ; j <= m ; ++ j)    &#123;        s[i][j] += s[i-1][j] + s[i][j-1] - s[i-1][j-1] ;  //构造二维前缀和的模板    &#125;&#125;//比如要计算子矩阵的和，我们的重点应该放在右下角//例一：遍历任意子矩阵for(int i = 1 ; i <= x1 ; i ++)&#123;    for(int j = 1 ; j <= y1 ; ++ j)    &#123;        for(int k = 1 ; k <= x2 ; ++ k)        &#123;            for(int l = 1 ; l <= y2 ; ++l )            &#123;                int res = s[k][l] - s[i-1][l] - s[k][j-1] + s[i-1][j-1] ;             &#125;        &#125;    &#125;&#125;//例二：遍历有固定边界的子矩阵//r为正方形的边长for(int x2 = r ; x2 <= x ; ++ x2)&#123;    for(int y2 = r ; y2 <= y ; ++ y2)    &#123;        int x1 = x2 - r + 1 ;         int y1 = y2 - r + 1 ；         int res = s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1] ;//减一的都是x1，这个规律可以记住    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求gcd</title>
      <link href="/2021/10/16/qiu-gcd/"/>
      <url>/2021/10/16/qiu-gcd/</url>
      
        <content type="html"><![CDATA[<h1 id="求最大公约数"><a href="#求最大公约数" class="headerlink" title="求最大公约数"></a>求最大公约数</h1><p>小tips，就是简单mark一下欧几里得算法。</p><pre class="line-numbers language-c++"><code class="language-c++">int gcd(int a , int b)&#123;    return b ? (gcd(b , a%b)) : a ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>算了，还是贴一题吧….</p><h1 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h1><hr><p>给定 n 对正整数 ai,bi，请你求出每对数的最大公约数。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n。</p><p>接下来 n 行，每行包含一个整数对 ai,bi。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出共 n 行，每行输出一个整数对的最大公约数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤105,<br>1≤ai,bi≤2×109</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>23 64 6</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>32</code></pre><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;int gcd(int a , int b)&#123;    return b ? gcd(b,a%b) : a ; &#125;int main()&#123;    int n ;     cin >> n ;    while(n--)    &#123;        int a , b ;         cin >> a >> b ;                 int res = gcd(a , b) ;                cout << res << endl ;     &#125;        return 0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 小tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划一日一题-10-14-货币系统</title>
      <link href="/2021/10/14/dong-tai-gui-hua-yi-ri-yi-ti-10-14-huo-bi-xi-tong/"/>
      <url>/2021/10/14/dong-tai-gui-hua-yi-ri-yi-ti-10-14-huo-bi-xi-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="货币系统"><a href="#货币系统" class="headerlink" title="货币系统"></a>货币系统</h1><hr><p>给定 V种货币（单位：元），每种货币使用的次数不限。</p><p>不同种类的货币，面值可能是相同的。</p><p>现在，要你用这 V 种货币凑出 N 元钱，请问共有多少种不同的凑法。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 V 和 N。</p><p>接下来的若干行，将一共输出 V 个整数，每个整数表示一种货币的面值。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示所求总方案数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤V≤25<br>1≤N≤10000<br>答案保证在<code>long long</code>范围内。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>3 101 2 5</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>10</code></pre><hr><p>好的，这一题是明显的dp问题，特征非常明显，以至于让我第一次看到，就想到了完全背包和整数划分两道题目，应该就是需要稍微数学归纳一下就可以找出来状态转移方程了。</p><p>还是老样子的思维模式：</p><p>状态表示：f[i] [j] 表示用前i个物品，正好凑出target的方案数</p><p>状态属性：种类</p><p>base case：f[i] [0] = 1 ; </p><p>状态转移：</p><p>f[i] [j] = f[i-1] [j] + f[i-1] [j-v[i]] + f[i-1] [j-2*v[i]] + ……..</p><p>f[i] [j-v[i]] =            f[i-1] [j-v[i]] + f[i-1] [j-2*v[i]] + ……..</p><p>好的，合并一下，f[i] [j] = f[i-1] [j] + f[i] [j-v[i]] ;</p><p>好的，直接上代码，但是有一个关键点，此题是让你正好凑成target，所以要保证所有的状态都是由f[0] 转移过来的。</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ; const int N = 10010 ; long long f[N][N] ;int a[N] ; int main()&#123;    int n , target ;     cin >> n >> target ;        for(int i = 1 ; i <= n ; ++ i)    &#123;        cin >> a[i] ;     &#125;        for(int i = 1 ; i <= n ; ++ i)        f[i][0] = 1 ;         for(int i = 1 ; i <= n ; ++ i)    &#123;        for(int j = 1 ; j <= target ; ++ j)        &#123;            f[i][j] = f[i-1][j] ;             if(j >= a[i])            &#123;                f[i][j] += f[i][j-a[i]] ;            &#125;        &#125;    &#125;        cout << f[n][target] << endl ;         return 0  ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好，同样的道理，可以同完全背包一样进行一维优化。</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 100010 ; int a[N] ; long long f[N] ; int main()&#123;    int n , m ;         cin >> n >> m ;         f[0] = 1 ;     for(int i = 1 ; i <= n ; ++ i)    &#123;        cin >> a[i] ;      &#125;        for(int i = 1 ; i <= n ; ++ i)    &#123;        for(int j = 1 ; j <= m ; ++ j)        &#123;            if(j >= a[i])            &#123;                f[j] += f[j-a[i]];            &#125;        &#125;    &#125;        cout << f[m] << endl ;         return  0 ;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 一日一题 背包dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找硬币</title>
      <link href="/2021/10/14/zhao-ying-bi/"/>
      <url>/2021/10/14/zhao-ying-bi/</url>
      
        <content type="html"><![CDATA[<h1 id="找硬币"><a href="#找硬币" class="headerlink" title="找硬币"></a>找硬币</h1><hr><p>伊娃喜欢从整个宇宙中收集硬币。</p><p>有一天，她去了一家宇宙购物中心购物，结账时可以使用各种硬币付款。</p><p>但是，有一个特殊的付款要求：每张帐单，她只能使用<strong>恰好</strong>两个硬币来<strong>准确</strong>的支付消费金额。</p><p>给定她拥有的所有硬币的面额，请你帮她确定对于给定的金额，她是否可以找到两个硬币来支付。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 N 和 M，分别表示硬币数量以及需要支付的金额。</p><p>第二行包含 N 个整数，表示每个硬币的面额。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一行，包含两个整数 V1,V2，表示所选的两个硬币的面额，使得 V1≤V2 并且 V1+V2=M。</p><p>如果答案不唯一，则输出 V1最小的解。</p><p>如果无解，则输出 <code>No Solution</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤105,<br>1≤M≤1000</p><h4 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h4><pre><code>8 151 2 8 7 2 4 11 15</code></pre><h4 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h4><pre><code>4 11</code></pre><h4 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h4><pre><code>7 141 8 7 2 4 11 15</code></pre><h4 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h4><pre><code>No Solution</code></pre><hr><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>因为，本想着要一直坚持每日更新dp的题目的，但是一是因为dp的题目难度不小，二是还有很多其他值得记录的题目，所以，dp就随缘更新吧，但是每日刷题是必须的，等下次找到很妙，或者是有共性的dp问题，我再打卡吧。</p><p>本题还是比较水的一道题目，其实有点像leetcode的第一题，两数之和的题目。但是leetcode的那一题给的数据范围比较宽泛，本题是105，所以时间复杂度为2的算法就过不了。</p><p>好吧，这时候hash表就要派上用场了。</p><p>我们可以将值作为key存入hash表，然后value就是他的下标。我们可以进行依次遍历，然后用hash的find函数，找到hash表中是否有与他进行配对的值。若有直接返回下标。若没有，就直接cout <code>No Solution</code> .</p><p>贴个代码：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 100010 ; unordered_map<int , int> ha ; int a[N] ; int main()&#123;    int n , target ;     cin >> n >> target ;         for(int i = 1 ; i <= n ; ++ i)    &#123;        cin >> a[i] ;     &#125;        sort(a , a+n+1) ;         for(int i = 1 ; i <= n ; ++ i)    &#123;        ha[a[i]] = i  ;     &#125;         int id1  , id2 ;         for(int i = 1 ; i <= n ; ++ i)    &#123;        auto pos = ha.find(target-a[i]) ;                if(pos != ha.end() && pos->second != i)        &#123;            id1 = i ;             id2 = pos->second ;             cout << a[id1] << " " << a[id2]  ;             return 0 ;        &#125;    &#125;        cout << "No Solution" << endl ;     return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好吧，今天发的确实好水……</p><p>贴个leetcode第一题的代码</p><p><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和 - 力扣（LeetCode） (leetcode-cn.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>manacher算法</title>
      <link href="/2021/10/13/manacher-suan-fa/"/>
      <url>/2021/10/13/manacher-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="manacher算法"><a href="#manacher算法" class="headerlink" title="manacher算法"></a>manacher算法</h1><p>书接上回，最长回文字符串的长度那一道题，挖了一个坑，今天来介绍一下manacher算法(马拉车)。</p><p>是一种比较高效的处理寻找最长回文字符串的方法，时间复杂度可以达到O(n) . </p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划一日一题-10-12-最长公共上升子序列</title>
      <link href="/2021/10/12/dong-tai-gui-hua-yi-ri-yi-ti-10-12-zui-chang-gong-gong-shang-sheng-zi-xu-lie/"/>
      <url>/2021/10/12/dong-tai-gui-hua-yi-ri-yi-ti-10-12-zui-chang-gong-gong-shang-sheng-zi-xu-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="最长公共上升子序列"><a href="#最长公共上升子序列" class="headerlink" title="最长公共上升子序列"></a>最长公共上升子序列</h1><hr><p>熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目。</p><p>小沐沐先让奶牛研究了最长上升子序列，再让他们研究了最长公共子序列，现在又让他们研究最长公共上升子序列了。</p><p>小沐沐说，对于两个数列 A 和 B，如果它们都包含一段位置不一定连续的数，且数值是严格递增的，那么称这一段数是两个数列的公共上升子序列，而所有的公共上升子序列中最长的就是最长公共上升子序列了。</p><p>奶牛半懂不懂，小沐沐要你来告诉奶牛什么是最长公共上升子序列。</p><p>不过，只要告诉奶牛它的长度就可以了。</p><p>数列 A 和 B 的长度均不超过 3000。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含一个整数 N，表示数列 A，B的长度。</p><p>第二行包含 N 个整数，表示数列 A。</p><p>第三行包含 N 个整数，表示数列 B。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最长公共上升子序列的长度。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤3000,序列中的数字均不超过 231−1。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>42 2 1 32 1 2 3</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>2</code></pre><hr><p>好吧，我承认看到题就直接懵逼了…….</p><p>我们之前做过最长上升子序列和最长公共子序列。这里就简单回顾一下一些基本的参数。</p><p>LIS：</p><p>状态表示：dp[i] 表示从1到i的序列中，且是以i结尾的，最长的上升子序列的长度。</p><p>状态属性：max</p><p>base case：dp[i] = 1 ; </p><p>状态转移：用i做一次遍历，然后用j往前进行遍历，如果遇到符合要求的，继续找最大值即可。</p><pre class="line-numbers language-c++"><code class="language-c++">for(int i = 1 ; i <= n ; ++ i)&#123;    dp[i] = 1 ;     for(int j = i-1 ; j >= 0 ; --j)    &#123;        if(a[i] > a[j])        dp[i] = max(dp[i] , dp[j]  + 1) ;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>LCS：</p><p>状态表示：dp[i] [j] 表示a串的1-i， 到b串的1-j，中最长的公共子序列，不一定要是以j结尾。</p><p>状态属性：max</p><p>base case：dp[i] [0] = 0 ;  dp[0] [i] = 0  ;</p><p>状态转移：</p><p>if 相等  dp[i] [j] = dp[i-1] [j-1]  + 1 ;  </p><p>else      dp[i] [j] = max(dp[i-1] [j] , dp[i] [j-1]) ;</p><pre class="line-numbers language-c++"><code class="language-c++">for(int i = 1 ; i <= n ; ++i)&#123;    for(int j = 1 ; j <= n ;++ j)    &#123;        if(a[i] == b[j])        &#123;            f[i][j] = f[i-1][j-1]  + 1 ;         &#125;        else        &#123;            f[i][j] = max(f[i-1][j] , f[i][j-1]) ;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好，其实这一题就是上述两题的融合。</p><p>我们学着来自行分析一下基本参数：</p><p>状态表示：dp[i] [j] 表示a串1-i ， b串1-j， 且b串以j结尾的序列的包含的最长公共上升子序列。</p><p>(为什么非要是以j结尾呢？不以任何结尾行吗)（为什么不以i结尾？）</p><p>状态属性：max</p><p>base case：同LCS，但是申请全局变量了，就不需要显性的申明了。</p><p>状态转移：</p><p>if 相等  由于j是定位符的特性，找到倒数第二个满足最长公共上升子序列的j的下标，要以此来进行转移。</p><p>贴个代码：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 3010 ; int a[N] , b[N] ; int f[N][N] ;int main()&#123;    int n ;     cin >> n ;     for(int i = 1 ; i <= n ; ++ i)    &#123;        cin >> a[i] ;     &#125;        for(int i = 1 ;  i <= n ; ++ i)    &#123;        cin >> b[i] ;    &#125;        for(int i = 1 ; i <= n ; ++i)    &#123;        for(int j = 1 ; j <= n ; ++ j)        &#123;            f[i][j] = f[i-1][j] ;             if(a[i] == b[j])            &#123;                 f[i][j] = max(f[i][j] , 1) ;                for(int k = 1 ;  k < j ; ++ k)                &#123;                    if(b[k] < b[j])                    &#123;                        f[i][j] = max(f[i][j] , f[i-1][k] + 1) ;                    &#125;                &#125;            &#125;        &#125;    &#125;        int res = 0 ;     for(int i = 1 ; i <= n ; ++i)    &#123;        res = max(res , f[n][i]) ;    &#125;    cout << res << endl ;    return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码是完全根据我们的思路来走的，属于是最朴素的代码，我们可以看到有三层循环。数据范围是在1000左右的，最后应该会TLE。</p><p>所以，我们如何才能有三轮优化成两轮？？？</p><p>明天再更….. 今天累了</p><p>——————-10-13 再更————————————————————————————————————————–</p><p>昨天实在没有领悟到精髓之处，在经历了这一道题对我的知识框架的冲击与重建之后，我开始寻找y总的dp分析法与我自己总结的方法的共同之处，现在还在领悟之中。</p><p>y总的分析法，主要着重于集合分析，主要着重于状态转移的时候，可以将集合分成两个不重不漏的集合，然后对每个集合进行细分，每个集合取自己的状态属性，然后大的方面再取两个集合的总属性。</p><p>今天再次看到这道题感觉又有了新的思路：</p><p>又再次重温了一下LIS与LCS的例题，想要通过这两道题目找到一些新的思路。</p><p>我们可以看出来，LCIS这道题在表示的过程中，确实是借鉴了前两道题，既有LIS的以i结尾的设法，也有LCS的模糊性设法。</p><p>整个dp的状态转移的过程其实就是以LCS作为前提，在进入前提之后，在去用LIS的方法去找到符合要求的状态表示 。 同时注意一下，转移时候的一些细节即可。至于y总说的，将集合凭借用a[i] 与不用来进行划分可以理解，其实就是我说的，思考来源的过程，考虑a[i]其实就是自身较大，不考虑其实就是通过自身之前的状态进行转移，只能说我只能凭借我对这道题目的理解来强行解释这种思路，看起来可以解释的通，但是却没有找到一个可以让自己先手就立即想到的理由。</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 3010 ; int a[N] , b[N] ; int f[N][N] ;int main()&#123;    int n ;     cin >> n ;    int res = 0  ;     for(int i = 1 ; i <= n ; ++ i)    &#123;        cin >> a[i] ;     &#125;        for(int i = 1 ; i <= n ; ++ i)    &#123;        cin >> b[i] ;     &#125;        for(int i = 1 ; i <= n ; ++i)    &#123;        for(int j = 1 ; j <= n ; ++j)        &#123;            f[i][j] = f[i-1][j] ;             //便于迭代，要不然没有东西迭代了            if(a[i] == b[j])                    //进入LCS的前提            &#123;                f[i][j] = max(f[i][j] , 1) ;                for(int k = 1 ; k < j ; ++k )     //LIS的模式                &#123;                    if(b[k] < b[j])                    f[i][j] = max(f[i][j] , f[i-1][k]  + 1) ;                &#125;            &#125;            res = max(res , f[i][j]) ;        &#125;    &#125;        cout << res << endl ;     return 0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好吧，感觉像是理解了，但是应该是未完全理解。之后等自己再继续刷题，说不定过一段时间之后就成了显然了&gt;_&lt;.</p><p>好的，主要思路就是上述，但是这题的数据是3000，如果暴力的话，没话说，直接超时。我们想着可以进行优化，但是空间上我们不用去管它。</p><p>对于时间上的优化，我们一般采用的是等价转换，单纯从代码上进行修改。</p><p>想要把时间复杂度优化成2，所以就要想办法将最后一个循环灭了。最后一个循环主要是找到j以前的状态找到符合要求的然后进行转移。</p><p>那我们有没有一种可能，提前就可以将这一个最大值就直接储存起来，就直接省去了最后一个步骤。</p><p>Talk is cheap , show me your code .</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 3010 ; int a[N] , b[N] ; int f[N][N] ; int main()&#123;     int n ;     cin >> n ;    for(int i = 1 ; i <= n ; ++i)        cin >> a[i] ;        for(int j = 1 ; j <= n ; ++j)        cin >> b[j] ;        for(int i = 1 ; i <= n ; ++i)    &#123;        int maxv = 1 ;         for(int j = 1 ; j <= n ; ++j )        &#123;            f[i][j]  = f[i-1][j] ;             if(a[i] == b[j])            &#123;                f[i][j] = max(f[i][j] , maxv) ;             &#125;            if(a[i] > b[j])            &#123;                maxv = max(maxv , f[i-1][j]  + 1) ;             &#125;        &#125;    &#125;        int res = 0 ;         for(int i =1 ; i <= n ; ++ i)    &#123;        res = max(res , f[n][i]) ;        &#125;        cout << res << endl ;        return 0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好吧，在懂了思路逻辑之后，进行修改就比较好理解了。</p><p>由于遍历顺序是由小到大，所以我们完全可以针对每一个i来优先定义一个maxv，主要是用于储存最大的倒数第二的值，(这样说好像有一点抽象)， 其实就是省略了一部再找最大值的步骤，他是从一个小循环的一开始，就定义了一个基底，用于找最大值，跟这循环一起走的，就完全不需要再开一个循环进行查找了。这样就可以将时间复杂度降低到2了。</p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>其实在看y总的讲解之后，我是感觉有点被打破思考模式的感觉，就是感觉就算是做了前置的LIS与LCS，但是遇到这种题，思路还是没有明显。</p><p>甚至有很多问题：</p><p>一、为什么要以j定位？</p><p>二、如何体现有c有l？</p><p>总之，刷题的意义在于利用旧的知识，在遇到新的问题的时候，可以顺利的想到多种以前可以顺利解决的思路。所以，如果遇到一个问题，你感觉他不是你的框架里面的东西，但是看了答案之后，却发现你可以利用现有的知识完全的解决他们。这可以说明两个事情：</p><p>一、对以往的问题思考不够深入</p><p>二、知识框架过于片面与呆板</p><p>总之，学习能力的提升过程其实就是不断建立自己的思维模式的过程，不断建立，然后不断打破，然后再进行建立，这是正常过程。</p><p>继续坚持，随着时间与问题的堆积，你的思维模式会越来越多元化，框架会越来越硬，由flask变成django(hhhhh，玩个小梗) 。量变引起质变。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 一日一题 线性dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划一日一题-10-11-最长回文子串</title>
      <link href="/2021/10/11/dong-tai-gui-hua-yi-ri-yi-ti-10-11-zui-chang-hui-wen-zi-chuan/"/>
      <url>/2021/10/11/dong-tai-gui-hua-yi-ri-yi-ti-10-11-zui-chang-hui-wen-zi-chuan/</url>
      
        <content type="html"><![CDATA[<h1 id="最长回文子串与最长回文子序列的爱恨情仇"><a href="#最长回文子串与最长回文子序列的爱恨情仇" class="headerlink" title="最长回文子串与最长回文子序列的爱恨情仇"></a>最长回文子串与最长回文子序列的爱恨情仇</h1><hr><p>给定一个字符串，请你求出其中的最长回文子串的长度。</p><p>例如，给定字符串 <code>Is PAT&amp;TAP symmetric?</code>，最长回文子串为 <code>s PAT&amp;TAP s</code>，其长度是 1111。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>包含一个非空字符串。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示给定字符串的最长回文子串的长度。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>给定字符串的长度不超过 1000。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>Is PAT&amp;TAP symmetric?</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>11</code></pre><hr><p>好吧，这道题目实属非常经典的一道例题，有很多种做法，下面开始介绍两种方法。</p><p>(小声bb，其实还有一种马拉车算法，之后有时间再讲，其实不是很重点的一种方法，也比较简单)</p><p>在介绍这三种方法之后，我们需要对比一下，leetcode上面的一道题目</p><p><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">516. 最长回文子序列 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>仔细想一下，子序列与子串的difference在什么地方。在dp做法的时候，在状态表示，状态转移的过程中有什么明显的区别？？？</p><h2 id="一、线性dp"><a href="#一、线性dp" class="headerlink" title="一、线性dp"></a>一、线性dp</h2><p>状态表示：f[i] [j] 表示什么呢？因为其实线性dp不是我第一次做出来这个题目所用的方法。</p><p>我闪过几个角度，like 从i到j这一段中最长的子串的长度？ 其实有点像后面要说的，子序列的表示。</p><p>或者是f[i] [j] 表示i到j是回文子串同时储存着长度？有点脱裤子放… 不对，就像是为了dp而dp的感觉….</p><p>最终选择dp[i] [j] 不仅表示回文子串而且存贮这长度这种表示方式，没什么原因，就是感觉思路简单，便于比较。</p><p>状态属性：max</p><p>base case：每一个字符都可以表示为长度为一的回文子串。</p><p>状态转移：这样想，所有回文子串(注意连续)，都是只可能有一种状态转移来的，dp[i+1] [j-1]  +2 转移来的，so 只需要一种语句即可。</p><p>直接</p><pre class="line-numbers language-c++"><code class="language-c++">if(a[i] == a[j])&#123;    f[i][j] = f[i+1][j-1] + 2 ; &#125;else&#123;    f[i][j] = -1000 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="两个雷区"><a href="#两个雷区" class="headerlink" title="两个雷区"></a>两个雷区</h4><p>一是遍历顺序，这个注意即可，细心就行。</p><p>二是对不满足条件的处理，我之前就是因为，没有上述的else的语句，被卡了大概5分钟…..</p><p>我们这样想，因为f表示的是连续符合要求的子串，如果不满足a[i] == a[j]，其实就是等于把这个i到j给pass了，给他一个大的负数就是等于，不让他影响后续res的max函数的判断，这样会省下很多烦恼。</p><p>代码如下：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N  = 1010 ; string a ; int f[N][N] ; int main()&#123;    getline(cin , a) ;    int n = a.size() ;     if(n == 1)     &#123;        cout << 1 << endl ;    &#125;    else    &#123;    int res = 1 ;     for(int i = 0 ; i < n ; ++ i)    &#123;        f[i][i] = 1 ;     &#125;        for(int i = n-1 ; i >= 0 ; --i)    &#123;        for(int j = i + 1  ; j < n ; j ++)        &#123;            if(a[i] == a[j])            &#123;                f[i][j] = f[i+1][j-1] + 2 ;             &#125;            else            &#123;                f[i][j] = -10000 ;             &#125;                res = max(res , f[i][j]) ;        &#125;    &#125;    cout << res << endl  ;    &#125;    return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、中心扩散法"><a href="#二、中心扩散法" class="headerlink" title="二、中心扩散法"></a>二、中心扩散法</h2><p>这一种方法其实是我第一次做出来的方法，我觉得他比较符合一般思维的特点。具体逻辑是先进行一次循环遍历，将自己所指向的下标作为回文子串的中心。向左右开始扩散，判断方法是字符是否相同，如果字符相同，即为之前的数量加上2即可。再用一个res储存最大值就可以。</p><p>但是，最主要注意的是需要分成奇数回文字符串与偶数回文字符串，分别循环，最后取大值即可。</p><h3 id="OK。Talk-is-cheap-show-me-your-code"><a href="#OK。Talk-is-cheap-show-me-your-code" class="headerlink" title="OK。Talk is cheap, show me your code"></a>OK。Talk is cheap, show me your code</h3><p>贴个代码：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 1010 ; int f[N][N] ; string a ; int main()&#123;    getline(cin , a) ;        int n = a.size() ;        if(n == 1) cout << 1 << endl ;    else    &#123;    int res = -1000 ;     for(int i = 0 ; i < n ; ++ i)        f[i][i] = 1 ;         for(int i = 0 ; i < n ;++ i)                 //奇数回文    &#123;        int l = i - 1 ; int r  = i + 1 ;                 while(l >= 0 && r < n && a[l] == a[r])        &#123;            f[l][r] = f[l+1][r-1] + 2 ;             l -- ;  r ++ ;        &#125;        res = max(res ,f[l+1][r-1] ) ;    &#125;        for(int i = 0 ; i < n ; ++ i)                 //偶数回文    &#123;        int l  = i  ; int r = i + 1 ;         while(l >= 0 && r < n && a[l] == a[r])        &#123;            f[l][r] = f[l+1][r-1] + 2 ;             l -- ;  r ++ ;        &#125;        res = max(res ,f[l+1][r-1] ) ;    &#125;    cout << res << endl ;     &#125;    return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>———-10-12 添加———————————————————————————————————————————————————</p><p>ok，在看manacher算法的时候，他的预处理也可以用在中心扩散法(暴力)。因为暴力解法需要分两种情况，一种是偶数的，还有一种是奇数的。可以在string a的每一个字符左右两面都添加一个额外符号，相同即可。所以原数据范围由n到2*n+1 ; </p><p>一定可以转化为奇数来做。</p><p>但是注意两个细节：</p><p>一、申请的范围N, 因为数据由1000到了2001，所以申请超过2010就可以了。</p><p>二、最后的输出结果，由于c++除法自动向下取整，所以结果就是res &gt;&gt; 1即可。别的没有什么。</p><p>所以，贴个代码：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ; const int N = 2010 ; string a ; int f[N][N] ; int main()&#123;    getline(cin , a) ;     string b = "" ;         int n = a.size() ;     for(int i = 0 ; i < n  ; ++ i)    &#123;        b.push_back('#') ;        b.push_back(a[i]) ;    &#125;     b.push_back('#') ;    n = b.size() ;     for(int i = 0 ; i < n  ; ++ i)    &#123;        f[i][i] = 1 ;     &#125;    int res = 1 ;    for(int i = 1;  i < n ; ++  i)    &#123;        int l = i -1 ;         int r = i + 1 ;         while(l >= 0  && r < n && b[l] == b[r])        &#123;            f[l][r] = f[l+1][r-1]  + 2 ;           l -- ; r++ ;          &#125;                res = max(res , f[l+1][r-1])  ;     &#125;    int ans = res / 2 ;     cout << ans << endl ;    return 0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ok.以上就是最长回文子串的做法，我们来看最长回文子序列的题目。</p><p><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">516. 最长回文子序列 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>这就是典型的线性dp可以做出来的题，我们按照经典模板走一下。</p><p>状态表示：dp[i] [j] 表示在下标为i到j的一段字符串中， 最长子序列的长度。</p><p>状态属性：max</p><p>base case：每一个字符都可以看成是一个长度为一的回文字符串。</p><p>状态转移：字符串经典分割，按照遍历时候，字符是否相同进行分割。</p><p>​                    如果相同，f[i] [j] =  f[i+1] [j-1]  + 2  ; </p><p>​                    如果不同 ， f[i] [j] = max(f[i] [j-1] , f[i+1] [j]) ;</p><p>感觉都成了肌肉记忆了…………</p><p>贴个代码：</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    int longestPalindromeSubseq(string s) &#123;        int n = s.size() ;        if(n == 1) return 1 ;         vector<vector<int>> f(n , vector<int> (n,  0)) ;         for(int i = 0 ; i < n  ; ++ i)        &#123;            f[i][i] = 1 ;         &#125;                for(int i = n-1 ; i >= 0 ; --i)        &#123;             for(int j = i + 1 ; j < n ; ++ j)      //一个小细节，注意遍历的顺序，这是根据状态转移的式子来的。             &#123;                 if(s[i] == s[j])                 &#123;                     f[i][j] = f[i+1][j-1] + 2 ;                  &#125;                 else                 &#123;                     f[i][j] = max(f[i][j-1] , f[i+1][j]) ;                 &#125;             &#125;        &#125;        return f[0][n-1] ;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以明显的感觉到两者之间的方法的差异。</p><p>本质上，其实就是定义的差别，即连续与不连续的区别。这就导致了在dp的时候，状态表示的差异。</p><h3 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h3><p>状态表示：是饱满的，就是相当于中间不能有任何空隙，任何使得中间有空隙的f段都会被直接pass。</p><p>状态属性：max</p><p>base case：不说了</p><p>状态转移：唯一一种形成的方式，就是相等才会前进，如果不等，就直接pass</p><h3 id="子序列"><a href="#子序列" class="headerlink" title="子序列"></a>子序列</h3><p>状态表示：相等于很宽容，里面既可以有合乎要求的，也可以有方案外的。</p><p>状态属性：同子串</p><p>base case：同子串</p><p>状态转移：经典按照字符串==方式进行划分， if 就+2 else 就回退。</p><p>好了，终于写完了！！！ </p><p>之后有时间介绍一下，马拉车算法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 一日一题 线性dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git基本原理以及常用命令</title>
      <link href="/2021/10/10/git-ji-ben-yuan-li-yi-ji-chang-yong-ming-ling/"/>
      <url>/2021/10/10/git-ji-ben-yuan-li-yi-ji-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="git的使用方法"><a href="#git的使用方法" class="headerlink" title="git的使用方法"></a>git的使用方法</h1><p>最近从一些网站搜集了一些关于git的资料，这里做一个总结，方便自己以后查阅。</p><h2 id="一、版本控制的理解"><a href="#一、版本控制的理解" class="headerlink" title="一、版本控制的理解"></a>一、版本控制的理解</h2><p>工作区——————-&gt;暂存区———————&gt;版本库</p><p>工作区：在本地自己创建的仓库，可以在本地进行修改。</p><p>暂存区：就是一个缓冲区，每次要将工作区的内容传入到版本库时，就要先将内容先放进暂存区。</p><p>版本库：存放所有已经提交到本地仓库的代码</p><p>版本结构：是一种树的结构，可以有多个分支，有master分支，树的一个节点就是一个代码版本</p><h2 id="二、本地三个区域的常用操作"><a href="#二、本地三个区域的常用操作" class="headerlink" title="二、本地三个区域的常用操作"></a>二、本地三个区域的常用操作</h2><h3 id="工作区："><a href="#工作区：" class="headerlink" title="工作区："></a>工作区：</h3><p><code>git init</code> 在本地(自己的计算机上)生成一个代码仓库，标志是.git</p><p><code>git status</code> 查看仓库的状态</p><p><code>git log</code> 查看当前分支的所有版本(不包括回滚)</p><p><code>git reflog</code>查看HEAD 指针的移动路线</p><h3 id="工作区-gt-暂存区"><a href="#工作区-gt-暂存区" class="headerlink" title="工作区-&gt;暂存区"></a>工作区-&gt;暂存区</h3><p><code>git add + xxx.txt</code> 将xxx文件的修改从工作区添加到暂存区</p><p><code>git add .</code> 将工作区的所有文件的修改一并添加到暂存区</p><p>ok，这里弄清楚一个概念，这里的add并不是添加一个文件实体，而是添加的是一个文件的修改操作。</p><p>例如，想要删除一个a.txt文件，我们应该这样做.</p><p><code>rm a.txt</code></p><p><code>git add a.txt</code></p><p>就是首先在本地删除这个a文件，然后将这个删除操作添加到staged里面。</p><p><code>git restore</code> 将工作区的文件变成与暂存区相同</p><p><code>git restore --staged a.txt</code> 从暂存区中撤销对a文件的操作</p><h3 id="暂存区-gt-版本库"><a href="#暂存区-gt-版本库" class="headerlink" title="暂存区-&gt;版本库"></a>暂存区-&gt;版本库</h3><p><code>git commit --m&quot;备注信息&quot; </code>将暂存区的文件传入版本库</p><h3 id="代码回滚"><a href="#代码回滚" class="headerlink" title="代码回滚"></a>代码回滚</h3><p><code>git reset --hard HEAD^^</code> 回退两个版本</p><p><code>git reset --hard HEAD ~100</code>  回退100个版本</p><p>如果想要直接跳转到那个版本的话</p><p><code>git reset --hard + hash</code> hash是指版本号对应的hash值</p><h2 id="三、本地-gt-云端"><a href="#三、本地-gt-云端" class="headerlink" title="三、本地-&gt;云端"></a>三、本地-&gt;云端</h2><p><code>git push</code> 将当前分支推送到云端仓库 但是如果是第一次的话 要写成<code>git push -u</code></p><p><code>git push origin branchname</code> 将本地的某个分支push到云端，直接指认branchname</p><p><code>git clone</code> 必备技能 将别人公开的仓库里面的文件下载到本地</p><p><code>git checkout -b branchname</code> 有两个作用一个是创建branchname 一个是在create的同时checkout到这个分支</p><p><code>git checkout branchname</code> 切换分支</p><p><code>git branch</code> 查看各个分支的信息</p><p><code>git branch branchname</code> 创建新分支</p><p><code>git branch -d branchname</code> 删除本地分支</p><p><code>git merge branchname</code> 将这个分支合并到当前分支</p><p><code>git push -d origin branchname</code> 在远程仓库删除分支</p><p><code>git pull</code> 从云端仓库的当前分支拉取下来并合并到本地的当前分支</p><p><code>git pull origin branchname</code> 从远端仓库的拉取branchname这条分支并与本地的当前分支进行合并 </p><h1 id="—————————-10-23晚更新————————————"><a href="#—————————-10-23晚更新————————————" class="headerlink" title="—————————-10.23晚更新————————————-"></a>—————————-10.23晚更新————————————-</h1><p>发现了一个极其有趣的了解git实战的网站</p><p><a href="https://learngitbranching.js.org/?locale=zh_CN">https://learngitbranching.js.org/?locale=zh_CN</a> 可能需要魔法上网(hhh)</p><p>花了大概两个小时，通关了。对git多了很多认知，但是有很多不太容易文字记录下来，算了，防止自己忘了在这里就随便记录一些，然后有时间在玩一玩那个网站吧。</p><p><code>git commit </code> 我之前一直以为他是将自己修改后的文件，直接复制粘贴而已，但是其实不是，他储存的其实是上一个版本与这一次commit版本的差异，这是因为git考虑到他的轻量级。</p><p><code>git checkout</code> 与<code>git branch</code> 这个就得好好唠唠。</p><p>其实本质上，git checkout操控的是HEAD指针。例如，在游戏中就有一个部分叫做分离HEAD指针，有时候为了更加便捷的操作版本树，我们可以使用<code>git checkout c1</code> c1指的是某一个提交记录的hash值，可以用<code>git log</code> 来进行查看。此时HEAD与该分支的指针(例如main)分离，因为在一般情况下，HEAD指针往往是指向分支的指针的。</p><p>我们再来看看<code>git branch -f main HEAD</code> 这个命令，这是什么意思呢？</p><p>翻译过来其实就是，强制将main指针移动到HEAD指针所在的位置，这个不一定是指针，也可以是任意一个提交版本的位置，这个命令就是操控分支指针的命令，当然，也可以用来进行版本的回滚操作。</p><p>我们再来看看合并分支操作：</p><p><code>git merge</code> </p><p>就是字面意义上的进行合并</p><p>例如：当前的分支是main，我想要把bugFix分支合过来，那我的命令就是<code>git merge bugFix</code> </p><p><code>git rebase</code> </p><p>举个例子：<code>git rebase main</code> 假定当前的分支是bugFix，我想要将bugFix合并到main。</p><p>本质上他是将原bugFix当前所指的版本库copy一份，将其复制到main的下一位，同时main指针往下指，原来的版本依旧保留,但是这样的话会使得代码树更加清爽。(maybe)，在保留历史痕迹方面就没有merge保留的清晰。</p><p>接下来说一个比较重要的概念</p><h4 id="相对引用"><a href="#相对引用" class="headerlink" title="相对引用"></a>相对引用</h4><p><code>git checkout HEAD^</code> HEAD指针跳转到上一级，之所以叫相对引用，是相对于<code>git checkout c1</code> 这种简单粗暴的移动HEAD指针的方式。</p><p><code>git branch -f main HEAD^</code> 也是可以的，就是把一个特定版本的hash值换成了一个相对位置而已。</p><h4 id="回退版本"><a href="#回退版本" class="headerlink" title="回退版本"></a>回退版本</h4><p><code>git reset</code>  </p><p>比如说，我想要删除本地的最新版本</p><p><code>git reset HEAD^</code> 他是相当于把最新的版本隐藏了，就像是没有提交过一样，但是你push到remote的时候，他是不会有变化的</p><p><code>git revert HEAD</code> 他是相当于隐藏了c1，提交了一次c1’，里面存的是c1的修改记录，内容与c0一致。push到remote的时候，remote是有变化的。</p><h4 id="整理提交记录"><a href="#整理提交记录" class="headerlink" title="整理提交记录"></a>整理提交记录</h4><p>把多人凌乱的提交记录进行整理，可以使得代码树干净整洁一些。</p><p>ok，介绍一个我最喜欢也是非常方便的一个指令。</p><p>  <code>git cherry-pick c1 c2 c3</code> 假定当前的分支是main，就是把全局的c1 c2 c3节点，复制一个副本，然后依次粘贴到main指针下面。同时，main指针进行移动。</p><p>与cherry有着差不多功能的一条指令是</p><h4 id="可交互的rebase"><a href="#可交互的rebase" class="headerlink" title="可交互的rebase"></a>可交互的rebase</h4><p><code>git rebase -i HEAD~3</code> 这条指令是从你现在的HEAD指针的位置开始，向上移动三个位置，在起始点到倒数第二个点的这些节点中，会出现一个ui，你可以选择其中的一些点，可以进行忽略，排序什么的，然后粘贴到最后一个指向的节点的下面。但是不移动父节点的指针。</p><h4 id="git-tag-与-git-discribe"><a href="#git-tag-与-git-discribe" class="headerlink" title="git tag 与 git discribe"></a>git tag 与 git discribe</h4><p>个人觉得没有什么用</p><p>在merge之后，我们知道,假定一种情况</p><p>当时的HEAD指针指向main ， 同时你想要merge一条bugFix分支，于是你</p><p><code>git merge bugFix</code> ，我们知道这条指令的意思是将bugFix分支merge到main分支。</p><p>那么你就会想到如果此时我<code>git checkout HEAD^</code>指向的是哪条分支呢？</p><p>实践之后可以知道，就是之前的main分支，因为是将bugFixmerge到main，所以main占主导。</p><p>那有些朋友就会问了，如果我想checkout到bugFix怎么办呢？</p><p>很简单，<code>git checkout HEDA^2</code> 即可。</p><p>下面是local与remote的一些交互操作，有些确实有些蛋疼，没有合作代码的项目经历还真是比较吃亏。</p><p>同时还有一点，单纯的列举操作自然没有自己动手实践的理解深，所以看到这的朋友，不妨自己到那个小游戏里面去玩一玩。</p><p>不管了，先列举一些我的一些总结，等之后有了git的工作经历在进一步更新吧</p><p>其实命令无非就是</p><p><code>git fetch</code> 有两个作用，一是将local与remote相比缺失的记录下载下来，同时改变o/main，也就是origin指针。注意！！！这里是不改变local的main指针的，只是一个下载而已，不改变本地的任何指针。</p><p><code>git pull</code> 可以看做是<code>git fetch</code> 与<code>git merge</code> 的结合版，就是在下载之后，将remote分支与local的当前分支合并。</p><p>正常我们为了美观一般都<code>git pull --rebase</code> 会使得代码更加简洁一些。</p><p><code>git push</code> pull的反义词，就是将local与remote对比，将local的改进与更新同步到remote，注意！！！当前的分支是什么就push哪一条分支，只push当前的分支。</p><p><code>git clone</code> 将remote仓库，如<code>github</code> 、<code>gitee</code>、<code>git lab</code> 的所有文件克隆到本地的仓库，就像是在本地创建了remote的一个副本。</p><h4 id="本地分支对远程分支指针的追踪"><a href="#本地分支对远程分支指针的追踪" class="headerlink" title="本地分支对远程分支指针的追踪"></a>本地分支对远程分支指针的追踪</h4><p><code>git checkout -b foo o/main</code> 这句话的意思是在本地创建并切换到foo分支，该分支对origin/main指针进行追踪。</p><p>那么什么叫进行追踪呢？就是相当于foo取代了本地的main分支，本地的main分支已经没有用了，他不在可以与远程的main分支进行对应，foo承担了main分支应有的工作。</p><p><code>git push origin main</code>这句话把它进行慢动作的话其实有两个指令：1.找到本地的main分支 2. 将本地的main分支进行push，同时移动o/main指针</p><p><code>git push origin main:foo</code> 冒号前面的是一个位置，表示的是本地的main分支指针所指向的一个位置，后面的是要移动的远程的foo指针，就是将远程的仓库添加从foo到main指针缺少的一段版本，同时将foo指针移动到main的位置</p><p><code>git fetch origin main:foo </code> 原理同上</p><p><code>git pull origin main:foo</code> 原理同上</p><p>好，终于更新完了，差不多学会上述的操作就应该差不多了。以后有时间的话，我就再来整理一下。</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由回文平方讲一种无脑转进制的方法</title>
      <link href="/2021/10/10/you-hui-wen-ping-fang-jiang-yi-chong-wu-nao-zhuan-jin-zhi-de-fang-fa/"/>
      <url>/2021/10/10/you-hui-wen-ping-fang-jiang-yi-chong-wu-nao-zhuan-jin-zhi-de-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="回文平方"><a href="#回文平方" class="headerlink" title="回文平方"></a>回文平方</h1><hr><p>回文数是指数字从前往后读和从后往前读都相同的数字。</p><p>例如数字 12321 就是典型的回文数字。</p><p>现在给定你一个整数 B，请你判断 1∼300之间的所有整数中，有哪些整数的<strong>平方</strong>转化为 B 进制后，其 B 进制表示是回文数字。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>一个整数 B。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>每行包含两个<strong>在 B 进制下</strong>表示的数字。</p><p>第一个表示满足平方值转化为 B 进制后是回文数字那个数，第二个数表示第一个数的平方。</p><p>所有满足条件的数字按从小到大顺序依次输出。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>2≤B≤20,<br>对于大于 9 的数字，用 A 表示 10，用 B 表示 11，以此类推。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>10</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>1 12 43 911 12122 48426 676101 10201111 12321121 14641202 40804212 44944264 69696</code></pre><hr><p>思路比较简单，这里主要讲一种无脑转进制的方法。</p><p>先贴代码</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ; int B ; string a = "0123456789ABCDEFGHIJK" ; string tob(int sum)&#123;    string res = "" ;     while(sum)    &#123;        res += a[sum%B] ;         sum /= B ;     &#125;    reverse(res.begin(), res.end()) ;    return res ;&#125;bool check(string a)&#123;    int l = 0 ;     int r = a.size() -1 ;    while(l < r)    &#123;        if(a[l] == a[r])        &#123;            l ++ ; r -- ;        &#125;        else        &#123;            return false ;         &#125;    &#125;    return true ; &#125;int main()&#123;    cin >> B ;         for(int i = 1 ; i <= 300 ; ++i)    &#123;        string x = tob(i*i) ;         if(check(x))        &#123;            string y = tob(i) ;            cout << y << " " << x << endl ;         &#125;    &#125;    return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里可以注意到，我在将任意数转换成B进制的时候，直接采用了一种比较万能的方法，直接将备选的string组给展示出来。然后就直接可以套用模板来进行转换了。如果最后是要用int型的，直接调用atoi函数即可。</p><p>例如，leetcode的一道题目：</p><p><a href="https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/">405. 数字转换为十六进制数 - 力扣（LeetCode） (leetcode-cn.com)</a></p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    string toHex(int num) &#123;        string a = "0123456789ABCDEF" ;                 long long n = num < 0 ? (long long) (num + pow(2,32)) : num ;         string res = "" ;         while(n)        &#123;            res += a[n%16] ;             n /= 16 ;        &#125;        reverse(res.begin() , res.end()) ;        return res ;     &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特别要注意的是，当负数要进行进制转换的时候，因为要按照补码进行运算，就是再十进制基础上，加上了pow(2,32) 。但是同时也要注意，会不会爆int,因为int的范围是2的-31~2的31，直接加上pow(2，32)就会爆int ，所以我们需要有一个强制转换，ok，除此之外就没有什么了。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划一日一题-10-10-最长公共子序列</title>
      <link href="/2021/10/10/dong-tai-gui-hua-yi-ri-yi-ti-10-10-zui-chang-gong-gong-zi-xu-lie/"/>
      <url>/2021/10/10/dong-tai-gui-hua-yi-ri-yi-ti-10-10-zui-chang-gong-gong-zi-xu-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><hr><p>给定两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 N 和 M。</p><p>第二行包含一个长度为 N 的字符串，表示字符串 A。</p><p>第三行包含一个长度为 M 的字符串，表示字符串 B。</p><p>字符串均由小写字母构成。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大长度。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N,M≤1000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>4 5acbdabedc</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>3</code></pre><hr><p>这题也是经典的双串的线性dp问题，按照模板来进行分析即可。</p><p>状态表示：dp[i] [j] 表示串a的1-i与串b的1-j之间的最长common子序列。所以最终答案的返回值应该是dp[n] [m] ; </p><p>状态属性：max</p><p>base case：dp[i] [0] =  0 ; dp[0] [j] = 0 ;</p><p>状态转移：按照典型的字符相等判断</p><p>​                    如果两者是相等的，dp[i] [j] = dp[i-1] [j-1] + 1 ; </p><p>​                    如果不等 ， dp[i] [ j] = max(dp[i-1] [j] , dp[ i] [j-1]) ; </p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 1010 ; int f[N][N] ; char a[N] , b[N] ; int main()&#123;    int n , m ;         cin >> n >> m ;         scanf("%s%s" , a + 1 , b + 1) ;         for(int i = 1 ;  i <= n ; ++i)        a[i][0] = 0  ;     for(int j = 1 ; j <= m ; ++j)        a[0][j] = 0 ;         for(int i = 1 ;  i <= n ; ++i )    &#123;        for(int j = 1 ; j <= m ; ++j)        &#123;            if(a[i] == b[j])            &#123;                f[i][j] = f[i-1][j-1] + 1 ;             &#125;            else            &#123;                f[i][j] = max(f[i-1][j] , f[i][j-1]) ;            &#125;        &#125;    &#125;    cout << f[n][m] << endl ;     return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>经典的模板题，按照模板走即可，没有什么说的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 一日一题 线性dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蛇形矩阵</title>
      <link href="/2021/10/09/she-xing-ju-zhen/"/>
      <url>/2021/10/09/she-xing-ju-zhen/</url>
      
        <content type="html"><![CDATA[<h1 id="蛇形矩阵"><a href="#蛇形矩阵" class="headerlink" title="蛇形矩阵"></a>蛇形矩阵</h1><hr><p>输入两个整数 n和 m，输出一个 n行 m 列的矩阵，将数字 1 到 n×m 按照回字蛇形填充至矩阵中。</p><p>具体矩阵形式可参考样例。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入共一行，包含两个整数 n 和 m。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出满足要求的矩阵。</p><p>矩阵占 n 行，每行包含 m 个空格隔开的整数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n,m≤100</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>3 3</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>1 2 38 9 47 6 5</code></pre><hr><p>好家伙，纯模拟，耐心就可以，纯耗时间，没有技巧…..</p><p>贴个代码：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 1010 ;int f[N][N] ; int main()&#123;    int n , m  ;    cin >> n >> m  ;     int all = n*m ;     int cnt = 0 ;    int top1 =n , top2 = m  , bottom1 = 1 , bottom2 = 1 ;    while(all > 0 )    &#123;        for(int j = bottom2 ; j <= top2 ;  j++)        &#123;            f[bottom1][j] = ++cnt ;            all -- ;        &#125;        top2 -- ;        for(int i = bottom1 ; i <= top1 ; ++i)        &#123;            f[i][top2+1] = ++cnt ;            all -- ;        &#125;        top1 -- ;                 for(int j = top2 ; j >= bottom2 ; --j)        &#123;            f[top1+1][j] = ++cnt ;            all -- ;        &#125;        bottom2 ++ ;                 for(int i = top1 ; i <= bottom1 ; --i)        &#123;            f[i][bottom2] = ++cnt ;            all -- ;        &#125;        bottom1 ++ ;             &#125;        for(int i  = 1 ; i <= n ; ++i)    &#123;        for(int j = 1 ; j <= m ;++j)        &#123;            cout << f[i][j] << " " ;        &#125;        cout << endl ;    &#125;    return  0 ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意对称美还有一些细节就行了……. 模拟的题目是最无聊的…….</p>]]></content>
      
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划一日一题-10-9-最长上升子序列</title>
      <link href="/2021/10/09/dong-tai-gui-hua-yi-ri-yi-ti-10-9-zui-chang-shang-sheng-zi-xu-lie/"/>
      <url>/2021/10/09/dong-tai-gui-hua-yi-ri-yi-ti-10-9-zui-chang-shang-sheng-zi-xu-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h1><p>给定一个长度为 N的数列，求数值严格单调递增的子序列的长度最长是多少。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 N。</p><p>第二行包含 N 个整数，表示完整序列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大长度。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤1000<br>−109≤数列中的数≤109</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>73 1 2 1 8 5 6</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>4</code></pre><p>此题在审题的时候就要注意一下子串和子序列的区别。子串必须是连续的，但是子序列只要是有左右顺序即可，可以不需要是连续的。</p><p>给出的数据是个数，以及一支长串字符序列，要求返回的是最长递增序列的长度。</p><p>状态表示：f[i] 表示的是以第i个字符结尾的从1-i的最长上升子序列的长度。</p><p>状态属性：max</p><p>base case：f[i] = 1 ; 因为每一个字符可以看作是只有一个字符的序列</p><p>状态转移：对于每一个f[i] 他的值其实来源于他前面的序列中比他小的f[j] 集合中最大的然后在加上一</p><pre class="line-numbers language-c++"><code class="language-c++">//表示的是大概意思，代码是不对的，但是思路是这样的for(int i = 1 ; i <= n ; ++i)&#123;    for(int j = i-1 ; j >= 0 ; --j)    &#123;        if(a[i] > a[j])        &#123;            f[i] = f[j]+1 ;         &#125;        res = max(res, f[i]) ;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>So,代码如下：</p><pre class="line-numbers language-c++"><code class="language-c++">#include<bits/stdc++.h>using namespace std ; const int N = 1010 ; int a[N] , f[N] ; int main()&#123;    int n ;     cin >> n ;         int res = -1e9-1 ;         for(int i = 1 ; i <= n ; ++i)    &#123;        cin >> a[i] ;     &#125;        for(int i = 1 ; i <= n ; ++i)    &#123;        f[i]  = 1;         for(int j = i-1 ; j >= 0 ; --j)        &#123;            if(a[i] >  a[j])            &#123;                f[i] = max(f[i] , f[j]  + 1) ;             &#125;        &#125;        res = max(res , f[i]) ;     &#125;        cout << res << endl ;     return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ok，分析一下上面代码的时间复杂度O(n2) 。</p><p>那么是否存在更加优化时间的方案呢？</p><h2 id="贪心加二分"><a href="#贪心加二分" class="headerlink" title="贪心加二分"></a>贪心加二分</h2><p>我们想到其实对于f[i]表示的是以a[i]结尾的子序列来说，我们可以有这样的想法：</p><p>1.首先明确一点：我们维护一个上升子序列，想让子序列的长度更长，那就相当于往后遍历的时候遇到了比已经维护的子序列中最大的要小的数字a[i]的时候，我们应该找子序列中小于a[i]的最大的数字，然后将其替换成a[i] 。这样就可以保证之后理论上可以替换更多的数字，从而维护了最长的子序列。</p><p>2.那么我们如果仅仅是两轮循环遍历，来实现上述思想，那么细心的同学就可以发现，时间复杂度并没有优化，只是思路发生了变化而已。所以，可以这样实现的重点就是我们在维护的子序列中可以采用二分的方法来找到小于a[i]的最大数字。所以时间复杂度优化为O(nlgn).</p><p>actually，这种思路的话，其实个人感觉不太像dp，而是更像是贪心算法，在加上二分。</p><p>ok，下面是代码实现：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 100010 ;//q[N]是我们要维护的序列//w[N]负责读入数据int q[N] , w[N] ; int cnt ; int find(int *q , int num)&#123;    int l = 1 ;     int r = cnt ;     while(l < r)    &#123;        int mid = l + r >> 1  ;        if(q[mid] < num)        &#123;            l = mid + 1 ;         &#125;        else        &#123;            r  = mid ;         &#125;    &#125;    return  l ;&#125;int main()&#123;    int n ;     cin >> n ;     for(int i = 1 ; i <= n ;++i)    &#123;        cin >> w[i] ;     &#125;    q[++cnt] = w[1] ;     for(int i = 2 ; i <= n ;++i)    &#123;        if(w[i] > q[cnt])        &#123;            q[++cnt] = w[i] ;    //如果是个比维护序列的最大值大的，就直接加入即可        &#125;       else       &#123;           int t = find(q ,  w[i]) ;            q[t] = w[i] ;        &#125;    &#125;        cout << cnt << endl ;    return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ok,以上是解决了长度的问题，那我们开始举一反三，是否可以在举一个同类的问题</p><h2 id="能否返回所有长度为最长的上升子序列的个数？"><a href="#能否返回所有长度为最长的上升子序列的个数？" class="headerlink" title="能否返回所有长度为最长的上升子序列的个数？"></a>能否返回所有长度为最长的上升子序列的个数？</h2><p>好吧，今天时间有限，等下次在更…….</p><p>—————————————————————————–2021.11.6更新————————————————————————————-</p><p>如何才能返回所有长度为最长的上升子序列长度的个数呢，我们先来看一下leetcode里面的一道题</p><p><a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/">673. 最长递增子序列的个数 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>可以看出来，与单纯的求最长递增子序列相比，该题多了一维信息，那就是收集f[i] == ans的f[i]的个数。可以看成是二维的LIS问题。</p><p>那么我们怎么进行g[i] (以nums[i] 为结尾的最长子序列的个数)的更新呢？</p><h3 id="逻辑分析"><a href="#逻辑分析" class="headerlink" title="逻辑分析"></a>逻辑分析</h3><p>状态表示：<code>g[i]</code> 表示以nums[i] 结尾的同时是最长递增子序列的个数</p><p>状态属性：max</p><p>base case：g[i] = 1 ;</p><p>状态转移：在对f数组进行更新的时候，我们考虑到<code>f[i] = max(f[i] , f[j] + 1)</code> ，这表示着f的状态的两个来源，</p><p>我们分成三个情况来讨论：</p><p>一：<code>f[i] &gt; f[j] + 1</code> 表示不需要用这个j来进行更新，也就是说，不会发生任何事情，所以我们在代码中可以直接省略</p><p>二：<code>f[i] == f[j] + 1</code> 表示在i之前还存在一种情况可以在i的序号下得到最长子序列，例如：<code>1223</code> ，以3为结尾就会有两个。我们可以直接<code>g[i] += g[j] </code> 即可。</p><p>三：<code>f[i] &lt; f[j] + 1</code> 表示可以用j来进行更新当前的数组，那就是<code>g[i] = g[j]</code> 即可。</p><pre class="line-numbers language-c++"><code class="language-c++">//用代码表示转移方程就是这样的for(int i = 0 ; i < n ; ++ i)&#123;    f[i] = g[i] = 1 ;     for(int j = 0 ; j < i; ++ j)    &#123;        if(nums[i] > nums[j])        &#123;            if(f[i] == f[j] + 1)            &#123;                g[i] += g[j] ;             &#125;            else if(f[i] < f[j] + 1)            &#123;                g[i] = g[j] ;                 f[i] = f[j] + 1 ;             &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Talk is cheap ,Show me your code!!!</p><h4 id="同时更新版本"><a href="#同时更新版本" class="headerlink" title="同时更新版本"></a>同时更新版本</h4><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    int findNumberOfLIS(vector<int>& nums) &#123;        int res = 0  ,ans = 0  ;         int n = nums.size() ;         vector<int> f(n) , g(n) ;        for(int i =  0;  i < n ; ++ i)        &#123;            f[i] = g[i] = 1 ;             for(int j = 0 ; j < i  ; ++ j)            &#123;                if(nums[i] > nums[j])                &#123;                    if(f[i] == f[j] + 1)                    &#123;                        g[i] += g[j] ;                     &#125;                    else if(f[i] < f[j] + 1)                    &#123;                        g[i] = g[j] ;                         f[i] = f[j] + 1  ;                    &#125;                &#125;            &#125;            ans = max(ans , f[i]) ;         &#125;                for(int i = 0 ; i < n ; ++ i)        &#123;                if(f[i] == ans)                &#123;                    res += g[i] ;                 &#125;        &#125;        return res ;     &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ok,这是同时更新f,g的版本。我们还可以将f与g独立处理.</p><h4 id="独立处理版本"><a href="#独立处理版本" class="headerlink" title="独立处理版本"></a>独立处理版本</h4><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    int ans = 0  ,res = 0 ;     int findNumberOfLIS(vector<int>& nums) &#123;        int n = nums.size() ;        vector<int> f(n) , g(n) ;                  for(int i = 0 ; i < n ; ++ i)        &#123;            f[i] = 1 ;            for(int j = 0 ; j < i  ; ++ j)            &#123;                if(nums[i] > nums[j])                f[i] = max(f[i] , f[j] + 1) ;             &#125;            ans = max(ans , f[i]) ;         &#125;         for(int i = 0 ; i < n ; ++ i)        &#123;            if(f[i] == 1) g[i] = 1 ;             for(int j = 0 ; j < i ; ++ j)            &#123;                if(f[i] == f[j] + 1 && nums[i] > nums[j])                    g[i] += g[j] ;             &#125;        &#125;                for(int i = 0 ;  i < n ; ++ i)        &#123;            if(f[i] == ans)                res += g[i] ;         &#125;        return res  ;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>意思要比同时更新要更加好理解，先按部就班的将f数组完成，对于g数组来说，只要f[i] 是由可以有f[j] 来更新到的，他就会把所有的可能都加进去，前提是g[i] 一开始是空的，如果初始化为1的话，结果会有错。最后，只要查找哪些f是最大的，然后res一直加上g就可以了。</p><p>所以为什么要说这个呢?</p><p>是为了引出下面这一道题，他是上面的题目的变种，需要稍加考虑一下细节。</p><p>ok，我们再来看看这一道题。</p><h2 id="低买"><a href="#低买" class="headerlink" title="低买"></a>低买</h2><hr><p>给定一段时间内股票的每日售价（正 16 位整数）。</p><p>你可以选择在任何一天购买股票。</p><p>每次你选择购买时，当前的股票价格必须严格低于你之前购买股票时的价格。</p><p>编写一个程序，确定你应该在哪些天购进股票，可以使得你能够购买股票的次数最大化。</p><p>例如，下面是一个股票价格时间表：</p><pre><code> Day   1  2  3  4  5  6  7  8  9 10 11 12Price 68 69 54 64 68 64 70 67 78 62 98 87</code></pre><p>如果每次购买都必须遵循当前股票价格严格低于之前购买股票时的价格，那么投资者最多可以购买四次该股票。</p><p>买进方案之一为：</p><pre><code>Day    2  5  6 10Price 69 68 64 62</code></pre><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第 1 行包含整数 N，表示给出的股票价格的天数。</p><p>第 2 至最后一行，共包含 N 个整数，每行 10 个，最后一行可能不够 10 个，表示 N 天的股票价格。</p><p>同一行数之间用空格隔开。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出占一行，包含两个整数，分别表示最大买进股票次数以及可以达到最大买进次数的方案数。</p><p>如果两种方案的买入日序列不同，但是价格序列相同，则认为这是相同的方案（只计算一次）。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤5000</p><h4 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h4><pre><code>1268 69 54 64 68 64 70 67 78 6298 87</code></pre><h4 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h4><pre><code>4 2</code></pre><h4 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h4><pre><code>54 3 2 1 1</code></pre><h4 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h4><pre><code>4 1</code></pre><hr><h4 id="逻辑思路"><a href="#逻辑思路" class="headerlink" title="逻辑思路"></a>逻辑思路</h4><p>题目意思比较直白，就是LDS(最长下降子序列) ,但是要注意点是，位置不同但是数字相同的只能算一种。</p><p>例如<code>1223</code> res == 1,而不是res==2 。 </p><p>那我们如何来考虑呢？</p><p>我们先用独立处理的方式来进行分析，f的算法是不会变得。那么对于，g数组其实就是在从左往右的顺序的时候，当f[i] == f[j] &amp;&amp; nums[i] == nums[j] ，的时候需要特判一下，这就相当于是到第三位的时候是2，此时<code>f[3] == 2</code> <code>f[2] == 2</code> ，并且<code>nums[2] == nums[3] == 2</code> ，所以我们需要将此时的g，变成0，反正就是只要加上一个就行了，随便你是g[i] =0 , 还是g[j] = 0 这样，我们在最后一次循环得出res的时候，只会加一次。</p><p>ok，这就是大致思路，下面贴个代码。</p><h4 id="独立处理做法"><a href="#独立处理做法" class="headerlink" title="独立处理做法"></a>独立处理做法</h4><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 5010 ; int nums[N] , f[N] , g[N] ; int n ; int res = 0  ,ans = 0  ;int main()&#123;    cin >> n ;        for(int i = 1; i <= n ; ++ i)    &#123;        cin >> nums[i] ;     &#125;        for(int i = 1 ; i <= n ; ++ i)    &#123;        f[i] = 1;          for(int j = 1 ; j < i ; ++ j)         &#123;             if(nums[i] < nums[j])             f[i] = max(f[i] , f[j] + 1) ;          &#125;         ans = max(ans , f[i]) ;    &#125;        for(int i = 1 ; i <= n ; ++ i)    &#123;        if(f[i] == 1) g[i] = 1;         for(int j = 1 ;  j < i ; ++ j)        &#123;            if(f[i] == f[j] + 1 && nums[i] < nums[j])                g[i] += g[j] ;             else if(f[i] == f[j] && nums[i] == nums[j])                g[j] = 0 ;         &#125;    &#125;        for(int i = 1 ; i <= n ; ++ i)    &#123;        if(f[i] == ans)            res += g[i] ;     &#125;        cout << ans  << " "<< res << endl ;         return  0 ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那我们用同步更新的思路来再想一遍</p><p>对于f来说，依然是没有什么影响。此时，对于g来说，一种从源头根治的方法是，每次j来进行搜索的时候，都将在确立了f之后，将之前的相同元素的f变为另一个很小的数。</p><h4 id="同步更新思路："><a href="#同步更新思路：" class="headerlink" title="同步更新思路："></a>同步更新思路：</h4><p>贴个代码：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 5010 ; int nums[N] , f[N] , g[N] ; int n ; int res = 0  ,ans = 0  ;int main()&#123;    cin >> n ;        for(int i = 1; i <= n ; ++ i)    &#123;        cin >> nums[i] ;     &#125;    for(int i = 1 ; i <= n ; ++ i)    &#123;        f[i]  = 1 ;          for(int j = 1 ; j < i ; ++ j)        &#123;            if(nums[j] > nums[i])                f[i] = max(f[i] , f[j] + 1) ;         &#125;                if(f[i] == 1) g[i] = 1 ;        ans = max(ans , f[i]) ;                 for(int j = 1 ; j < i ; ++ j)        &#123;            if(nums[j] == nums[i])                f[j] = -1 ;        &#125;                                for(int j = 1 ; j < i ; ++ j)        &#123;            if(nums[j] > nums[i] && f[i] == f[j] + 1)                g[i] += g[j] ;         &#125;            &#125;    for(int i = 1 ; i <= n ; ++ i)    &#123;        if(f[i] == ans)        &#123;            res += g[i] ;         &#125;    &#125;    cout << ans  << " "<< res << endl ;         return  0 ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实还有一个有意思的地方是在于，不同方法的时候，g的预处理的值也是比较有意思的。</p><p>总结一下，独立处理意思容易理解，但是代码相对来说比较冗余。同时更新理解起来稍微难一些，但是代码要简洁。</p><p>好了，说完了，拜拜 &gt;_&lt; .</p>]]></content>
      
      
      
        <tags>
            
            <tag> 一日一题 线性dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划一日一题-10-8-混合背包问题</title>
      <link href="/2021/10/08/dong-tai-gui-hua-yi-ri-yi-ti-10-8-hun-he-bei-bao-wen-ti/"/>
      <url>/2021/10/08/dong-tai-gui-hua-yi-ri-yi-ti-10-8-hun-he-bei-bao-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="混合背包问题"><a href="#混合背包问题" class="headerlink" title="混合背包问题"></a>混合背包问题</h1><hr><p>有 N种物品和一个容量是 V 的背包。</p><p>物品一共有三类：</p><ul><li>第一类物品只能用1次（01背包）；</li><li>第二类物品可以用无限次（完全背包）；</li><li>第三类物品最多只能用 si次（多重背包）；</li></ul><p>每种体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 N行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。</p><ul><li>si=−1 表示第 i种物品只能用1次；</li><li>si=0 表示第 ii 种物品可以用无限次；</li><li>si&gt;0表示第 i 种物品可以使用 si 次；</li></ul><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N,V≤1000<br>0&lt;vi,wi≤1000<br>−1≤si≤1000</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><pre><code>4 51 2 -12 4 13 4 04 5 2</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>8</code></pre><hr><p>其实从大体上来看，背包问题其实只有01，完全两大问题。对于混合背包，分组背包，多重背包其实就是通过某种优化手段，将其映射到01和完全两大背包类型中。</p><p>例如，此题的混合背包问题，昨天我们做了多重背包问题，不同体积与价值的物品可以有不同的数量。我们采用了一种二进制优化的方法，将多重背包映射成为01背包，然后套用01的模板即可。</p><p>好的 ，那么我们开始举一反三，混合背包可以简化成什么问题。</p><p>我们从数量开始入手，对于有固定容积的背包来说，其实是不存在无穷这一概念的，也就是说物品的无穷相对于优先的背包容积来说，是不存在的。本质上，全是多重背包问题。</p><p>ok，明确了这一点后，我们就可以把此题当做多重背包来做，然后可以用二进制优化的方法进行转化成01背包。</p><p>代码如下：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 10010 ; int f[N] ; int w[N] , v[N] ;int main()&#123;    int n , m ;          cin >> n >> m ;         int cnt = 0 ;         for(int i = 1 ; i <= n ; ++i)    &#123;        int a , b , c ;                 cin >> a >> b >> c ;         if(c == -1)        &#123;            cnt ++ ;            v[cnt] = a  ;             w[cnt] = b ;         &#125;        else if(c == 0)        &#123;            c = m / a ;            int k = 1 ;            while(c >= k )            &#123;                cnt ++ ;                v[cnt] = a * k ;                 w[cnt] = b * k ;                c -= k ;                 k *= 2  ;            &#125;            if (c)            &#123;                cnt ++ ;                v[cnt] = a * c;                 w[cnt] = b * c  ;            &#125;        &#125;        else         &#123;            int k = 1 ;             while(c >= k)            &#123;                cnt ++ ;                v[cnt] = a * k ;                 w[cnt] = b * k ;                c -= k ;                 k *= 2  ;            &#125;            if(c)            &#123;                cnt ++ ;                 v[cnt] = a * c ;                 w[cnt] = b * c ;             &#125;        &#125;    &#125;    n = cnt ;     for(int i = 1 ; i <= n ; ++i)    &#123;        for(int j = m ; j >= v[i] ; --j)        &#123;            f[j] = max(f[j] , f[j-v[i]] + w[i]) ;        &#125;    &#125;    cout << f[m] << endl ;    return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 一日一题 背包dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh相关</title>
      <link href="/2021/10/07/ssh-xiang-guan/"/>
      <url>/2021/10/07/ssh-xiang-guan/</url>
      
        <content type="html"><![CDATA[<h1 id="ssh相关知识点"><a href="#ssh相关知识点" class="headerlink" title="ssh相关知识点"></a>ssh相关知识点</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="ssh的全称："><a href="#ssh的全称：" class="headerlink" title="ssh的全称："></a>ssh的全称：</h3><p>secure shell ，翻译为中文即为安全外壳协议。是一种加密的数据传输协议，用于在不安全的网络环境中进行安全的网络通信。</p><p>我们在以后开发web，或者是自己运营博客的时候，需要用到自己的服务器。但是往往自带的远程连接的工具不是很好用，于是我们有了想要ssh连接服务器的需要。</p><p>SSH协议主要是实现三个功能：</p><p>一、用户与服务器的验证，确保数据可以正确的发送到客户机或者是服务器上</p><p>二、加密数据，确保数据的安全性与私密性</p><p>三、确保数据的完整性</p><p>那么SSH协议是如何实现的呢？</p><p>这里，我们先介绍两个概念</p><p><code>对称加密算法</code> 与 <code>非对称加密算法</code></p><p>对称加密算法：用同一把钥匙进行加密和解密运算。于是对于发送方与接收方来说，任意一方得到钥匙都可以进行解密。</p><p>优点是，计算量小，速度快，而且方便。但是有一个极大的漏洞就是这也导致了他的安全性往往不是很高。因为，万一这把钥匙落到了第三方的手中，那么对于client端与server端的信息就直接暴露了。</p><p>非对称加密算法：这里就多了一个公钥的概念。</p><p>发送的一端自己生成了一个公钥与一个私钥，他想要与接收端进行通信的时候，就把公钥扔给他，向他发送用私钥加密过的数据，接收方用私钥进行解密即可。</p><p>有两个需要注意的地方：</p><p>公钥与私钥其实并没有说谁必须是公钥或者是私钥，他们只是满足</p><p><code>公钥加密后的数据只有私钥可以解开，同时私钥加密后的数据也只有公钥可以解开</code></p><p><code>公钥不可以解开自己加密后的数据，私钥不可以解开自己加密后的数据</code></p><p>SSH实现过程：</p><h3 id="每次登陆的过程"><a href="#每次登陆的过程" class="headerlink" title="每次登陆的过程"></a>每次登陆的过程</h3><p>1.client端发送login request进行唤醒server。</p><p>2.server发送公钥给client ，client端用公钥对自己的密码进行加密后,再次发送给server端</p><p>3.server端接收session-key，用自己的私钥进行解密，然后判断client的身份信息，进行登陆时的身份验证。</p><p>可以看出每次登陆时一种极其浪费时间的一种做法。</p><p>我们再来看一下</p><h3 id="ssh免密登陆的过程："><a href="#ssh免密登陆的过程：" class="headerlink" title="ssh免密登陆的过程："></a>ssh免密登陆的过程：</h3><p>1.client在本地生成公钥和私钥，然后将公钥手动复制给server</p><p>2.client同样发送login request 唤醒server</p><p>3.server端于是随机生成一个数R，用公钥进行加密后发送给client(pubkey)</p><p>4.client端用私钥进行解密得到R，同时用MD5对R和session-key进行生成Digest1</p><p>5.server端同样也对R与session-key生成Digest2，同时判断两者是否相同。</p><h2 id="二、两个作用："><a href="#二、两个作用：" class="headerlink" title="二、两个作用："></a>二、两个作用：</h2><p>1.远程登陆自己的server</p><p>(1)将user和hostname省略</p><p>(2)免密登录 可以登录多个server</p><p>2.scp本地与server、server与server之间传输文件</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划一日一题-10.7-多重背包问题</title>
      <link href="/2021/10/07/dong-tai-gui-hua-yi-ri-yi-ti-10-7-duo-chong-bei-bao-wen-ti/"/>
      <url>/2021/10/07/dong-tai-gui-hua-yi-ri-yi-ti-10-7-duo-chong-bei-bao-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h1><hr><p>有 N 种物品和一个容量是 V 的背包。</p><p>第 i 种物品最多有 si件，每件体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 N行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i种物品的体积、价值和数量。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N,V≤100<br>0&lt;vi,wi,si≤100</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><pre><code>4 51 2 32 4 13 4 34 5 2</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>10</code></pre><hr><p>综合前面两个来看，相比于01背包是单纯的只有一个，完全背包是可以有无穷多个来看，多重背包就像是前面两种的综合。更加符合实际情况，不同体积与价值的物品有不同的数量。</p><p>于是，综合前面两个的dp表示以及dp转移方式，可以自然而然的想到可以在完全背包的时候，我们第一次所使用的三次循环的方式。因为这里的数据不是非常强。所以三次循环是不会TLE的。</p><h2 id="最朴素的代码如下"><a href="#最朴素的代码如下" class="headerlink" title="最朴素的代码如下:"></a>最朴素的代码如下:</h2><pre class="line-numbers language-c++"><code class="language-c++">//极其朴素做法#include <bits/stdc++.h>using namespace std ;const int N = 110 ; int f[N][N] ; int w[N] , v[N] ,s[N]; int main()&#123;    int n , m ;     cin >> n >> m ;     for(int i = 1 ; i <= n ; ++i)    &#123;        cin >> v[i] >> w[i] >> s[i] ;     &#125;        int i , j , k ;         for(i = 1 ; i <= n ; ++i)    &#123;        for(j = 1 ; j <= m ; ++j )        &#123;            f[i][j] = f[i-1][j] ;                         for(k = 1 ; k <= s[i] && j >= k*v[i] ; ++k)            &#123;                f[i][j] = max(f[i][j] , f[i-1][j-k*v[i]] + k * w[i]) ;            &#125;        &#125;    &#125;    cout << f[n][m] << endl ;    return 0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种做法在这种强度的数据面前是可以过的，但是一旦数据到达了1000，这样的循环直接就GG了。</p><p>我们又来考虑一下，是否有可以将三次循环优化成两次的方法，唉，没错，我们又想到了完全背包问题的优化，他是根据递推公式进行优化的。</p><p>亦或者是根据有穷性的特性将多重背包问题转化成01背包问题，即为二进制优化。</p><p>先上代码。之后，我会解释二进制为什么可行？优化在什么地方？为什么会想到二进制来进行优化？是否还会有更好的优化方法？</p><h2 id="二进制优化"><a href="#二进制优化" class="headerlink" title="二进制优化"></a>二进制优化</h2><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 10010 ; int f[N]  ; int v[N] , w[N]; int main()&#123;    int n , m  ;        int cnt = 0 ;       cin >> n >> m ;         for(int i = 1 ; i <= n ; ++i)    &#123;        int a , b , c ;                 cin >> a >> b >> c ;                 int k = 1 ;         while(c >= k )        &#123;            cnt ++ ;            v[cnt] = a * k ;             w[cnt] = b * k ;             c -= k ;             k *= 2 ;         &#125;        if(c > 0)        &#123;            cnt ++ ;            v[cnt] = a * c ;             w[cnt] = b * c  ;        &#125;    &#125;        n = cnt ;     for(int i = 1 ; i <= n ; ++i)    &#123;        for(int j = m ; j >=v[i] ; --j)        &#123;            f[j] = max(f[j] , f[j-v[i]] + w[i]) ;        &#125;    &#125;        cout << f[m] << endl ;         return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用STL是这样的"><a href="#使用STL是这样的" class="headerlink" title="使用STL是这样的"></a>使用STL是这样的</h2><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 10010 ; vector < pair <int ,int> > vc ;  int f[N] ;int main()&#123;    int n , m ;     cin >> n >> m ;         for(int i = 1 ; i <= n ; ++i)    &#123;        int a , b ,c ;         cin >> a >> b >> c ;        int k = 1 ;         while(c >= k )        &#123;            vc.push_back(&#123;a*k , b*k&#125;) ;            c -= k ;              k *= 2 ;         &#125;                 if(c > 0)        &#123;            vc.push_back(&#123;c*a , c*b&#125;) ;        &#125;    &#125;           for(auto num : vc)   &#123;       for(int j  = m;  j >= num.first ;--j)       &#123;               f[j] = max(f[j] , f[j-num.first]+num.second) ;        &#125;   &#125;        cout << f[m] << endl  ;    return 0  ;     &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二进制优化的思路："><a href="#二进制优化的思路：" class="headerlink" title="二进制优化的思路："></a>二进制优化的思路：</h2><p>1.明确一个思想，例如一堆数字，1，2，4，8，16，32，64……可以用来表示1~128的任何一个数字。</p><p>所以对于多重背包问题，对于他的价值和体积来说，我们可以使用二进制将其拆解成一些子项。这样在朴素暴力的时候，我们是一个一个遍历的，但是二进制的时候，我们可以通过选取其中的一些值来达到之前需要选取多个同样体积与价值的累加的效果。</p><h4 id="当然，你也可以直接将过程理解成这样一个故事-估计会方便理解一些-："><a href="#当然，你也可以直接将过程理解成这样一个故事-估计会方便理解一些-：" class="headerlink" title="当然，你也可以直接将过程理解成这样一个故事(估计会方便理解一些)："></a>当然，你也可以直接将过程理解成这样一个故事(估计会方便理解一些)：</h4><p>我们想要从我们以前做过的题目中寻求思路，但是我们只写过01背包呀。唉！！正好，这些也是正好是有穷个数的物品，我们完全可以将其拆成一个一个的，但是你会发现，不行哎，没卵用，因为它仍然是一个个的，同之前的暴力做法不是一样的吗？？？(我是sb)</p><p>于是，我就在百度上或者是google上搜索，将一个大数如何可以拆解成很多小数，同时可以表示一段范围内的任意一个实数，唉，这时候你突然看到了，可以用二进制进行优化。</p><p>2.将有限个固定体积与价值的东西通过二进制累加变成不同体积与价值但是数量为1的物品，就转变成了01背包问题，然后套用01背包的模板即可。</p><p>所以优化在什么地方呢？</p><p>从时间复杂度来看，朴素做法的时间复杂度为O(mns) 。经过二进制优化后为O(2mnlogs).</p><p>其实就是相当于本来有n个东西，你需要一个个来看，但是通过二进制优化，我们可以用lgn的东西来进行表示。其实对于代码来说，循环的次数是没有发生变化的，只是做选择的次数由n变成lgn了。</p><p>这时候，提一句，</p><p>对于dp来说，dp的时间复杂度可以简单理解为</p><pre><code>dp的时间复杂度 == 问题的个数 * 问题选项的个数</code></pre><p>对了，还可以用dequeue，也就是单调队列进行优化，过一段时间在更……….</p>]]></content>
      
      
      
        <tags>
            
            <tag> 一日一题 背包dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划一日一题-10.6-完全背包问题</title>
      <link href="/2021/10/06/dong-tai-gui-hua-yi-ri-yi-ti-10-6-wan-quan-bei-bao-wen-ti/"/>
      <url>/2021/10/06/dong-tai-gui-hua-yi-ri-yi-ti-10-6-wan-quan-bei-bao-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h1><hr><p>有 N种物品和一个容量是 V的背包，每种物品都有无限件可用。</p><p>第 i种物品的体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 N行，每行两个整数 vi,wi，用空格隔开，分别表示第 i种物品的体积和价值。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N,V≤1000<br>0&lt;vi,wi≤1000</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><pre><code>4 51 22 43 44 5</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>10</code></pre><hr><p>我们会根据01背包自然而然的想到会用三次循环，但是这里的数据是1000，三次循环很显然会TLE。</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 1010 ; int f[N][N] ;int w[N] , v[N]  ;int main()&#123;    int n , m ;         cin >> n >> m ;         for(int i = 1 ; i <= n ; i++)    &#123;        cin >> v[i] >> w[i] ;     &#125;        for(int i = 1 ; i <= n  ; ++i)    &#123;        for(int j = 1 ; j <= m ; ++j)        &#123;            f[i][j] = f[i-1][j] ;             for(int 1 = 0 ; j - v[i] * k >= 0 ; k++)            &#123;                f[i][j] = max(f[i][j] , f[i-1][j-k*v[i]] + k*w[i]) ;            &#125;        &#125;    &#125;    cout << f[i][j] << endl ;    return 0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以我们后面开始考虑用二轮循环进行优化 。 </p><p>状态表示：同01背包问题，dp[i] [j] 表示的是，使用前i个物品并且体积不超过j的所能够实现的最大价值。</p><p>状态属性：max</p><p>base case：同01背包问题</p><p>状态转移：这可以通过小学数学来进行一个推导。</p><pre><code>f[i][j] = max(f[i-1][j] , f[i-1][j-v[i]] + w[i] , f[i-1][j-2*v[i]] + 2*w[i] + .....)f[i][j-v[i]] = max(f[i-1][j-v[i]] , f[i-1][j-2*v[i]]+2*w[i] + .....)//所以由一式与二式相消可知f[i][j] = max(f[i-1][j] , f[i][j-v[i]]+ w[i]) ;</code></pre><h2 id="错误的做法："><a href="#错误的做法：" class="headerlink" title="错误的做法："></a>错误的做法：</h2><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 1010 ;int f[N][N] ;int w[N] , v[N] ;int main()&#123;     int n , m ;         cin >> n >> m  ;         for(int i = 1 ; i <= n ; ++i)    &#123;        cin >> v[i] >> w[i] ;     &#125;        for(int i = 1 ; i <= n  ;++i)    &#123;        for(int j = 1 ; j <= m ; ++j)        &#123;            if(j >= v[i])            &#123;                f[i][j] = max(f[i-1][j] , f[i][j-v[i]]+w[i]) ; // 注意这样写是错的，这样会导致当j< v[i]的时候，没有东西进行迭代            &#125;        &#125;    &#125;    cout << f[n][m] << endl ;    return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="正确的做法："><a href="#正确的做法：" class="headerlink" title="正确的做法："></a>正确的做法：</h2><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 1010 ;int f[N][N] ;int w[N] , v[N] ;int main()&#123;     int n , m ;         cin >> n >> m  ;         for(int i = 1 ; i <= n ; ++i)    &#123;        cin >> v[i] >> w[i] ;     &#125;        for(int i = 1 ; i <= n  ;++i)    &#123;        for(int j = 1 ; j <= m ; ++j)        &#123;            f[i][j] = f[i-1][j] ;             if(j >= v[i])            &#123;                f[i][j] = max(f[i][j] , f[i][j-v[i]]+w[i]) ;             &#125;        &#125;    &#125;    cout << f[n][m] << endl ;    return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>形同01背包问题，由于完全背包问题也仅仅是用到了前一轮的值，所以我们完全可以进行一维的优化。</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 1010 ; int w[N] , v[N] ; int f[N] ; int main()&#123;    int n , m ;        cin >> n >> m ;             for(int i = 1 ; i <= n ; ++i)    &#123;        cin >> v[i] >> w[i] ;     &#125;            for(int i = 1 ; i <= n ; ++i)    &#123;        for(int j = v[i] ; j <= m ; ++j)        &#123;            f[j] = max(f[j] , f[j-v[i]]+w[i]) ;        &#125;    &#125;        cout << f[m] << endl ;        return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有的人肯定又会进行纠结，纠结的点就是在于j的循环顺序的问题，为什么这一次的j就是由小到大进行穷举的呢？</p><p>我们说一维的运算其实就是对二维的简化(这…. 好像是说了一句废话…..)，其实意思就是一维的逻辑就是二维的逻辑。我们反过来看二维的dp转移方程就知道了。</p><pre><code>f[i][j] = max(f[i-1][j] , f[i][j-v[i]]+w[i]) ;</code></pre><p>我们发现对于f[i-1] [j]来说，一维的毋庸置疑就是上一轮遗留下来的，对于f[i] [j-v[i]] + w[i] 来说，在一维的状态下必须是由该轮转移下来的，所以必须由小到大进行列举，小的赋值完了之后，才轮到大的进行赋值。</p><p>其实完全背包问题可以延申很多，例如我们之前说过的，整数划分问题。就可以理解为是一种完全背包问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 一日一题 背包dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL算法详解</title>
      <link href="/2021/10/05/stl-suan-fa-xiang-jie/"/>
      <url>/2021/10/05/stl-suan-fa-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="C-STL详解-建议收藏！！！"><a href="#C-STL详解-建议收藏！！！" class="headerlink" title="C++ STL详解(建议收藏！！！)"></a>C++ STL详解(建议收藏！！！)</h1><p>本蒟蒻写这篇分享的目的一个是为了写一个归纳总结方便自己以后随时能够复习还有就是给那些对STL还不是很了解的萌新介绍一下什么是STL以及如何使用STL更高效(偷懒)地解题。本篇文章将会长期更新<del>欢迎大家一起监督学习</del>有错误的地方或者需要补充的欢迎在评论区留言哦~</p><h2 id="一、什么是STL"><a href="#一、什么是STL" class="headerlink" title="一、什么是STL?"></a>一、什么是STL?</h2><p>STL(Standard Template Library，标准模板库)，是惠普实验室开发的一系列软件的统称。现主要出现在C++中，STL从广义上分为：容器(container)、算法(algorithm)和迭代器(iterator)。STL几乎所有的代码都采用了模板类或者模板函数，这相比传统的由函数和类组成的库来说提供了更好的代码重用机会。</p><h2 id="二、STL六大组件是什么"><a href="#二、STL六大组件是什么" class="headerlink" title="二、STL六大组件是什么?"></a>二、STL六大组件是什么?</h2><p>STL提供了六大组件，彼此之间可以组合套用，这六大组件分别是容器、算法、迭代器、仿函数、适配器、空间配置器。其中，在算法竞赛中用到最多的为容器、算法与迭代器。</p><p>容器(Container)：STL容器为各种数据结构，如vector、stack、queue、map、set等，用来存放数据，从实现角度来看，STL容器是一种class template。<br>算法(Algorithm)：STL的算法多数定义在<algorithm>头文件中，其中包括了各种常用的算法，如sort、find、copy、reverse等，从实现角度来看，STL算法是一种function template。<br>迭代器(Iterator)：STL迭代器扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将opetator*、opetator-&gt;、operator++等指针相关操作予以重载的class template。所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。<br>仿函数(Functor)：行为类似函数，可作为算法的某种策略，从实现角度来看，仿函数是一种重载了operator()的class或者class template。<br>适配器(Adaptor)：一种用来修饰容器或仿函数或迭代器接口的东西。<br>空间配置器(Allocator)：负责空间的配置与管理。从实现角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。</p><h2 id="三、STL容器详解"><a href="#三、STL容器详解" class="headerlink" title="三、STL容器详解"></a>三、STL容器详解</h2><p>相信很多人学习STL就是为了在比赛中能够更好地装B运用各种数据结构和算法，提高解题速度。确实，使用STL中的容器能够不需要自己手写定义各种数据结构，使用STL中的算法能够不需要自己手写实现各种基本算法，因此本部分对于算法巨巨们是最为重要的一部分，那么STL容器究竟有哪些呢?在做题中该如何使用呢?</p><h3 id="①-vector："><a href="#①-vector：" class="headerlink" title="① vector："></a>① vector：</h3><p>又称变长数组，定义在<vector>头文件中，vector容器是动态空间，随着元素的加入，它的内部机制会自动扩充空间以容纳新的元素。因此vector的运用对于内存的合理利用与运用的灵活性有很大的帮助。</p><p>vector的定义方式<br>    vector<int> v;//定义一个vector，其中的元素为int类型<br>    vector<int> v[N];//定义一个vector数组，其中有N个vector<br>    vector<int> v(len);//定义一个长度为len的vector<br>    vector<int> v(len, x);//定义一个长度为len的vector，初始化每个元素为x<br>    vector<int> v2(v1);//用v1给v2赋值，v1的类型为vector<br>    vector<int> v2(v1.begin(), v1.begin() + 3);//将v1中第0~2三个元素赋值给v2<br>vector的常用内置函数<br>    //vector中的常用内置函数<br>    vector<int> v = { 1, 2, 3 };//初始化vector，v:{1, 2, 3}<br>    vector<int>::iterator it = v.begin();//定义vector的迭代器，指向begin()</p><pre><code>v.push_back(4);//在vector的尾部插入元素4，v:&#123;1, 2, 3, 4&#125;v.pop_back();//删除vector的最后一个元素，v:&#123;1, 2, 3&#125;v.size();//返回vector中元素的个数v.empty();//返回vector是否为空，若为空则返回true否则返回falsev.front();//返回vector中的第一个元素v.back();//返回vector中的最后一个元素v.begin();//返回vector第一个元素的迭代器v.end();//返回vector最后一个元素后一个位置的迭代器v.clear();//清空vectorv.erase(v.begin());//删除迭代器it所指向的元素v.insert(v.begin(), 1);//在迭代器it所指向的位置前插入元素1//根据下标进行遍历for (int i = 0; i &lt; v.size(); i++)    cout &lt;&lt; v[i] &lt;&lt; &#39; &#39;;//使用迭代器遍历for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)    cout &lt;&lt; *it &lt;&lt; &#39; &#39;;//for_each遍历(C++11)for (auto x : v)    cout &lt;&lt; x &lt;&lt; &#39; &#39;;</code></pre><h3 id="②stack："><a href="#②stack：" class="headerlink" title="②stack："></a>②stack：</h3><p>又称栈，是一种后进先出(Last In First Out，LIFO)的数据结构，定义在<stack>头文件中，stack容器允许新增元素、移除元素、取得栈顶元素，但是除了最顶端以外，没有任何方法可以存取stack的其它元素，换言之，stack不允许有遍历行为。</p><p>stack的定义方式<br>    stack<int> stk;//定义一个stack，其中元素的类型为int<br>    stack<int> stk[N];//定义一个stack数组，其中有N个stack<br>stack的常用内置函数<br>    //stack中的常用内置函数<br>    stack<int> stk;<br>    stk.push(x);//在stack中插入元素x<br>    stk.pop();//弹出stack的栈顶元素<br>    stk.top();//返回stack的栈顶元素<br>    stk.size();//返回stack中元素的个数<br>    stk.empty();//返回stack是否为空，若为空则返回true否则返回false</p><h3 id="③string："><a href="#③string：" class="headerlink" title="③string："></a>③string：</h3><p>又称字符串，定义在<string>头文件中。C风格的字符串(以空字符结尾的字符数组)太过复杂难于掌握，因此C++标准库定义了一种string类。string玩得好，天梯和蓝桥拿个国奖真的有手就行，去年我刚大二的时候从零开始学算法，两个星期没学多少只学了string，校选拔就进前几了，后来的国赛也拿了点小奖(ACM就被打爆了)。因此熟练地运用string还是很重要滴~</p><p>string的定义方式<br>    string str;//定义一个空的字符串<br>    string str[N];//定义一个string数组，其中有N个string<br>    string str(5, ‘a’);//使用5个字符’a’初始化<br>    string str(“abc”);//使用字符串初始化<br>string的常用内置函数<br>    //string中的常用内置函数<br>    string str(“abcabc”);<br>    str.push_back(‘d’);//在string尾部插入字符，”abcabcd”<br>    str.pop_back();//删除string尾部的字符，”abcabc”<br>    str.length();//返回string中字符的个数<br>    str.size();//作用与length()相同<br>    str.empty();//返回string是否为空，若为空返回true否则返回false<br>    str.substr(1);//返回string中从下标为1开始至末尾的子串，”bc”<br>    str.substr(0, 2);//返回string中从下标为0开始长度为2的子串，”ab”<br>    str.insert(1, 2, ‘x’);//在下标为1的字符前插入2个字符’x’，”axxbcabc”<br>    str.insert(1, “yy”);//在下标为1的字符前插入字符串”yy”，”ayyxxbcabc”<br>    str.erase(1, 4);//删除从位置1开始的4个字符，”abcabc”<br>    str.find(‘b’);//返回字符’b’在string中第一次出现的位置，返回1<br>    str.find(‘b’, 2);//返回从位置2开始字符’b’在string中第一次出现的位置，返回4<br>    str.find(“bc”);//同上，返回字符串第一次出现的位置，返回1<br>    str.find(“bc”, 2);//返回4<br>    str.rfind(‘b’);//反向查找，原理同上，返回4<br>    str.rfind(‘b’, 3);//返回1<br>    str.rfind(“bc”);//返回4<br>    str.rfind(“bc”, 3);//返回1<br>    str[0];//用下标访问string中的字符<br>    cout &lt;&lt; (str == str) &lt;&lt; endl;//string可比较大小，按字典序<br>string的erase()与remove()函数的用法<br>    //string中erase()与remove()的用法<br>    string str1, str2, str3, str4, str5;<br>    str1 = str2 = str3 = str4 = str5 = “I love AcWing! It’s very funny!”;<br>    str1.erase(15);//删除[15,end())的所有元素，”I love AcWing!”<br>    str2.erase(6, 11);//从第6个元素(包括)开始往后删除11个元素，”I love’s very funny!”<br>    str3.erase(str3.begin() + 2);//删除迭代器所指的元素，”I ove AcWing! It’s very funny!”<br>    str4.erase(str4.begin() + 7, str4.end() - 11);//删除[str4.begin()+7,str4.end()-11)的所有元素，”I love very funny!”<br>    str5.erase(remove(str5.begin(), str5.end(), ‘n’), str5.end());//删除[str5.begin(),str5.end())中所有字符’n’，”I love AcWig! It’s very fuy!”</p><h3 id="④queue："><a href="#④queue：" class="headerlink" title="④queue："></a>④queue：</h3><p>又称队列，是一种先进先出(First In First Out，FIFO)的数据结构，定义在<queue>头文件中，queue容器允许从一端(称为队尾)新增元素(入队)，从另一端(称为队头)移除元素(出队)。</p><h3 id="⑤priority-queue："><a href="#⑤priority-queue：" class="headerlink" title="⑤priority_queue："></a>⑤priority_queue：</h3><p>又称优先队列，同样定义在<queue>头文件中，与queue不同的地方在于我们可以自定义其中数据的优先级，优先级高的排在队列前面，优先出队。priority_queue具有queue的所有特性，包括基本操作，只是在这基础上添加了内部的一个排序，它的本质是用堆实现的，因此可分为小根堆与大根堆，小根堆中较小的元素排在前面，大根堆中较大的元素排在前面。注意：创建priority_queue时默认是大根堆！</p><p>queue的定义方式<br>    queue<int> que;//定义一个queue，其中元素的类型为int<br>    queue<int> que[N];//定义一个queue数组，其中有N个queue<br>    priority_queue<int> smallHeap;//定义一个小根堆<br>    priority_queue&lt;int, vector<int>, greater<int> &gt; bigHeap;//定义一个大根堆<br>queue的常用内置函数<br>    //queue中的常用内置函数<br>    queue<int> que;<br>    que.push(x);//在queue的队尾插入元素x<br>    que.pop();//出队queue的队头元素<br>    que.front();//返回queue的队头元素<br>    que.back();//返回queue的队尾元素<br>    que.size();//返回stack中元素的个数<br>    que.empty();//返回stack是否为空，若为空则返回true否则返回false</p><h3 id="⑥deque："><a href="#⑥deque：" class="headerlink" title="⑥deque："></a>⑥deque：</h3><p>又称双端队列，定义在<deque>头文件中，vector容器是单向开口的连续内存空间，deque则是一种双向开口的连续线性空间。所谓的双向开口，意思是可以在头尾两端分别做元素的插入和删除操作，当然，vector也可以在头尾两端插入元素，但是在其头部进行插入操作效率奇差，无法被接受。deque和vector最大的差异一是在于deque允许使用常数项时间在头部进行元素的插入和删除操作，二是在于deque没有容量的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。</p><p>deque的定义方式<br>    deque<int> deq;//定义一个deque，其中的元素为int类型<br>    deque<int> deq[N];//定义一个deque数组，其中有N个deque<br>    deque<int> deq(len);//定义一个长度为len的deque<br>    deque<int> deq(len, x);//定义一个长度为len的deque，初始化每个元素为x<br>    deque<int> deq2(deq1);//用deq1给v2赋值，deq2的类型为deque<br>    deque<int> deq2(deq1.begin(), deq1.begin() + 3);//将deq1中第0~2三个元素赋值给deq2<br>deque的常用内置函数<br>    //deque中的常用内置函数<br>    deque<int> deq = { 1, 2, 3 };//初始化vector，v:{1, 2, 3}<br>    deque<int>::iterator it = deq.begin();//定义vector的迭代器，指向begin()</p><pre><code>deq.push_back(4);//在deque的尾部插入元素4，v:&#123;1, 2, 3, 4&#125;deq.pop_back();//删除deque的尾部元素，v:&#123;1, 2, 3&#125;deq.push_front(4);//在deque的头部插入元素4，v:&#123;4, 1, 2, 3&#125;deq.pop_front();//删除deque的头部元素，v:&#123;1, 2, 3&#125;deq.size();//返回vector中元素的个数deq.empty();//返回vector是否为空，若为空则返回true否则返回falsedeq.front();//返回vector中的第一个元素deq.back();//返回vector中的最后一个元素deq.begin();//返回vector第一个元素的迭代器deq.end();//返回vector最后一个元素后一个位置的迭代器deq.clear();//清空vectordeq.erase(deq.begin());//删除迭代器it所指向的元素deq.insert(deq.begin(), 1);//在迭代器it所指向的位置前插入元素1//根据下标进行遍历for (int i = 0; i &lt; deq.size(); i++)    cout &lt;&lt; deq[i] &lt;&lt; &#39; &#39;;//使用迭代器遍历for (deque&lt;int&gt;::iterator it = deq.begin(); it != deq.end(); it++)    cout &lt;&lt; *it &lt;&lt; &#39; &#39;;//for_each遍历(C++11)for (auto x : deq)    cout &lt;&lt; x &lt;&lt; &#39; &#39;;</code></pre><h3 id="⑦map-multimap："><a href="#⑦map-multimap：" class="headerlink" title="⑦map/multimap："></a>⑦map/multimap：</h3><p>又称映射，定义在<map>头文件中，map和multimap的底层实现机制都是红黑树。map的功能是能够将任意类型的元素映射到另一个任意类型的元素上，并且所有的元素都会根据元素的键值自动排序。map所有的元素都是pair，同时拥有实值和键值，pair的第一元素被视为键值，第二元素被视为实值，map不允许两个元素有相同的键值。multimap和map的操作类似，唯一区别是multimap的键值允许重复。</p><p>map/multimap的定义方式<br>    map&lt;string, int&gt; mp;//定义一个将string映射成int的map<br>    map&lt;string, int&gt; mp[N];//定义一个map数组，其中有N个map<br>    multimap&lt;string, int&gt; mulmp;//定义一个将string映射成int的multimap<br>    multimap&lt;string, int&gt; mulmp[N];//定义一个multimap数组，其中有N个multimap<br>map/multimap的常用内置函数<br>    //map/multimap中的常用内置函数<br>    map&lt;string, int&gt; mp;<br>    mp[“abc”] = 3;//将”abc”映射到3<br>    mp[“ab”]++;//将”ab”所映射的整数++<br>    mp.insert(make_pair(“cd”, 2));//插入元素<br>    mp.insert({ “ef”, 5 });//同上<br>    mp.size();//返回map中元素的个数<br>    mp.empty();//返回map是否为空，若为空返回true否则返回false<br>    //mp.clear();//清空map<br>    mp.erase(“ef”);//清除元素{“ef”, 5}<br>    mp[“abc”];//返回”abc”映射的值<br>    mp.begin();//返回map第一个元素的迭代器<br>    mp.end();//返回map最后一个元素后一个位置的迭代器<br>    mp.lower_bound(“abc”);//返回第一个键值大于等于”abc”的元素的迭代器，{“abc”, 3}<br>    mp.upper_bound(“abc”);//返回第一个键值大于”abc”的元素的迭代器，{“cd”, 2}</p><pre><code>//使用迭代器遍历for (map&lt;string, int&gt;::iterator it = mp.begin(); it != mp.end(); it++)    cout &lt;&lt; (*it).first &lt;&lt; &#39; &#39; &lt;&lt; (*it).second &lt;&lt; endl;//for_each遍历(C++11)for (auto x : mp)    cout &lt;&lt; x.first &lt;&lt; &#39; &#39; &lt;&lt; x.second &lt;&lt; endl;//扩展推断范围的for_each遍历(C++17)for (auto &amp;[k, v] : mp)    cout &lt;&lt; k &lt;&lt; &#39; &#39; &lt;&lt; v &lt;&lt; endl;</code></pre><h3 id="⑧set-multiset："><a href="#⑧set-multiset：" class="headerlink" title="⑧set/multiset："></a>⑧set/multiset：</h3><p>又称集合，定义在<set>头文件中。set的特性是所有元素都会根据元素的键值自动被排序，set的元素不像map那样可以同时拥有实值和键值，set的元素既是键值又是实值，set不允许两个元素有相同的键值，因此总结来说就是set中的元素是有序且不重复的。multiset的特性和用法和set完全相同，唯一的区别在于multiset允许有重复元素，set和multiset的底层实现都是红黑树。</p><p>set/multiset的定义方式<br>    set<int> st;//定义一个set，其中的元素类型为int<br>    set<int> st[N];//定义一个set数组，其中有N个set<br>    multiset<int> mulst;//定义一个multiset<br>    multiset<int> mulst[N];//定义一个multiset数组，其中有N个multiset<br>set/multiset的常用内置函数<br>    //set/multiset中的常用内置函数<br>    set<int> st;<br>    st.insert(5);//插入元素5<br>    st.insert(6);//同上<br>    st.insert(7);//同上<br>    st.size();//返回set中元素的个数<br>    st.empty();//返回set是否为空，若为空返回true否则返回false<br>    st.erase(6);//清除元素6<br>    st.begin();//返回set第一个元素的迭代器<br>    st.end();//返回set最后一个元素后一个位置的迭代器<br>    st.clear();//清空set<br>    st.lower_bound(5);//返回第一个键值大于等于5的元素的迭代器，返回元素5的迭代器<br>    st.upper_bound(5);//返回第一个键值大于5的元素的迭代器，返回元素7的迭代器</p><pre><code>//使用迭代器遍历for (set&lt;int&gt;::iterator it = st.begin(); it != st.end(); it++)    cout &lt;&lt; (*it) &lt;&lt; &#39; &#39;;//for_each遍历(C++11)for (auto x : st)    cout &lt;&lt; x &lt;&lt; &#39; &#39;;</code></pre><h3 id="⑨unordered-map-unordered-set："><a href="#⑨unordered-map-unordered-set：" class="headerlink" title="⑨unordered_map/unordered_set："></a>⑨unordered_map/unordered_set：</h3><p>分别定义在<unordered_map>与<unordered_set>头文件中，内部采用的是hash表结构，拥有快速检索的功能。与map/set相比最大的区别在于unordered_map/unordered_set中的元素是无序的，增删改查的时间复杂度为O(1)(map/set增删改查的时间复杂度为O(logn))，但是不支持lower_bound()/upper_bound()函数。</p><p>unordered_map/unordered_set的定义方式<br>    unordered_set<int> st;//定义一个unordered_set，其中的元素类型为int<br>    unordered_set<int> st[N];//定义一个unordered_set数组，其中有N个unordered_set<br>    unordered_map&lt;int, int&gt; mp;//定义一个unordered_map<br>    unordered_map&lt;int, int&gt; mp[N];//定义一个unordered_map数组，其中有N个unordered_map<br>unordered_map/unordered_set的常用内置函数<br>    //unordered_map/unordered_set中的常用内置函数<br>    unordered_set<int> st;<br>    unordered_map&lt;int, int&gt; mp;<br>    st.insert(5);//插入元素5<br>    st.insert(6);//同上<br>    st.insert(7);//同上<br>    st.size();//返回unordered_set中元素的个数<br>    st.empty();//返回unordered_set是否为空，若为空返回true否则返回false<br>    st.erase(6);//清除元素6<br>    st.begin();//返回unordered_set第一个元素的迭代器<br>    st.end();//返回unordered_set最后一个元素后一个位置的迭代器<br>    st.clear();//清空unordered_set<br>    mp.insert(make_pair(1, 2));//插入元素{1, 2}<br>    mp.insert({ 3, 4 });//同上<br>    mp.size();//返回unordered_map中元素的个数<br>    mp.empty();//返回unordered_map是否为空，若为空返回true否则返回false<br>    mp.erase(3);//清除元素{3, 4}<br>    mp.begin();//返回unordered_map第一个元素的迭代器<br>    mp.end();//返回unordered_map最后一个元素后一个位置的迭代器<br>    mp.clear();//清空unordered_map</p><pre><code>//使用迭代器遍历for (unordered_set&lt;int&gt;::iterator it = st.begin(); it != st.end(); it++)    cout &lt;&lt; (*it) &lt;&lt; &#39; &#39;;//for_each遍历(C++11)for (auto x : st)    cout &lt;&lt; x &lt;&lt; &#39; &#39;;//使用迭代器遍历for (unordered_map&lt;int, int&gt;::iterator it = mp.begin(); it != mp.end(); it++)    cout &lt;&lt; (*it).first &lt;&lt; &#39; &#39; &lt;&lt; (*it).second &lt;&lt; endl;//for_each遍历(C++11)for (auto x : mp)    cout &lt;&lt; x.first &lt;&lt; &#39; &#39; &lt;&lt; x.second &lt;&lt; endl;//扩展推断范围的for_each遍历(C++17)for (auto &amp;[k, v] : mp)    cout &lt;&lt; k &lt;&lt; &#39; &#39; &lt;&lt; v &lt;&lt; endl;</code></pre><h2 id="四、STL算法详解"><a href="#四、STL算法详解" class="headerlink" title="四、STL算法详解"></a>四、STL算法详解</h2><p>C++标准库定义了一组泛型算法，之所以称为泛型指的是它们可以操作在多种容器上，不但可以作用于标准库类型，还可以用在内置数组类型甚至其它类型的序列上。泛型算法定义在<algorithm>头文件中，标准库还定义了一组泛化的算术算法(Generalized Numeric Algorithm)，定义在<numeric>头文件中。</p><p>作者：AsanoSaki<br>链接：<a href="https://www.acwing.com/blog/content/10558/">https://www.acwing.com/blog/content/10558/</a><br>来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 好资源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划一日一题-10.5-01背包问题</title>
      <link href="/2021/10/05/dong-tai-gui-hua-yi-ri-yi-ti-10-5-01-bei-bao-wen-ti/"/>
      <url>/2021/10/05/dong-tai-gui-hua-yi-ri-yi-ti-10-5-01-bei-bao-wen-ti/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h1><p>有 N 件物品和一个容量是 V的背包。每件物品只能使用一次。</p><p>第 i件物品的体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N,V≤1000<br>0&lt;vi,wi≤1000</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><pre><code>4 51 22 43 44 5</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>8</code></pre><hr><p>还是用之前的分析方法来分析：</p><p>状态表示：f[i] [j] 表示使用前i个物品，且总体积不大于j的时候，所实现的最大价值</p><p>状态属性：max</p><p>base case：f[i] [0] = 0 ; f[0]  [i] = 0 (因为此题的base case来说，我们申请dp数组的时候就是申请的全局变量，默认值直接是0，所以这一题的base case没有显性的展现出来)。</p><p>状态转移：分成两块，任何状态都可以分成两个状态，一是不使用第i个物品，二是使用第i件物品。分隔条件是v[i] 与j的大小关系。</p><p>代码如下：</p><pre class="line-numbers language-c++"><code class="language-c++">#include<bits/stdc++.h>using namespace std ;const int N = 1010 ; int f[N][N] ;int w[N] , v[N] ;int main()&#123;    int n , m ;         cin >> n >> m ;         for(int i = 1 ; i <= n ; ++i)    &#123;        cin >> v[i] >> w[i] ;    &#125;            for(int i = 1 ; i <= n ; ++i)    &#123;        for(int j = 1 ; j <= m ;++j)        &#123;            f[i][j] = f[i-1][j] ;            if(v[i] <= j)            &#123;                f[i][j] = max(f[i][j] , f[i-1][j-v[i]]  + w[i]) ;            &#125;        &#125;    &#125;    cout << f[n][m] << endl ;    return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>仔细阅读上述代码之后，我们发现可以采用一维数组进行优化。因为i在这题来说，可以根据循环的由小到大的次序进行省略。</p><p>其中有一个比较难理解的点就是，对于二层循环的j来说，不应该是有小到大进行穷举，而是应该是由大到小进行穷举，因为对于二维代码来说，有一个i用来指向此时的j是上一次的循环的还是下一次循环的，状态转移是由上一次循环转移来的，所以不管j是大还是小，都是上一次循环来赋值的。但是对于一维的dp数组来说，没有i作为指向，必须通过j的列举顺序来体现是上一轮循环的状态转移。</p><p>当然，最简单的理解就是一维的dp方法必须要满足二维的dp方法的逻辑思路。所以对于j的列举顺序必须满足，f[j]的状态必须是上次循环中j的值比现在小的dp值转移过来的。</p><p>所以，根据这一条原则，j如果不变化，仍然是由小到大进行列举的话，虽然是由比自己小的j的dp值转移过来的，但是这些值都是由本轮循环进行迭代之后得到的值，并不是上一轮循环所遗留下来的，这就导致了逻辑出现了错误。</p><p>优化空间后的代码如下：</p><pre class="line-numbers language-c++"><code class="language-c++">#include<bits/stdc++.h>using namespace std ;const int N = 1010 ; int f[N] ;int w[N] , v[N] ;int main()&#123;    int n , m ;         cin >> n >> m ;         for(int i = 1 ; i <= n ; ++i)    &#123;        cin >> v[i] >> w[i] ;    &#125;            for(int i = 1 ; i <= n ; ++i)    &#123;        for(int j = m ; j >= 0 ; --j)        &#123;            if(v[i] <= j)            &#123;                f[j] = max(f[j] , f[j-v[i]]  + w[i]) ;            &#125;        &#125;    &#125;        cout << f[m] << endl ;        return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 一日一题 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器删除的大坑</title>
      <link href="/2021/10/04/die-dai-qi-shan-chu-de-da-keng/"/>
      <url>/2021/10/04/die-dai-qi-shan-chu-de-da-keng/</url>
      
        <content type="html"><![CDATA[<h1 id="迭代器删除的坑"><a href="#迭代器删除的坑" class="headerlink" title="迭代器删除的坑"></a>迭代器删除的坑</h1><p>今天在字符串定点删除固定元素的时候，出现了大问题，百思不得其解。</p><p>题目简单描述是这样的：</p><hr><p>给定一个字符串str,targe元素是‘a’，通过erase方法进行删除</p><p>代码是这样的:</p><pre class="line-numbers language-c++"><code class="language-c++">#include<bits/stdc++.h>using namespace std ;int main()&#123;    string str = "ahsdjkafbnaasdfjkanasjkdfbhjasddkaldfasa" ;         for(auto it = str.begin() ;  it != str.end() ;  ++ it)    &#123;        if(*it == 'a')        &#123;            str.erase(it) ;        &#125;    &#125;    cout << str << endl ;    return 0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>但是出现了大问题，呜呜呜呜……</p><p>在leetcode的ide里面，我是发现了根本删不干净，于是我调试了好久，并且上网查找资料，终于找到了问题所在。</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;int main()&#123;    string str = "ahsdjkafbnaasdfjkanasjkdfbhjasddkaldfasa" ;         auto it = str.begin() ;         while( it != str.end())    &#123;        if(*it == 'a')        &#123;            str.erase(it) ;        &#125;        else        &#123;            it ++ ;        &#125;    &#125;        cout << str << endl ;        return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="对于关联容器"><a href="#对于关联容器" class="headerlink" title="对于关联容器"></a>对于关联容器</h2><p>如map,set,unordered_map容器来说，例如map的底层是由红黑树实现的，当删除一个或者多个节点的时候，并不会导致其他节点的波动。</p><h2 id="对于非关联式的容器-序列容器"><a href="#对于非关联式的容器-序列容器" class="headerlink" title="对于非关联式的容器(序列容器)"></a>对于非关联式的容器(序列容器)</h2><p>例如vector，string，list，queue等容器，这些是有连续分配内存的，所以当删除了当前迭代器的指针，会使后来的元素都往前移动一位，所以会使后续的所有元素的指针都失效。</p><p>目前有两种可以用的方法：</p><p>第一种是采用while循环：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;int main()&#123;    string str = "asfhjkasnaaseelfha" ;        auto it = str.begin() ;         while(it != str.end())    &#123;        if(* it == 'a')        &#123;            str.erase(it) ;        &#125;        else        &#123;            it ++ ;        &#125;    &#125;    cout << str << endl ;    return 0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二种采用的是用erase方法得到下一个有效的迭代器指针：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;int main()&#123;    string str = "asfhjkasnaaseelfha" ;        for(auto it = str.begin() ; it != str.end() ; )    &#123;        if(*it == 'a')        &#123;            it = it.erase(it) ;         &#125;        else        &#123;            it ++ ;        &#125;    &#125;    cout << str << endl ;    return 0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划一日一题-10.4-编辑距离</title>
      <link href="/2021/10/04/dong-tai-gui-hua-yi-ri-yi-ti-10-4-bian-ji-ju-chi/"/>
      <url>/2021/10/04/dong-tai-gui-hua-yi-ri-yi-ti-10-4-bian-ji-ju-chi/</url>
      
        <content type="html"><![CDATA[<h1 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h1><hr><p>给定 n个长度不超过 10 的字符串以及 m 次询问，每次询问给出一个字符串和一个操作次数上限。</p><p>对于每次询问，请你求出给定的 n 个字符串中有多少个字符串可以在上限操作次数内经过操作变成询问给出的字符串。</p><p>每个对字符串进行的单个字符的插入、删除或替换算作一次操作。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 n和 m。</p><p>接下来 n行，每行包含一个字符串，表示给定的字符串。</p><p>再接下来 m 行，每行包含一个字符串和一个整数，表示一次询问。</p><p>字符串中只包含小写字母，且长度均不超过 10。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出共 m 行，每行输出一个整数作为结果，表示一次询问中满足条件的字符串个数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n,m≤1000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>3 2abcacdbcdab 1acbd 2</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>13</code></pre><hr><p>总体考察dp的方式就是同最小编辑距离是一致的，这里再次将最小编辑距离再次巩固一次。</p><p>设置一个函数，用于返回从字符串a变化到字符串b的时候，所需要的最小的次数。</p><p>主函数则用每次返回的次数与limit进行比较，如果比limit小，num++即可。</p><p>对于edit_distance函数来说：</p><p>状态表示：f [i] [j] 就是字符串a的1-i位置变化到字符串b的1-j位置所需要的最小次数</p><p>状态属性：min</p><p>base case : 一般考虑是包括f[0]的初始化</p><p>状态转移：每一次将f[i-1] [j] and f[i] [j-1]  的最小值先赋值给f[i] [j] (也就是所谓的删除和插入)</p><p>​                    一般对于字符串类型的题目来说，分界限很多是字符是否是相等的，如果相等的话，直接pass掉。</p><p>​                    如果不相等，就是各自回到原来的一步，然后做一个替换即可。</p><p>代码如下：</p><pre class="line-numbers language-c++"><code class="language-c++">#include<bits/stdc++.h>using namespace std ;const int N = 1010 ; int f[N][N] ;char str[N][N] ;int edit_distance(char a[] , char b[])&#123;    int la = strlen(a+1) ;  int lb = strlen(b+1) ;        for(int i = 1 ; i <= la ; ++i)    &#123;        f[i][0] = i ;    &#125;        for(int i = 1 ; i <= lb ;++i)    &#123;        f[0][i] = i  ;    &#125;        for(int i = 1 ; i <= la ;++i)    &#123;        for(int j = 1 ; j <= lb ;++j)        &#123;            f[i][j] = min(f[i-1][j] , f[i][j-1])  + 1 ;            if(a[i] == b[j])            &#123;                f[i][j] = min(f[i][j] , f[i-1][j-1]) ;              &#125;            else            &#123;                f[i][j] = min(f[i][j] , f[i-1][j-1]  +1) ;            &#125;        &#125;    &#125;    return f[la][lb] ;&#125;int main()&#123;    int n , m  ;         cin >> n >> m ;        for(int i = 1 ; i <= n ;++ i)    &#123;        cin >> (str[i]  +1 );     &#125;        while(m--)    &#123;        int num = 0 ;         char c[N] ;        int limit = 0 ;         cin >> (c+1) >> limit ;         for(int i = 1 ; i <= n ;++i)        &#123;            if(edit_distance(str[i] , c) <= limit)            &#123;                num ++ ;            &#125;        &#125;        cout << num << endl ;     &#125;    return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 一日一题 线性dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划一日一题-10.3-整数划分</title>
      <link href="/2021/10/03/dong-tai-gui-hua-yi-ri-yi-ti-10-3-zheng-shu-hua-fen/"/>
      <url>/2021/10/03/dong-tai-gui-hua-yi-ri-yi-ti-10-3-zheng-shu-hua-fen/</url>
      
        <content type="html"><![CDATA[<h1 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h1><hr><p>一个正整数 n 可以表示成若干个正整数之和，形如：n=n1+n2+…+nk，其中 n1≥n2≥…≥nk,k≥1。</p><p>我们将这样的一种表示称为正整数 n 的一种划分。</p><p>现在给定一个正整数 n，请你求出 n 共有多少种不同的划分方法。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>共一行，包含一个整数 n。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含一个整数，表示总划分数量。</p><p>由于答案可能很大，输出结果请对 109+7取模。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤1000</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h4><pre><code>5</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>7</code></pre><hr><p>该题是典型的整数划分类问题，也可以将其理解成完全背包问题。所以该题就可以转换为现在有n种物品，第i种背包的容量是i，数量为无穷，请问能装满体积为n的背包的方案数是多少？</p><p>同完全背包问题，我们先想朴素算法。用f[i] [j] 表示用前i个物品来装满体积为j的背包的方案数。</p><p>状态表示：f[i] [j] 表示用前i个物品装满j的背包的方案数，最终的结果就可以标示为f[n] [ n] ; </p><p>状态属性：无</p><p>状态转移：f[i] [j] = f[i-1] [ j] +f[i-1] [j-i] +f[i-1] [j-2*i] + …+ </p><p>​                    f[i] [j-i] =                f[i-1] [j-i] + f[i-1] [j- 2*i] + … + </p><p>故有数学推导可得：</p><p>f[i] [j] = f[i-1] [j] + f[i] [j-i] </p><p>base case ：比较玄学，基于现在的水平，我觉得就是把二维数组涉及下标为0的可以提前知道的给初始化一下，比如这一题：</p><p>f[i] [0] 是可以提前知道的，同时也是转移的起始点。</p><pre class="line-numbers language-c++"><code class="language-c++">//朴素做法#include <bits/stdc++.h>using namespace std ;const int N = 1010  , mod = 1e9+7;int f[N][N] ;int main()&#123;    int n ;     cin >> n  ;        //base case        for(int i = 1 ; i <= n ;++i)    &#123;        f[i][0] = 1 ;    &#125;        for(int i = 1 ; i <= n ;++i)    &#123;        for(int j = 1 ; j <= n ;++j)        &#123;            f[i][j] = f[i-1][j] % mod ;            if(j >= i)                 f[i][j] = (f[i-1][j] + f[i][j-i]) % mod ;         &#125;    &#125;    cout << f[n][n] << endl ;    return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">//做了一点优化#include <bits/stdc++.h>using namespace std ;const int  N = 1010 , mod = 1e9+7;int f[N] ; int main()&#123;    int n ;     cin >> n ;      for(int i = 1 ; i <= n ;++i)        f[0] = 1 ;          for(int i = 1 ; i <= n ;++i)    &#123;        for(int j = 1 ; j <= n ; ++j)        &#123;            if(j >= i)                f[j] = (f[j] +f[j-i]) % mod ;        &#125;    &#125;    cout << f[n] << endl ;    return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 一日一题 计数dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>没有问题的答案</title>
      <link href="/2021/10/02/mei-you-wen-ti-de-da-an/"/>
      <url>/2021/10/02/mei-you-wen-ti-de-da-an/</url>
      
        <content type="html"><![CDATA[<h1 id="没有答案的问题"><a href="#没有答案的问题" class="headerlink" title="没有答案的问题"></a>没有答案的问题</h1><p>今天在看文献的时候突然想到一个有趣的问题，每一篇文献里面都有很多篇引用。如果用一个数据结构来表示，所有文献的集合就是一张非常复杂的网络图。所以说，只要从当前任意一篇文献开始，顺着其中任意一篇引用文献，不断向前找，终可以找到一篇甚至说是第一篇没有任何引用文献的论文。</p><p>又想到年初Clubhouse爆火的时候，由于当时注册软件只能是邀请制，所以每一个注册的用户都有一个比他更早注册的邀请人。而这个邀请人正好就被放在了每一个用户的个人主页上，于是当时我很好奇地顺着整个链条点到了最后。不意外，最后这个没有邀请人的用户就是这个软件的创始人之一。</p><p>这么想，顺着链条去找寻一个东西还是一件挺有趣的事。但是呢，有时候这个链条可能没有终点，找寻的过程也没有这么简单。</p><p>之前有看到一篇文章讲《如何把一个成年人逼疯？》，那你只需要不断地问他问题。</p><p>就拿一个简单的问题说：为什么天空是蓝色的？ 有点常识的人会回答：因为光的散射。那继续追问：什么是散射，又为什么只散射蓝色的光？这个时候你可能就得去查查资料了：这是因为瑞利散射，波长越短的光波散射强度更大… 那么光为什么会发生散射？光的本质是什么？人眼为什么能看到这些颜色…</p><p>如果真的这么一直追问下去，不说把人逼疯，至少会让人觉得你这是在故意找茬，最后让一个人生气还是很容易的。</p><p>上面回答的过程，就是不断用一个概念去解释另一个概念，然后在回答的过程中又引出了更多的概念。所以说，有时候你认为的答案可能并不是真正的答案，至少很大可能下都不是那个最终的答案。</p><p>面对一个问题，我们都想要得到一个答案。但是最终的答案止步于哪，对不同的人来说可能是不一样的。因为每个人对答案的追求是不一样的。有趣的是，如果你愿意不断追问，在这个过程中，你问得越深，可能会发现原来的答案并不是自己想要的那个答案了，自己原本以为懂的东西发现又不懂了。</p><p>所以即使当你停止追问时，当你以为你已经找到答案时，当前的答案也不一定是最终答案，但它一定是一个你愿意接受的答案。</p><p>所以啊，人就是要保持无知，“我知道”三个字就还是不要轻易说出口了。你以为的你知道可能对别人来说并不是他们想要的答案，你我认为的答案也都不一定是最终答案，它们只是不同的人在不同思考维度不同深度上的一个临时结果罢了。</p><p>回答里面有回答，问题里面有问题，这一个链条的探索过程和上面是一样的。科学家通过这种不断提问，发现问题，想知道这最后的答案究竟是什么，然后去不断追寻一切背后的答案。于是在这个过程中，科学家们为了解释创造出了无数的概念，人们也在这个过程中更好地认识了这个世界，也学到了更多的知识。</p><p>之前在学模拟集成电路的时候，从CMOS管开始，为了了解底层细节转向学习了半导体物理，为了更好地理解电子运动，顺着知识的脉络又看到电动力学，再深究，是量子力学…虽然最后说服了自己，有许多东西是没有必要看的，但是这个追寻知识链条的过程还是很有意义的。不断问问题和寻找答案的过程并不容易，这也是为什么大部分人都成为不了科学家。</p><p>小时候就知道对问题要刨根问底，多问一些为什么。但是越长大，由于环境的原因，思维越惰性，越来越不愿意思考，越不愿意问为什么了。</p><p>上面这种不断问问题的方式，其实也为我们构建自己的知识系统提供了一个思路。一般来说，我们学习的知识是离散的，一个个孤立的知识点，当它们足够多的时候就会编织成网。但是，我们也可以主动地顺着知识点，不断去找出一条可以串起来的知识脉络。</p><p>虽然问问题是一个能够让人思考的很好的办法，在这个过程中我们会发现自己的无知，会学习到新的知识。但是现实中的问题往往没有那么简单，有的问题不能立即得到答案，可能需要很多年去解答，甚至有的问题，都没有一个正确答案。真正重要的，是我们问问题过程中的思考，与我们思考的结果。为什么问问题的能力如此重要，因为这个世界需要的是解决问题的人，真正稀缺的有技术的人是具有独立思考自己独立解决问题的人。</p><p>又比如有这样一个问题：已知有一个直角三角形，斜边长是 10，斜边上的高是 6，问这个直角三角形的面积是多少？</p><p>乍一看，三角形面积 = 底 × 高 / 2 = 30</p><p>但事实却是无解，这样的直角三角形并不存在。大家以前都学过，圆直径所对的圆周角是90度。所以以直角三角形的斜边为直径作一个圆，连接圆上任意一点就可以得到以该直径为斜边的所有直角三角形。但是以这道题为例，这些三角形中斜边上的高最大只能为这个圆的半径长度，也就是5，这就是说并不可能存在高为6的直角三角形。</p><p>以前在学校的时候，学习一个知识点要做好多题，为的是再遇到时能够更快地上手。做更多的题能提高熟练度是没错，最后还能很好的达到一个平均水准。但是在这个过程中渐渐淡化了我们真正的分析问题的能力，于是遇到新问题，大部分时候都习惯性地套用经验，甚至忘了如何从根本上发现问题，分析问题和解决问题。</p><p>分析能力，更是一种底层逻辑能力，之前一直在想底层逻辑能力是什么。后来觉得底层逻辑可能就像亚里士多德的“三段论”那样的一个思维模型。这个世界这么复杂，现实的问题也各种各样，每天面对的信息也越来越多，我们需要学会要建立自己的一个思考模型。例如考虑信息源的可靠性，数据的真实性，结论的因果性…但是要做到下意识地去思考分析问题，还是挺难的，多思考吧。</p><p>另一方面，以前做题的时候，如果做不出来，第一时间会觉得肯定不是自己的问题，会觉得是题出错了。到后来，会先反思一下是不是自己题读错了，因为认为自己犯错的几率会大更多。现在有时候对一些现象也好，问题也好，也会想不通，就会反思是自己的问题呢还是别人的问题。唉，有时候质疑别人质疑自己都是一件挺难的事。</p><p>像上面的问题，其实如果不是指出了问题，可能自己觉得算出来的已经是正确答案了。就像上面说到的，你认为自己知道的答案不一定是真正的答案，即使看起来很正确，可能也只是无知的体现。</p><p>当然了，有一些问题也确实无解，生活中，想不明白的事多了去了，解释不了，解决不了的事也多了去了。导致问题无解的出现可能是由于限制太多，有时候卸下一些条件，可能就有解了。</p><p>面对生活中的问题，无解时会焦虑，有解时又想着最优解，人啊，总是这么贪心。</p><p>但是呢，其实无解也是一个答案，只是看你愿不愿意接受罢了。</p><p>作者：Coderoger<br>链接：<a href="https://www.acwing.com/file_system/file/content/whole/index/content/3006746/">https://www.acwing.com/file_system/file/content/whole/index/content/3006746/</a><br>来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划一日一题-10.2-石子合并</title>
      <link href="/2021/10/02/dong-tai-gui-hua-yi-ri-yi-ti-10-2-shi-zi-he-bing/"/>
      <url>/2021/10/02/dong-tai-gui-hua-yi-ri-yi-ti-10-2-shi-zi-he-bing/</url>
      
        <content type="html"><![CDATA[<h1 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h1><p>设有 NN 堆石子排成一排，其编号为 1，2，3，…，N1，2，3，…，N。</p><p>每堆石子有一定的质量，可以用一个整数来描述，现在要将这 NN 堆石子合并成为一堆。</p><p>每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。</p><p>例如有 44 堆石子分别为 <code>1 3 5 2</code>， 我们可以先合并 1、21、2 堆，代价为 44，得到 <code>4 5 2</code>， 又合并 1，21，2 堆，代价为 99，得到 <code>9 2</code> ，再合并得到 1111，总代价为 4+9+11=244+9+11=24；</p><p>如果第二步是先合并 2，32，3 堆，则代价为 77，得到 <code>4 7</code>，最后一次合并代价为 1111，总代价为 4+7+11=224+7+11=22。</p><p>问题是：找出一种合理的方法，使总的代价最小，输出最小代价。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行一个数 NN 表示石子的堆数 NN。</p><p>第二行 NN 个数，表示每堆石子的质量(均不超过 10001000)。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最小代价。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤300</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>41 3 5 2</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>22</code></pre><h3 id="经典区间dp问题："><a href="#经典区间dp问题：" class="headerlink" title="经典区间dp问题："></a>经典区间dp问题：</h3><p>状态表示：采用二维数组，f[i] [j] 表示的是合并了从i到j的石子之后，所得到的最小代价.最后答案的表示即为f[1] [n] .</p><p>状态属性： min</p><p>base case: </p><p>状态转移：因为我们选定的状态其实是一段区间的最小状态，所以我们先要选取区间用len来表示，然后对于每一个区间内部来说.</p><p>我们考虑到每一个区间所谓的最小代价，最后必将是左边一个连续的集合与右边一个连续的集合进行相加，这两个集合同时也是可以用我们的f数组来表示，这也就是我们这一题可以用dp来做的原因。我们采用设置一个k，来作为起点和终点的一个中断点，通过对k在i到j(即每个区间)的放置位置，来选择局部最优的方式。最终，不断迭代，即可得到最终的答案。</p><p>不说了，上代码：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 310  ; int f[N][N] ;int w[N] ;int main()&#123;    int n ;     cin >> n ;         for(int i = 1 ; i <= n ;++i)    &#123;        cin >> w[i] ;        w[i] += w[i-1] ;    &#125;            for(int len = 2 ; len <= n ; ++len)    &#123;        for(int i = 1 ; i <= n + 1 -len; i ++)        &#123;            int j = len + i - 1 ;            f[i][j] = 1e9  ;        for(int k = i ; k < j ;++k)        &#123;            f[i][j] = min(f[i][j] , f[i][k]+f[k+1][j]+ w[j] -w[i-1]) ;        &#125;           &#125;    &#125;    cout << f[1][n] << endl  ;     return 0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 一日一题 区间dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划一日一题-10-1-最小编辑距离</title>
      <link href="/2021/10/01/dong-tai-gui-hua-yi-ri-yi-ti-10.1-zui-xiao-bian-ji-ju-chi/"/>
      <url>/2021/10/01/dong-tai-gui-hua-yi-ri-yi-ti-10.1-zui-xiao-bian-ji-ju-chi/</url>
      
        <content type="html"><![CDATA[<h1 id="最小编辑距离"><a href="#最小编辑距离" class="headerlink" title="最小编辑距离"></a>最小编辑距离</h1><hr><p>给定两个字符串 A 和 B，现在要将 A 经过若干操作变为 B，可进行的操作有：</p><ol><li>删除–将字符串 A 中的某个字符删除。</li><li>插入–在字符串 A 的某个位置插入某个字符。</li><li>替换–将字符串 A 中的某个字符替换为另一个字符。</li></ol><p>现在请你求出，将 A 变为 B 至少需要进行多少次操作。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n，表示字符串 A 的长度。</p><p>第二行包含一个长度为 n 的字符串 A。</p><p>第三行包含整数 m，表示字符串 B 的长度。</p><p>第四行包含一个长度为 m 的字符串 B。</p><p>字符串中均只包含大写字母。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最少操作次数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n,m≤1000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>10 AGTCTGACGC11 AGTAAGTAGGC</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>4</code></pre><hr><p>由dp的思想，显然需要创建一个二维的数组。</p><h3 id="定义明确"><a href="#定义明确" class="headerlink" title="定义明确"></a>定义明确</h3><p>首先明确dp数组的定义，dp[i] [j] 表示的是第一个数组的1-i转变成1-j需要的最小的操作次数(即最小的编辑距离)。</p><h3 id="base-case"><a href="#base-case" class="headerlink" title="base case"></a>base case</h3><p>该题的启动点是0-i和0-j对于第一个数组转换成第二个数组的次数是明确的。</p><h3 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h3><p>1.注意是从已有值转移过来的，所以设计状态方程时候需要考虑base case。</p><p>2.一般涉及字符串转换的题都有一个思路是根据双指针指到的字符相等与否来进行状态转移考虑，再结合dp数组的含义即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 10010 ;int f[N][N] ;char p[N] ,q[N] ;int main()&#123;        int n , m  ;     scanf("%d%s",&n , p+1) ;    //这有一个小技巧，当涉及字符串的读入的时候，尽量使用%s，防止空格的读入    scanf("%d%s",&m , q+1) ;        //base case        for(int i = 1 ; i <= n ;++i)    &#123;        f[i][0] = i ;     &#125;    for(int j = 1 ; j <= m ;++j)    &#123;        f[0][j] = j ;    &#125;        //状态转移        for(int i = 1 ; i <= n ;++i)    &#123;        for(int j = 1 ; j <= m ;++j)        &#123;            f[i][j] = min(f[i-1][j] , f[i][j-1]) ; //之前我一直在想这一步的必要性，后来其实是如果不写的话，后面的转移就直接没有值            if(p[i] == q[j])            &#123;                f[i][j] = min(f[i][j] , f[i-1][j-1]) ;            &#125;            else            &#123;                f[i][j] = min(f[i][j] , f[i-1][j-1] + 1) ;            &#125;        &#125;    &#125;        cout << f[n][m] << endl ;       return 0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 一日一题 线性dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算</title>
      <link href="/2021/09/27/wei-yun-suan/"/>
      <url>/2021/09/27/wei-yun-suan/</url>
      
        <content type="html"><![CDATA[<h1 id="85-不用加减乘除做加法"><a href="#85-不用加减乘除做加法" class="headerlink" title="85.不用加减乘除做加法"></a>85.不用加减乘除做加法</h1><hr><p>写一个函数，求两个整数之和，要求在函数体内不得使用 ＋、－、×、÷＋、－、×、÷ 四则运算符号。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><pre><code>输入：num1 = 1 , num2 = 2输出：3</code></pre><hr><p>对于对二进制数进行位运算来说，将其异或就是进行无进位的运算，得出的用于进位的数字可以用两数进行相与操作得到，乘以进制即可。</p><p>代码如下：</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    int add(int num1, int num2)&#123;        while(num2)        &#123;          int m = num1^num2 ;         unsigned int n = ((unsigned int)num1&num2 ) << 1;         num1 = m ;         num2 = n ;     &#125;      return num1 ;     &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存限制比较严格的一题(怪)</title>
      <link href="/2021/09/23/nei-cun-xian-zhi-bi-jiao-yan-ge-de-yi-ti-guai/"/>
      <url>/2021/09/23/nei-cun-xian-zhi-bi-jiao-yan-ge-de-yi-ti-guai/</url>
      
        <content type="html"><![CDATA[<hr><p>地图上有 N 个目标，用整数 Xi,Yi 表示目标在地图上的位置，每个目标都有一个价值 Wi。</p><p><strong>注意</strong>：不同目标可能在同一位置。</p><p>现在有一种新型的激光炸弹，可以摧毁一个包含 R×R 个位置的正方形内的所有目标。</p><p>激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个正方形的边必须和 x，y 轴平行。</p><p>求一颗炸弹最多能炸掉地图上总价值为多少的目标。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入正整数 N 和 R，分别代表地图上的目标数目和正方形的边长，数据用空格隔开。</p><p>接下来 N 行，每行输入一组数据，每组数据包括三个整数 Xi,Yi,Wi，分别代表目标的 x 坐标，y 坐标和价值，数据用空格隔开。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>0≤R≤109<br>0&lt;N≤10000<br>0≤Xi,Yi≤5000<br>0≤Wi≤1000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>2 10 0 11 1 1</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>1</code></pre><hr><p>这就比较显然是一道二维前缀和的题目，具体思路还是比较简单的.</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 5050 ;int s[N][N] ;int main()&#123;    int n , R ;    cin >> n >> R ;    R = min(R , 5010) ;     int x = R, y = R ;        for(int i = 0 ; i < n ;++i)    &#123;        int a, b ,w ;        cin >>a >>b >>w ;                s[a+1][b+1] += w ;                x = max(x , a+1) ; y = max(y , b+1) ;     &#125;        for(int i = 1 ; i <= x; ++i)    &#123;        for(int j = 1 ; j <= y ;++j)        &#123;            s[i][j] = s[i][j] + s[i-1][j] + s[i][j-1] -s[i-1][j-1] ;        &#125;    &#125;        int res= 0 ;     for(int i = R ; i <= x ; ++i)        for(int j = R ; j <= y ;++j)        &#123;            res = max(res , (s[i][j] + s[i-R][j-R] - s[i-R][j] - s[i][j-R])) ;        &#125;        cout << res <<endl  ;    return 0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(奇怪哦~~~，同样的代码今天交就AC了，昨天明明就不可以的…….)</p>]]></content>
      
      
      
        <tags>
            
            <tag> acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>头痛的二分查找</title>
      <link href="/2021/09/19/tou-tong-de-er-fen-cha-zhao/"/>
      <url>/2021/09/19/tou-tong-de-er-fen-cha-zhao/</url>
      
        <content type="html"><![CDATA[<h1 id="二分手册-持续总结更新"><a href="#二分手册-持续总结更新" class="headerlink" title="二分手册(持续总结更新)"></a>二分手册(持续总结更新)</h1><p>经过长时间的保守二分法调试的折磨(主要是边界条件的一些细节).</p><p>经常看着别人的代码与自己的代码明明是一样的，但是别人的直接AC,我的要么TLE，要么CE，要么SF……..</p><p>所以，经过长时间的血泪教训与总结，我开始渐渐摸清楚二分的方法了吧(Maybe?)</p><h2 id="对于常用的二分模板来说"><a href="#对于常用的二分模板来说" class="headerlink" title="对于常用的二分模板来说"></a>对于常用的二分模板来说</h2><h3 id="最应该考虑二分的目的与意义"><a href="#最应该考虑二分的目的与意义" class="headerlink" title="最应该考虑二分的目的与意义"></a>最应该考虑二分的目的与意义</h3><p>二分：翻译成通俗易懂的语言来说，就是找到第一个满足XX条件的数据(前提是在一个有序的数组中)</p><p>主要有两种，一种是a[mid] &gt;= target型的，一种是a[mid] &lt;= target型的。</p><p>两种不同的表达方式对应着不同的left与right的部署。</p><pre class="line-numbers language-c++"><code class="language-c++">while(left < right)&#123;    int mid = left + right >> 1 ;     if(a[mid] >= target)    &#123;        right = mid ;     &#125;    else    &#123;        left = mid + 1 ;     &#125;&#125;//中文就是大于等于target的第一个数字<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">while(left < right)&#123;    int mid = left + right + 1>> 1 ;     if(a[mid] > target)    &#123;        right = mid-1 ;     &#125;    else    &#123;        left = mid  ;    &#125;&#125;//找到的是小于等于target的第一个数字 (只要是right = mid -1 ，要在mid的来源+1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="举一些例子："><a href="#举一些例子：" class="headerlink" title="举一些例子："></a>举一些例子：</h3><h2 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h2><hr><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p><p>输入一个升序的数组的一个旋转，输出旋转数组的最小元素。</p><p>例如数组 {3,4,5,1,2}为 {1,2,3,4,5}的一个旋转，该数组的最小值为 1。</p><p>数组可能包含重复项。</p><p><strong>注意</strong>：数组内所含元素非负，若数组大小为 0，请返回 −1。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><pre><code>输入：nums = [2, 2, 2, 0, 1]输出：0</code></pre><hr><p>这一题是比较经典的利用二分来做的，找最小值的模板题目。</p><p>其实如果是比赛做到了，那其实直接sort一下，return nums[0] 好像就可以了……..(好吧，某种程度上说他显然是一道弱智题…….)</p><p>但是！！！但是！！！但是！！！</p><p>这道题可以锻炼一下我们的二分的熟练度，好吧，现在就用二分来分析一下这道题目，就用刚刚的二分模板。</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    int findMin(vector<int>& nums) &#123;        int n = nums.size() ;         if(n == 0) return  -1 ;                 nums.erase(unique(nums.begin() , nums.end()) , nums.end()) ;                n = nums.size() ;                 int left = 0  ; int right = n-1 ; //左闭右开                if(nums[right] > nums[0]) return nums[0] ;                 while(left < right)        &#123;            int mid = left + right >> 1 ;                         if(nums[mid] >= nums[0])            &#123;                left = mid + 1 ;             &#125;            else            &#123;                right = mid ;             &#125;        &#125;        return nums[left] ;     &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>回顾一下代码：</p><p>写二分，重要的一下几点：</p><p>一、找到target，即你的对比值是什么。比如这一题他的对比值就是nums[0]。</p><p>二、找到你想要的值与target之间的关系，无非就是几种：</p><p>第一个小于等于target的数、第一个大于等于target的数，或者是把小于等于什么的改成小于而已…….</p><p>三、找对应的模板，背模板的时候注意几点即可。</p><p>我个人习惯是一般采用左闭右开的方式，来初始化的left和right。</p><p>然后找target与关系，找到之后呢，比如这一题，我要找的是小于nums[0]的第一个数字，那我就考虑left最终应该指向&gt;=nums[0]的最后一个元素的位置再加一。</p><p>一般来说，我们最终的破除循环的条件为</p><pre class="line-numbers language-c++"><code class="language-c++">while(left < right)&#123;    ...........&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>所以最终状态其实是left == right的，那我们就可以反向进行考虑，最后一步变化的那必然是xxx = mid + 1/mid -1什么的，另外一个值其实再倒数几步的时候是不会变化的，已经锁定住我们要的值了，剩下的其实可以理解为等另外一个变量靠过来，然后破圈即可。所以我们主要考虑的对象其实是xxx = mid ; 的部分。如果是right = mid -1 ;什么的，要注意再确定mid的时候，就需要</p><pre class="line-numbers language-c++"><code class="language-c++">mid = left + right + 1>> 1 ; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要不然，血泪教训是</p><p>TLE……….死循环……</p><p>好的，之后如果有更加经典的例子，我再次会更新。</p><p>—————————————-ok 今天是-10-10更新————————————————————————</p><p>又发现了一个比较经典的例子</p><h2 id="数的范围"><a href="#数的范围" class="headerlink" title="数的范围"></a>数的范围</h2><hr><p>给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。</p><p>对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。</p><p>如果数组中不存在该元素，则返回 <code> -1</code>。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n 和 q，表示数组长度和询问个数。</p><p>第二行包含 n 个整数（均在 1∼10000 范围内），表示完整数组。</p><p>接下来 q 行，每行包含一个整数 k，表示一个询问元素。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 q行，每行包含两个整数，表示所求元素的起始位置和终止位置。</p><p>如果数组中不存在该元素，则返回 <code>-1</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤100000<br>1≤q≤10000<br>1≤k≤10000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>6 31 2 2 3 3 4345</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>3 45 5-1 -1</code></pre><hr><p>ok，main函数的部分应该是相当简单了，主要的难点就是在于，如何返回两个值，满足起始与终点的要求。</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 100010  ; int a[N] ; int n , m ;int findlow(int *a , int num)&#123;    int left = 0 ;    int right = n ;     while(left < right)    &#123;        int mid = left + right >> 1 ;         if(a[mid] >= num)        &#123;            right = mid ;         &#125;        else        &#123;            left = mid + 1 ;         &#125;    &#125;    return left ; &#125;int findhigh(int *a , int num)&#123;    int left = 0 ;    int right = n ;     while(left < right)    &#123;        int mid = left + right >> 1 ;         if(a[mid] > num)        &#123;            right = mid ;         &#125;        else        &#123;            left = mid + 1 ;         &#125;    &#125;    return left - 1; &#125;int main()&#123;    cin >> n >> m ;         for(int i = 0 ; i < n ;++i)    &#123;        cin >> a[i] ;     &#125;    for(int i = 0 ; i < m ; ++ i)    &#123;        int b ;         cin >> b ;         int low = findlow(a , b) ;         int high = findhigh(a , b) ;         if(low > high)            low = high = -1 ;         cout << low << " " << high << endl ;     &#125;    return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运用之前的二分查找法的模板来说，</p><p>我们已经知道该题的target，就是目标值了。现在关系也明确了，就是查找&gt;=target的第一个数字和&lt;=target的最后一个数字。</p><p>我们知道二分查找模板的宗旨是返回第一个满足的值。那大于等于target的第一个值非常好找，小于等于target的最后一个值应该怎么找呢？</p><p>换个思路，那就是找&gt;target的第一个值的位置再减去一咯！！！！！</p><pre class="line-numbers language-c++"><code class="language-c++">int findlow(int *a , int num)&#123;    int left = 0 ;  int right = n ;     while(left < right)    &#123;        int mid = left + right >> 1 ;         if(a[mid] >= num)        &#123;            right = mid  ;        &#125;        else        &#123;            left = mid + 1 ;         &#125;    &#125;    return left ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">int findhigh(int *a , int num)&#123;    int left = 0 ; int right = n ;     while(left < right)    &#123;        int mid = left + right >> 1 ;         if(a[mid] > num)        &#123;            right = mid ;         &#125;        else        &#123;            left = mid + 1  ;        &#125;    &#125;    return left - 1 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性DP专题</title>
      <link href="/2021/09/18/xian-xing-dp-zhuan-ti/"/>
      <url>/2021/09/18/xian-xing-dp-zhuan-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="1-最长公共子序列"><a href="#1-最长公共子序列" class="headerlink" title="1.最长公共子序列"></a>1.最长公共子序列</h1><hr><p>给定两个长度分别为 N和M 的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 N 和 M。</p><p>第二行包含一个长度为 N 的字符串，表示字符串 A。</p><p>第三行包含一个长度为 M 的字符串，表示字符串 B。</p><p>字符串均由小写字母构成。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大长度。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N,M≤1000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>4 5acbdabedc</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>3</code></pre><hr><p>一、可以用二维dp，dp[i] [j] 表示在第一个序列的第i位到第二个序列的j位的最长公共子串的长度。</p><p>二、二维数组要想给每一个赋值，即需要从底往上遍历。</p><p>三、讲遇到的情况分成两大类，一类是相等，一类是不等。</p><p>即状态转移方程我为</p><pre><code>if(a[i] == b[j])dp[i][j] = dp[i-1][j-1] + 1 ;else if(a[i] != b[j])dp[i][j] = max(dp[i-1][j] , dp[i][j-1]) ;</code></pre><p>具体代码如下:</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 1010 ;int f[N][N] ;char a[N], b[N] ;int main()&#123;    int n , m ;     cin >>n >> m  ;    for(int i = 1 ; i <= n ;++i)        cin >> a[i] ;     for(int j = 1 ; j <= m ;++j)        cin >> b[j] ;            for(int i = 1 ; i <= n ; ++i)    &#123;        for(int j = 1 ; j <= m ; ++j)        &#123;            if(a[i] == b[j])            &#123;                f[i][j] = f[i-1][j-1] +1 ;            &#125;            else            &#123;                f[i][j] = max(f[i-1][j] , f[i][j-1]) ;            &#125;        &#125;            &#125;            cout << f[n][m] <<endl ;            return  0  ;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二、最长上升子序列"><a href="#二、最长上升子序列" class="headerlink" title="二、最长上升子序列"></a>二、最长上升子序列</h1><p>给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 N。</p><p>第二行包含 N 个整数，表示完整序列。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大长度。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤1000<br>−109≤数列中的数≤109</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>73 1 2 1 8 5 6</code></pre><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>4</code></pre><p>数据范围给的比较大，所以直接暴力dp就可以了。</p><p>一、创建一个一维的dp数组，dp[i]表示的是从1到i的字串中， 以q[i]所结尾的子序列的最长子序列的长度.</p><p>二、dp思路，搜索数组中目标值前面的值，找到严格比target小的index， 将本target接在后面即可。然后一直比较，将最大的值赋给dp即可。</p><p>三、最终的结果不一定是最后的dp结果，而是过程中出现最大的值，因此需要在每一个小循环结束的时候，设置一个res，专门用来记录出现的最大的dp值。</p><p>代码如下：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 1010 ;int w[N] ;int f[N] ; int main()&#123;    int n ;     cin >>n ;            int res =0  ;    for(int i = 1 ; i <= n ;++i)    &#123;        cin >> w[i] ;    &#125;    for(int i = 1 ; i <= n ;++i)    &#123;        f[i] = 1 ;        for(int j = 1 ; j <= i ;++j)        &#123;            if(w[i] > w[j]) f[i] = max(f[i] , f[j] +1) ;        &#125;        res = max(res , f[i]) ;    &#125;        cout << res <<endl ;    return  0  ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、最长上升子序列II"><a href="#三、最长上升子序列II" class="headerlink" title="三、最长上升子序列II"></a>三、最长上升子序列II</h1><p>题目同二，但是数据范围从1000改到了1e5。</p><p>所以，直接把暴力给毙了.</p><p>我们想到最多可以用nlogn来优化，于是可以用二分来优化.</p><p>dp是用不了了，可以用贪心加二分。</p><p>具体思路：</p><p>一、对于原数组中的值，依次在二分数组中找到小于他的最大值，二分数组的作用是一边存储，一边用于搜索。</p><p>二、最后返回q数组的长度即可。</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 100010 ;int w[N] ;int q[N] ;int main()&#123;    int n ;     cin >> n ;    q[0] = -2e9 ;         for(int i = 1 ; i <=  n ;++i)    &#123;        cin >> w[i] ;    &#125;        int len = 0  ;    for(int i = 1 ; i <= n ;++i)    &#123;        int left = 0 ; int right = len ;        while(left < right)        &#123;            int mid = (left + right +1) >> 1 ;            if(q[mid] < w[i])            &#123;                left = mid  ;             &#125;            else             &#123;                right = mid - 1  ;             &#125;        &#125;        q[right+1] = w[i] ;        len = max(len , right+1) ;    &#125;    cout << len <<endl ;    return  0  ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2021/09/15/bing-cha-ji/"/>
      <url>/2021/09/15/bing-cha-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="1-目的"><a href="#1-目的" class="headerlink" title="1.目的"></a>1.目的</h2><h3 id="一、合并两个集合"><a href="#一、合并两个集合" class="headerlink" title="一、合并两个集合"></a>一、合并两个集合</h3><p>即将其中的一个集合作为另外一个集合的son。</p><h3 id="二、判断两个元素是否在同一个集合里面"><a href="#二、判断两个元素是否在同一个集合里面" class="headerlink" title="二、判断两个元素是否在同一个集合里面"></a>二、判断两个元素是否在同一个集合里面</h3><p>集合的表示方式是用树来表示(不一定是二叉树)， 每个节点存储的是当前的节点的父亲节点，根节点存储的是该集合的编号。即只需要两个元素(树的节点)一直溯源，查找到根节点对应的编号。若编号相同，则在同一个集合里面。</p><h2 id="2-优化"><a href="#2-优化" class="headerlink" title="2.优化"></a>2.优化</h2><p>优化的环节主要在于查找根节点的步骤。</p><p>朴素的做法是，假设p[x]是x节点的上一个节点.</p><pre class="line-numbers language-c++"><code class="language-c++">while(p[x] == x) x = p[x] ; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样会导致时间复杂度较高。</p><p>优化方式：路径压缩。即从一个节点查找根节点之后，将途中的所有的节点的p[x]都指向根节点。这样一旦在需要重复寻根的时候，可以大大节省时间。</p><h2 id="3-模板题"><a href="#3-模板题" class="headerlink" title="3.模板题"></a>3.模板题</h2><h3 id="一、合并集合"><a href="#一、合并集合" class="headerlink" title="一、合并集合"></a>一、合并集合</h3><p>一共有 n 个数，编号是 1∼n，最开始每个数各自在一个集合中。</p><p>现在要进行 m 个操作，操作共有两种：</p><ol><li><code>M a b</code>，将编号为 a和 b 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；</li><li><code>Q a b</code>，询问编号为 a和b 的两个数是否在同一个集合中；</li></ol><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入整数 n 和 m。</p><p>接下来 m 行，每行包含一个操作指令，指令为 <code>M a b</code> 或 <code>Q a b</code> 中的一种。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个询问指令 <code>Q a b</code>，都要输出一个结果，如果 a和 b 在同一集合内，则输出 <code>Yes</code>，否则输出 <code>No</code>。</p><p>每个结果占一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n,m≤105</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>4 5M 1 2M 3 4Q 1 2Q 1 3Q 3 4</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>YesNoYes</code></pre><pre class="line-numbers language-c++"><code class="language-c++">#include<bits/stdc++.h>using namespace std ;const int N = 100010 ;int p[N] ;int find(int num)&#123;   //这一步是比较妙的，既找到了num的祖宗节点，而且还实现了路径压缩，每一个节点的父节点都是根节点了    if(p[num] != num)    &#123;        p[num] = find(p[num]) ;    &#125;    return p[num] ;&#125;int main()&#123;    int n ,m ;    cin>>n>>m ;    for(int i = 1 ;i <= n ;++i)        p[i] = i ;  //相当于初始化，将每一个元素存放到对应的集合中        for(int i = 0 ; i < m ;++i)&#123;        char op ;        cin>> op ;        int a , b ;        cin>> a >> b ;        if(op == 'M')        &#123;            p[find(a)] = find(b) ;        &#125;        else        &#123;            if(find(a) == find(b))                cout<<"Yes"<<endl ;            else                cout<<"No"<<endl ;        &#125;            &#125;return  0 ;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二、连通块中点的数量"><a href="#二、连通块中点的数量" class="headerlink" title="二、连通块中点的数量"></a>二、连通块中点的数量</h3><p>给定一个包含 n个点（编号为 1∼n1∼n）的无向图，初始时图中没有边。</p><p>现在要进行 m 个操作，操作共有三种：</p><ol><li><code>C a b</code>，在点 a 和点b 之间连一条边，aa 和 bb 可能相等；</li><li><code>Q1 a b</code>，询问点 a 和点b 是否在同一个连通块中，a 和 b 可能相等；</li><li><code>Q2 a</code>，询问点 a 所在连通块中点的数量；</li></ol><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入整数 n 和 m。</p><p>接下来 m 行，每行包含一个操作指令，指令为 <code>C a b</code>，<code>Q1 a b</code> 或 <code>Q2 a</code> 中的一种。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个询问指令 <code>Q1 a b</code>，如果 a 和 b 在同一个连通块中，则输出 <code>Yes</code>，否则输出 <code>No</code>。</p><p>对于每个询问指令 <code>Q2 a</code>，输出一个整数表示点 a 所在连通块中点的数量</p><p>每个结果占一行。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n,m≤105</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>5 5C 1 2Q1 1 2Q2 1C 2 5Q2 5</code></pre><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>Yes23</code></pre><pre class="line-numbers language-c++"><code class="language-c++">#include<bits/stdc++.h>using namespace std ;const int N = 100010 ;int n  , m ;int father[N] ;int find(int num)&#123;    if(father[num] != num)         father[num] = find(father[num]) ;    return father[num] ;&#125;int main()&#123;    cin>>n>>m ;    int size[N]  ;    for(int i = 1 ; i <= n ;++i )    &#123;        father[i] = i ;            size[i] = 1 ;    &#125;        string op;    int a, b ;    for(int i = 0 ; i < m ; ++i )    &#123;        cin>>op ;        if(op == "C")        &#123;            cin>>a>>b ;            int x = find(a) ; int y = find(b) ;            if(x != y)            &#123;                father[x] = y ;                size[y] += size[x] ;            &#125;        &#125;        else if(op == "Q1")        &#123;            cin>>a>>b ;            (find(a) == find(b)) ? puts("Yes") : puts("No") ;        &#125;        else if(op == "Q2")        &#123;            cin>>a ;            cout<<size[find(a)]<<endl ;        &#125;      &#125;    return 0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、食物链"><a href="#三、食物链" class="headerlink" title="三、食物链"></a>三、食物链</h3><p>动物王国中有三类动物 A,B,CA,B,C，这三类动物的食物链构成了有趣的环形。</p><p>A 吃 B，B 吃 C，C 吃A。</p><p>现有 N 个动物，以 1∼N 编号。</p><p>每个动物都是 A,B,C 中的一种，但是我们并不知道它到底是哪一种。</p><p>有人用两种说法对这 N 个动物所构成的食物链关系进行描述：</p><p>第一种说法是 <code>1 X Y</code>，表示 X 和 Y 是同类。</p><p>第二种说法是 <code>2 X Y</code>，表示 X 吃 Y。</p><p>此人对 N 个动物，用上述两种说法，一句接一句地说出 K 句话，这 K 句话有的是真的，有的是假的。</p><p>当一句话满足下列三条之一时，这句话就是假话，否则就是真话。</p><ol><li>当前的话与前面的某些真的话冲突，就是假话；</li><li>当前的话中 X 或 Y 比 N 大，就是假话；</li><li>当前的话表示 X吃 X，就是假话。</li></ol><p>你的任务是根据给定的 N 和 K 句话，输出假话的总数。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行是两个整数 NN 和 KK，以一个空格分隔。</p><p>以下 KK 行每行是三个正整数 D，X，YD，X，Y，两数之间用一个空格隔开，其中 DD 表示说法的种类。</p><p>若 D=1，则表示 X 和 Y 是同类。</p><p>若 D=2，则表示 X 吃 Y。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>只有一个整数，表示假话的数目。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤50000<br>0≤K≤100000</p><h4 id="输入样例：-2"><a href="#输入样例：-2" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>100 71 101 1 2 1 22 2 3 2 3 3 1 1 3 2 3 1 1 5 5</code></pre><h4 id="输出样例：-2"><a href="#输出样例：-2" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>3</code></pre><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 100010 ;int n , m ;int p[N] ; int dis[N] ;int find(int num)&#123;     if(p[num] != num)    &#123;         int t = find(p[num]) ;       dis[num]  += dis[p[num]] ;       p[num] = t;    &#125;    return p[num] ;&#125;int main()&#123;     cin >> n >> m ;        int res = 0 ;    for(int i = 1 ;i <= n ;++i)       p[i] = i  ;       while(m--)    &#123;         int op , a ,b ;                cin>> op >>a >>b ;            if(a > n || b> n ) res++ ;        else        &#123;             int pa = find(a) ; int pb = find(b) ;            if(op == 1)            &#123;                 if(pa == pb && (dis[a] - dis[b]) %3 )                 &#123;                     res++ ;                &#125;                else if(pa != pb)                &#123;                     p[pa] = pb ;                      dis[pa] = dis[b] - dis[a] ;                &#125;            &#125;            else            &#123;                 if(pa == pb && (dis[a] - dis[b] -1) %3 )                   res++ ;                else if(pa != pb)                &#123;                     p[pa] = pb ;                    dis[pa] = dis[b]+1-dis[a] ;                                 &#125;             &#125;        &#125;     &#125;    cout<<res<<endl ;    return 0  ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串哈希的理解</title>
      <link href="/2021/09/15/zi-fu-chuan-ha-xi-de-li-jie/"/>
      <url>/2021/09/15/zi-fu-chuan-ha-xi-de-li-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h2><hr><p>给定一个长度为 n 的字符串，再给定 m个询问，每个询问包含四个整数 l1,r1,l2,r2请你判断 [l1,r1][l1,r1] 和 [l2,r2][l2,r2] 这两个区间所包含的字符串子串是否完全相同。</p><p>字符串中只包含大小写英文字母和数字。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n 和 m，表示字符串长度和询问次数。</p><p>第二行包含一个长度为 n 的字符串，字符串中只包含大小写英文字母和数字。</p><p>接下来 m 行，每行包含四个整数 l1,r1,l2,r2表示一次询问所涉及的两个区间。</p><p>注意，字符串的位置从 1 开始编号。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个询问输出一个结果，如果两个字符串子串完全相同则输出 <code>Yes</code>，否则输出 <code>No</code>。</p><p>每个结果占一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n,m≤105</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>8 3aabbaabb1 3 5 71 3 6 81 2 1 2</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>YesNoYes</code></pre><hr><pre class="line-numbers language-c++"><code class="language-c++">#include<bits/stdc++.h>using namespace std ;typedef unsigned long long ULL ;const int N  = 1e5+10 , P = 131; //P一般采用131，或者是13331。根据经验判断，这样的将字符串映射成为数值的时候，99%的情况下是不hULL h[N] , p[N] ;//h数组其实就是可以看作是存储前缀和的数组//p其实就是记录当前的进制的数组，当前的位数的价值可以这么理解ULL ToPnumber(int l , int r)&#123;    return h[r]-h[l-1]*p[r-l+1] ;  &#125;/*这个思想就比较妙了，想要算出有固定起始区间的一段字符串的P进制数，其实可以拿少的数扩展来进行相减。举个例子，比如一段数组453672，我想要计算出来3~5区间的数值即367.我可以用45367-45*10的(5-3+1)次方。同样的道理，想要算出l~r的区间代表的P进制的数字，目前有已知h[r]和h[l].直接return h[r]-h[l-1]*(r-l+1) ;*/int main()&#123;    int n , m ;    cin>>n>>m ;    string x ;    cin>>x ;    h[0] = 0 ; p[0] = 1 ;        for(int i = 0 ;i < n ;++i)    &#123;        p[i+1] = p[i]*P  ;        h[i+1] = h[i]*P + x[i] ; //这就是算前缀和的操作    &#125;        for(int i = 0 ; i < m ;++i)    &#123;        int l1 , l2 , l3 ,l4 ;        cin>>l1>>l2>>l3>>l4 ;        if(ToPnumber(l1,l2) == ToPnumber(l3,l4))            cout<<"Yes"<< endl ;        else             cout<<"No"<< endl ;    &#125;        return  0 ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL的用法总结-摘自acwing</title>
      <link href="/2021/09/15/stl-de-yong-fa-zong-jie-zhai-zi-acwing/"/>
      <url>/2021/09/15/stl-de-yong-fa-zong-jie-zhai-zi-acwing/</url>
      
        <content type="html"><![CDATA[<p>vector（变长数组），倍增的思想，支持比较运算（按字典序）<br>    定义：：<br>        vector <int> a; 定义：一个vector数组a<br>        vector <int> a(10); 定义：一个长度为10的vector数组a<br>        vector <int> a(10,3); 定义：一个长度为10的vector数组a，并且所有元素都为3<br>    常用函数：：<br>        size(); 返回元素个数<br>        empty(); 返回是否是空<br>        clear(); 清空<br>        front(); 返回vector的第一个数<br>        back(); 返回vector的最后一个数<br>        push_back(); 向vector的最后插入一个数<br>        pop_back(); 把vector的最后一个数删掉<br>        begin(); vector的第0个数<br>        end(); vector的最后一个的数的后面一个数<br>    倍增的思想：<br>        系统为某一程序分配空间是，所需时间，与空间大小无关，与申请次数有关<br>    遍历方法<br>        假设有个vector <int> a;<br>        第一种：<br>            for(int i = 0;i &lt; a.size();i ++) cout&lt;&lt;a[i]&lt;&lt;” “;<br>        第二种：<br>            for(vector <int>::iterator i = a.begin();i != a.end();i ++) cout&lt;&lt;*i&lt;&lt;” “;  vector <int>::iterator可以写为auto<br>        第三种：<br>            for(auto  x : a) cout&lt;&lt;x&lt;&lt;” “;</p><p>pair，支持比较运算，以first为第一关键字，以second为第二关键字（按字典序）<br>    定义：：<br>        pair &lt;类型,类型&gt; 变量名;    两个类型可以不同<br>    初始化方式：<br>        假设有个pair &lt;int,string&gt; p;<br>        第一种：<br>            p = make_pair(10,”abc”);<br>        第二种：<br>            p = {10,”abc”);<br>    常用函数：：<br>        first(); 第一个元素<br>        second(); 第二个元素</p><p>string（字符串）<br>    常用函数：：<br>        substr(); 返回每一个子串<br>        c_str(); 返回这个string对应的字符数组的头指针<br>        size(); 返回字母个数<br>        length(); 返回字母个数<br>        empty(); 返回字符串是否为空<br>        clear(); 把字符串清空<br>queue（队列）<br>    定义：：<br>        queue &lt;类型&gt; 变量名;<br>    常用函数：：<br>        size(); 这个队列的长度<br>        empty(); 返回这个队列是否为空<br>        push(); 往队尾插入一个元素<br>        front(); 返回队头元素<br>        back(); 返回队尾元素<br>        pop(); 把队头弹出<br>        注意：队列没有clear函数！！！<br>    清空：<br>        变量名 = queue <int> ();<br>priority_queue（优先队列，堆）<br>    注意：默认是大根堆！！！<br>    定义：：<br>        大根堆：priority_queue &lt;类型&gt; 变量名;<br>        小根堆：priority_queue &lt;类型,vecotr &lt;类型&gt;,greater &lt;类型&gt;&gt; 变量名<br>    常用函数：<br>        size(); 这个堆的长度<br>        empty(); 返回这个堆是否为空<br>        push();往堆里插入一个元素<br>        top(); 返回堆顶元素<br>        pop(); 弹出堆顶元素<br>        注意：堆没有clear函数！！！</p><p>stack（栈）<br>    常用函数：<br>        size(); 这个栈的长度<br>        empty(); 返回这个栈是否为空<br>        push(); 向栈顶插入一个元素<br>        top(); 返回栈顶元素<br>        pop(); 弹出栈顶元素</p><p>deque（双端队列）<br>    常用函数：<br>        size(); 这个双端队列的长度<br>        empty(); 返回这个双端队列是否为空<br>        clear(); 清空这个双端队列<br>        front(); 返回第一个元素<br>        back(); 返回最后一个元素<br>        push_back(); 向最后插入一个元素<br>        pop_back(); 弹出最后一个元素<br>        push_front(); 向队首插入一个元素<br>        pop_front(); 弹出第一个元素<br>        begin(); 双端队列的第0个数<br>        end(); 双端队列的最后一个的数的后面一个数</p><p>set，map，multiset，multimap 基于平衡二叉树（红黑树），动态维护有序序列<br>    set/multiset<br>        注意：set不允许元素重复，如果有重复就会被忽略，但multiset允许！！！<br>        常用函数：<br>            size(); 返回元素个数<br>            empty(); 返回set是否是空的<br>            clear(); 清空<br>            begin(); 第0个数，支持++或–，返回前驱和后继<br>            end(); 最后一个的数的后面一个数，支持++或–，返回前驱和后继<br>            insert(); 插入一个数<br>            find(); 查找一个数<br>            count(); 返回某一个数的个数<br>            erase();<br>                （1）输入是一个数x，删除所有x    O(k + log n)<br>                （2）输入一个迭代器，删除这个迭代器<br>            lower_bound(x); 返回大于等于x的最小的数的迭代器<br>            upper_bound(x); 返回大于x的最小的数的迭代器<br>    map/multimap<br>        常用函数：<br>            insert(); 插入一个数，插入的数是一个pair<br>            erase();<br>                （1）输入是pair<br>                （2）输入一个迭代器，删除这个迭代器<br>            find(); 查找一个数<br>            lower_bound(x); 返回大于等于x的最小的数的迭代器<br>            upper_bound(x); 返回大于x的最小的数的迭代器</p><p>unordered_set，unordered_map，unordered_muliset,unordered_multimap 基于哈希表<br>    和上面类似，增删改查的时间复杂度是O(1)<br>    不支持lower_bound()和upper_bound()</p><p>bitset 压位<br>    定义：<br>        bitset &lt;个数&gt; 变量名;<br>    支持：<br>        <del>，&amp;，|，^<br>        &gt;&gt;，&lt;&lt;<br>        ==，!=<br>        []<br>    常用函数：<br>        count(); 返回某一个数的个数<br>        any(); 判断是否至少有一个1<br>        none(); 判断是否全为0<br>        set(); 把所有位置赋值为1<br>        set(k,v); 将第k位变成v<br>        reset(); 把所有位变成0<br>        flip(); 把所有位取反，等价于</del><br>        flip(k); 把第k位取反</p><p>作者：yxc<br>链接：<a href="https://www.acwing.com/video/20/">https://www.acwing.com/video/20/</a><br>来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      
        <tags>
            
            <tag> acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据范围的判断-摘自acwing</title>
      <link href="/2021/09/12/shu-ju-fan-wei-de-pan-duan-zhai-zi-acwing/"/>
      <url>/2021/09/12/shu-ju-fan-wei-de-pan-duan-zhai-zi-acwing/</url>
      
        <content type="html"><![CDATA[<p>一般ACM或者笔试题的时间限制是1秒或2秒。<br>在这种情况下，C++代码中的操作次数控制在 10的七次方到10的八次方为最佳。</p><p>下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：</p><p>n≤30, 指数级别, dfs+剪枝，状态压缩dp<br>n≤100 =&gt; O(n3)，floyd，dp，高斯消元<br>n≤1000=&gt; O(n2)，O(n2logn)，dp，二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford<br>n≤10000 =&gt; O(n∗√n)，块状链表、分块、莫队<br>n≤100000=&gt; O(nlogn) =&gt; 各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分<br>n≤1000000=&gt; O(n), 以及常数较小的 O(nlogn) 算法 =&gt; 单调队列、 hash、双指针扫描、并查集，kmp、AC自动机，常数比较小的 O(nlogn)的做法：sort、树状数组、heap、dijkstra、spfa<br>n≤10000000=&gt; O(n)，双指针扫描、kmp、AC自动机、线性筛素数<br>n≤10的9次方 =&gt; O(√n)，判断质数<br>n≤10的18次方 =&gt; O(logn)，最大公约数，快速幂<br>n≤10的1000次方=&gt; O((logn)2)，高精度加减乘除<br>n≤10的1000000次方 =&gt; O(logk×loglogk)，k表示位数，高精度加减、FFT/NTT</p><p>作者：yxc<br>链接：<a href="https://www.acwing.com/blog/content/32/">https://www.acwing.com/blog/content/32/</a><br>来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      
        <tags>
            
            <tag> acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题思考</title>
      <link href="/2021/09/09/bei-bao-wen-ti-si-kao/"/>
      <url>/2021/09/09/bei-bao-wen-ti-si-kao/</url>
      
        <content type="html"><![CDATA[<h2 id="背包问题分类："><a href="#背包问题分类：" class="headerlink" title="背包问题分类："></a>背包问题分类：</h2><h3 id="1-01背包问题"><a href="#1-01背包问题" class="headerlink" title="1.01背包问题"></a>1.01背包问题</h3><hr><p>有 NN 件物品和一个容量是 VV 的背包。每件物品只能使用一次。</p><p>第 ii 件物品的体积是 vivi，价值是 wiwi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 NN 行，每行两个整数 vi,wivi,wi，用空格隔开，分别表示第 ii 件物品的体积和价值。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N,V≤10000&lt;N,V≤1000<br>0&lt;vi,wi≤10000&lt;vi,wi≤1000</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><pre><code>4 51 22 43 44 5</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>8</code></pre><hr><pre class="line-numbers language-c++"><code class="language-c++">//朴素算法#include<bits/stdc++.h>using namespace std ;const int N = 1010 ;int dp[N][N] ;int v[N], w[N] ;int main()&#123;    int m, n ; cin>>m >> n ;    for(int i = 1 ; i<= m ;++i ) cin >> v[i]>>w[i] ;        for(int i = 1 ; i<= m ;++i) &#123;        for(int j = 0 ; j<= n ;++j)&#123;            dp[i][j] = dp[i-1][j] ;            if(j>= v[i]) dp[i][j] = max(dp[i-1][j-v[i]]+w[i]) ;        &#125;    &#125;    cout<< dp[m][n]<<endl ;    return 0 ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">//进行优化#include<bits/stdc++.h>using namespace std ;const int N = 1010 ;int dp[N] ; int v[N] ; int w[N] ;int main()&#123;    int m ,n ;     cin>> m >> n ;    for(int i = 1 ;i<= m; ++i) cin>> v[i]>>w[i] ;    for(int i = 1; i<= m ;++i )        for(int j = n ; j>= v[i] ;--j )            dp[j] = max(dp[j], dp[j-v[i]]+w[i]) ;    cout<<dp[n] <<endl ;    return 0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-完全背包问题"><a href="#2-完全背包问题" class="headerlink" title="2.完全背包问题"></a>2.完全背包问题</h3><p>有 NN 种物品和一个容量是 VV 的背包，每种物品都有无限件可用。</p><p>第 ii 种物品的体积是 vivi，价值是 wiwi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，VN，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 NN 行，每行两个整数 vi,wivi,wi，用空格隔开，分别表示第 ii 种物品的体积和价值。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N,V≤10000&lt;N,V≤1000<br>0&lt;vi,wi≤10000&lt;vi,wi≤1000</p><h4 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a>输入样例</h4><pre><code>4 51 22 43 44 5</code></pre><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>10</code></pre><pre class="line-numbers language-c++"><code class="language-c++">#这种算法最直观，但是会超时间，此题的数据是在1000 ，这有一个三层循环应该是在10的九次方左右，会超时,所以就有了之后的优化算法#include<bits/stdc++.h>using namespace std ;const int N = 1010 ;int f[N][N] ; int v[N] ; int w[N] ;int main()&#123;    int m ,n  ;    cin>>m>>n ;    for(int i = 1 ; i<= m ;++i) cin>> v[i]>>w[i] ;    for(int i = 1 ; i<= m ;++i ) &#123;        for(int j = 0 ; j<= n ;++j)&#123;            f[i][j] = f[i-1][j] ;                        for(int k = 1 ; j-k*v[i] >= 0 ; k++)&#123;                f[i][j]  = max(f[i][j] , f[i-1][j-k*v[i]]+k*w[i]) ;            &#125;        &#125;    &#125;    cout<< f[m][n] <<endl ;    return 0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">//朴素算法#include<bits/stdc++.h>using namespace std ;const int N =  1010 ;int dp[N][N] ; int v[N]; int w[N] ;int main()&#123;    int m , n ;    cin>>m >>n ;    for(int i = 1 ;i<= m ;++i) cin>> v[i]>>w[i] ;    for(int i = 1; i<= m ; ++i)         for(int j = 0 ; j<= n ++j)&#123;            dp[i][j] = dp[i-1][j] ;            if(j >= v[i]) dp[i][j] = max(dp[i][j], dp[i][j-v[i]]+w[i]) ;        &#125;    cout<< dp[m][n] <<endl ;    return 0 ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">//优化算法#include<bits/stdc++.h>using namespace std ;const int N = 1010; int dp[N] ; int v[N] ;int w[N] ; int main()&#123;    int m , n ;    cin>>m >> n ;     for(int i =1 ; i <= m ;++i) cin>>v[i]>>w[i] ;        for(int i = 1; i <= m ;++i)        for(int j = v ; j<= n ;++j)            dp[j] = max(dp[j], dp[j-v[i]]+w[i]) ;        cout>>dp[n] ;    return 0 ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-多重背包问题"><a href="#3-多重背包问题" class="headerlink" title="3.多重背包问题"></a>3.多重背包问题</h2><p>有 NN 种物品和一个容量是 VV 的背包。</p><p>第 ii 种物品最多有 sisi 件，每件体积是 vivi，价值是 wiwi。</p><p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，VN，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 NN 行，每行三个整数 vi,wi,sivi,wi,si，用空格隔开，分别表示第 ii 种物品的体积、价值和数量。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N,V≤1000&lt;N,V≤100<br>0&lt;vi,wi,si≤1000&lt;vi,wi,si≤100</p><h4 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例"></a>输入样例</h4><pre><code>4 51 2 32 4 13 4 34 5 2</code></pre><h4 id="输出样例：-2"><a href="#输出样例：-2" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>10</code></pre><pre class="line-numbers language-c++"><code class="language-c++">#这能ac是我妹想到的，总之这是一个最朴素的做法，我估计数据增强之后就不可以了#include<bits/stdc++.h>using namespace std ;const int N = 1010 ;int f[N][N] ;int v[N] ; int w[N] ;int s[N];int main()&#123;    int m ,n  ;    cin>>m >>n ;    for(int i = 1 ; i<= m ;++i) cin>>v[i]>>w[i]>>s[i] ;        for(int i = 1 ;i<= m ;++i)&#123;        for(int j = 0 ;j<=n ;++j)&#123;            f[i][j] = f[i-1][j] ;            for(int k = 1 ; k<= s[i]&& j-k*v[i]>= 0 ;++k)&#123;                f[i][j] = max(f[i][j], f[i-1][j-k*v[i]]+k*w[i]) ;            &#125;        &#125;    &#125;    cout<<f[m][n]<<endl ;    return 0 ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>妙</title>
      <link href="/2021/09/09/miao/"/>
      <url>/2021/09/09/miao/</url>
      
        <content type="html"><![CDATA[<h2 id="799-最长连续不重复子序列"><a href="#799-最长连续不重复子序列" class="headerlink" title="799.最长连续不重复子序列"></a>799.最长连续不重复子序列</h2><hr><p>给定一个长度为 nn 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 nn。</p><p>第二行包含 nn 个整数（均在 0∼1050∼105 范围内），表示整数序列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤105</p><hr><hr><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>51 2 2 3 5</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>3</code></pre><hr><p>核心思路：</p><p>1.对于重复的理解</p><p>不是单纯的判断==的关系，而是多申请了一个额外的数组，充当一个hash table，把原元素当成key值，记录元素的频率。当频率大于1的时候，就是重复了.</p><p>2.对于间断的时机的理解</p><p>由于推理逻辑是具有连续性的，所以，由于前一个i到j的区间是不重复的，但是之后出现了重复。只有一种可能，那就是最新的p[i]与之前区间里面的数据重复了。即只需要“恰头”，一个循环一直丢头，直到p[i]的频率为1为止。</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;#define read(x) scanf("%d",&x) ;const int N = 100010 ;int main()&#123;    int n ; int r = 0 ;  int p[N] ; int s[N] = &#123;0&#125; ;    read(n) ;     for(int i = 0 ,j = 0 ; i< n ;++i)&#123;        read(p[i]) ;        s[p[i]] ++ ;        while(s[p[i]] > 1) --s[p[j++]] ;        r = max(r, i-j+1) ;    &#125;    cout<< r<< endl ;    return 0 ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2007-从双倍数组中还原原数组"><a href="#2007-从双倍数组中还原原数组" class="headerlink" title="2007.从双倍数组中还原原数组"></a>2007.从双倍数组中还原原数组</h2><hr><p>一个整数数组 original 可以转变成一个 双倍 数组 changed ，转变方式为将 original 中每个元素 值乘以 2 加入数组中，然后将所有元素 随机打乱 。</p><p>给你一个数组 changed ，如果 change 是 双倍 数组，那么请你返回 original数组，否则请返回空数组。original 的元素可以以 任意 顺序返回。</p><p>示例 1：</p><p>输入：changed = [1,3,4,2,6,8]<br>输出：[1,3,4]<br>解释：一个可能的 original 数组为 [1,3,4] :</p><ul><li>将 1 乘以 2 ，得到 1 * 2 = 2 。</li><li>将 3 乘以 2 ，得到 3 * 2 = 6 。</li><li>将 4 乘以 2 ，得到 4 * 2 = 8 。<br>其他可能的原数组方案为 [4,3,1] 或者 [3,1,4] 。<br>示例 2：</li></ul><p>输入：changed = [6,3,0,1]<br>输出：[]<br>解释：changed 不是一个双倍数组。<br>示例 3：</p><p>输入：changed = [1]<br>输出：[]<br>解释：changed 不是一个双倍数组。</p><p>提示：</p><p>1 &lt;= changed.length &lt;= 105<br>0 &lt;= changed[i] &lt;= 105</p><hr><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    vector<int> findOriginalArray(vector<int>& a) &#123;        sort(a.begin(), a.end());        int res = 0;        unordered_map<int, int> mp;        vector<int> b;        for(auto &v: a)&#123;            if(mp[v]==0)&#123;                mp[2*v]++;        //只标记双倍的                b.push_back(v);            &#125;else&#123;                mp[v]--;         //如果双倍的值也在changed数组里面，那么双倍标记就会清除掉            &#125;        &#125;        for(auto &[k, v]: mp)&#123;            if(v) res++;            //如果有value值不是零的，说明是因为前面有值的二倍而在后面找不到，所以就冗余下来了        &#125;        if(res) return &#123;&#125;;        return b;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针算法专题</title>
      <link href="/2021/09/09/shuang-zhi-zhen-suan-fa-zhuan-ti/"/>
      <url>/2021/09/09/shuang-zhi-zhen-suan-fa-zhuan-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="一、不修改数组找出重复的数字"><a href="#一、不修改数组找出重复的数字" class="headerlink" title="一、不修改数组找出重复的数字"></a>一、不修改数组找出重复的数字</h1><p>给定一个长度为n+1 的数组<code>nums</code>，数组中所有的数均在 1∼n 的范围内，其中 n≥1。</p><p>请找出数组中任意一个重复的数，但不能修改输入的数组。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><pre><code>给定 nums = [2, 3, 5, 4, 3, 2, 6, 7]。返回 2 或 3。</code></pre><p><strong>思考题</strong>：如果只能使用 O(1) 的额外空间，该怎么做呢？</p><pre class="line-numbers language-c++"><code class="language-c++">//我的第一反应是一般看到重复什么的，我就会下意识的想到hash，于是我就写了一种数组hash的方法class Solution &#123;public:    int duplicateInArray(vector<int>& nums) &#123;        int vim[1000010] = &#123;0&#125; ;        int n = nums.size() ;        for(int i =  0 ; i < n ;++i)        &#123;            vim[nums[i]] ++ ;            if(vim[nums[i]] > 1 )                return nums[i] ;        &#125;        return 0 ;    &#125;&#125;;//这样时间复杂度是o(n) ,空间复杂度是o(n)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我又看到了有大佬用模拟链表来做，觉得是很有意思的思路。于是学习了.</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    int duplicateInArray(vector<int>& nums) &#123;        int slow = 0 , fast = 0 ;                do        &#123;            fast = nums[nums[fast]] ;            slow = nums[slow] ;        &#125;while(slow != fast) ;            fast = 0 ;                do        &#123;            fast = nums[fast] ;             slow = nums[slow] ;        &#125;while(fast != slow) ;   return slow ;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度是o(n) ,空间复杂度是o(1) 。</p><p>妙在用数组模拟链表的思路：</p><p>基于是链表找环的问题，题目是这样的</p><p><a href="https://leetcode-cn.com/problems/c32eOV/">剑指 Offer II 022. 链表中环的入口节点 - 力扣（LeetCode） (leetcode-cn.com)</a></p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    ListNode *detectCycle(ListNode *head) &#123;        if(head == NULL || head->next == NULL) return NULL ;        ListNode* fast = head->next->next ;        ListNode* slow = head->next ;        while(fast && fast->next )        &#123;            fast = fast->next->next ;            slow = slow->next ;            if(slow == fast)             break ;        &#125;        if(slow != fast) return NULL ;        else fast  = head ;        while(slow != fast)        &#123;            slow = slow->next ;            fast = fast->next ;        &#125;        return fast ;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大佬采用的是用数组下标映射值的方法，因为本题正好下标的范围其实在0-n，值的范围在1-n，也就是说存在可以相互映射的可能。</p><p>把数组全部转换成链表之后是</p><p>2-&gt;5-&gt;2 然后就是死循环了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串算法专题</title>
      <link href="/2021/09/08/zi-fu-chuan-suan-fa-zhuan-ti/"/>
      <url>/2021/09/08/zi-fu-chuan-suan-fa-zhuan-ti/</url>
      
        <content type="html"><![CDATA[<p>节选了字符串部分的一些有共性和特性的一些题目</p><h2 id="5-最长回文字符串"><a href="#5-最长回文字符串" class="headerlink" title="5.最长回文字符串"></a>5.最长回文字符串</h2><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><hr><p>示例1：</p><p>输入：s = “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。<br>示例 2：</p><p>输入：s = “cbbd”<br>输出：”bb”<br>示例 3：</p><p>输入：s = “a”<br>输出：”a”<br>示例 4：</p><p>输入：s = “ac”<br>输出：”a”</p><hr><hr><p>提示：</p><p>1 &lt;= s.length &lt;= 1000<br>s 仅由数字和英文字母（大写和/或小写）组成</p><hr><p>法一：中心扩散法</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    vector<int> maxlength(string s, int start, int end)&#123;        int n  = s.size() ;        vector<int> ans(2) ;        while(start>= 0 && end<n )&#123;            if(s[start]  == s[end])&#123;                start -- ; end++ ;            &#125;            else             break;        &#125;            start++ ; end-- ;            ans[0] = start ; ans[1] = end-start+1 ;            return ans ;    &#125;    string longestPalindrome(string s) &#123;        vector<int> ji(2) ; vector<int> ou(2)  ; vector<int> result(2) ;         int n = s.size() ;        if(n == 1) return s ;        int max =0  ;         for(int i = 0 ;i<n-1 ;++i)&#123;            ji = maxlength(s,i,i) ;            ou = maxlength(s,i,i+1) ;            int length = ji[1]>ou[1] ? ji[1]:ou[1] ;            if(length>max)&#123;                max = length ;                result = ji[1]>ou[1] ? ji:ou ;            &#125;        &#125;         return s.substr (result[0], result[1]) ;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>法二：动态规划法</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    string longestPalindrome(string s) &#123;        int n = s.size();        if (n < 2) &#123;            return s;        &#125;        int maxLen = 1;        int begin = 0;        // dp[i][j] 表示 s[i..j] 是否是回文串        vector<vector<int>>  dp(n, vector<int>(n));        // 初始化：所有长度为 1 的子串都是回文串        for (int i = 0; i < n; i++) &#123;            dp[i][i] = true;        &#125;        // 递推开始        // 先枚举子串长度        for (int L = 2; L <= n; L++) &#123;            // 枚举左边界，左边界的上限设置可以宽松一些            for (int i = 0; i < n; i++) &#123;                // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得                int j = L + i - 1;                // 如果右边界越界，就可以退出当前循环                if (j >= n) &#123;                    break;                &#125;                if (s[i] != s[j]) &#123;                    dp[i][j] = false;                &#125; else &#123;                    if (j - i < 3) &#123;                        dp[i][j] = true;                    &#125; else &#123;                        dp[i][j] = dp[i + 1][j - 1];                    &#125;                &#125;                // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置                if (dp[i][j] && j - i + 1 > maxLen) &#123;                    maxLen = j - i + 1;                    begin = i;                &#125;            &#125;        &#125;        return s.substr(begin, maxLen);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516.最长回文子序列"></a>516.最长回文子序列</h2><hr><p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><hr><hr><p>示例 1：</p><p>输入：s = “bbbab”<br>输出：4<br>解释：一个可能的最长回文子序列为 “bbbb” 。<br>示例 2：</p><p>输入：s = “cbbd”<br>输出：2<br>解释：一个可能的最长回文子序列为 “bb” 。</p><hr><hr><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul><hr><p>法一：动态规划法</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    int longestPalindromeSubseq(string s) &#123;        int n = s.size() ;        vector<vector<int>> dp(n,vector<int>(n,0)); //初始化二维的容器        for(int i = 0;i<n;i++)&#123;    //给每一个一个元素的附上初值            dp[i][i] = 1 ;        &#125;        for(int j = 0;j<n;j++)&#123;            for(int i = j-1;i>=0;i--)&#123;                if(s[i] == s[j])                dp[i][j] = dp[i+1][j-1] +2 ;                else                dp[i][j] = max(dp[i+1][j],dp[i][j-1]) ;            &#125;        &#125;       return dp[0][n-1] ;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="541-反转字符串II"><a href="#541-反转字符串II" class="headerlink" title="541.反转字符串II"></a>541.反转字符串II</h2><hr><p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每 2k 个字符反转前 k 个字符。</p><p>如果剩余字符少于 k 个，则将剩余字符全部反转。<br>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p><hr><hr><p>示例 1：</p><p>输入：s = “abcdefg”, k = 2<br>输出：”bacdfeg”<br>示例 2：</p><p>输入：s = “abcd”, k = 2<br>输出：”bacd”</p><hr><p>提示：</p><p>1 &lt;= s.length &lt;= 104<br>s 仅由小写英文组成<br>1 &lt;= k &lt;= 104</p><hr><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    string reverseStr(string s, int k) &#123;        int n = s.size() ;        for(int i = 0;i<n;i+=2*k)&#123;            reverse(s.begin()+i,s.begin()+min(n,k+i)) ;        &#125;        return s ;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763.划分字母区间"></a>763.划分字母区间</h2><hr><p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p><hr><hr><p>示例：</p><p>输入：S = “ababcbacadefegdehijhklij”<br>输出：[9,7,8]<br>解释：<br>划分结果为 “ababcbaca”, “defegde”, “hijhklij”。<br>每个字母最多出现在一个片段中。<br>像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。</p><hr><hr><p><strong>提示：</strong></p><ul><li><code>S</code>的长度在<code>[1, 500]</code>之间。</li><li><code>S</code>只包含小写字母 <code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code> 。</li></ul><hr><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    vector<int> partitionLabels(string s) &#123;       vector<int>ans,ends(26,-1) ;          //这一步是申请两个vector，一个是用来return，一个是用来反映元素最后出现的位置信号       for(int i = 0;i<s.length();i++)&#123;           ends[s[i]-'a'] = i ;                          &#125;       int i = 0 ;       int end = 0 ;       while(i<s.length())&#123;           end = ends[s[i]-'a'] ;           for(int k = i+1;k<end;k++)&#123;               end = max(end,ends[s[k]-'a']) ;           &#125;           ans.push_back(end-i+1) ;           i = end+1 ;       &#125;      return ans ;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="680-验证回文字符串II"><a href="#680-验证回文字符串II" class="headerlink" title="680.验证回文字符串II"></a>680.验证回文字符串II</h2><hr><p>给定一个非空字符串 <code>s</code>，<strong>最多</strong>删除一个字符。判断是否能成为回文字符串。</p><hr><hr><p>示例 1:</p><p>输入: s = “aba”<br>输出: true<br>示例 2:</p><p>输入: s = “abca”<br>输出: true<br>解释: 你可以删除c字符。<br>示例 3:</p><p>输入: s = “abc”<br>输出: false</p><hr><hr><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s</code> 由小写英文字母组成</li></ul><hr><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    bool validPalindrome(string s) &#123;    if(s.length() <= 2)    return true ;    else&#123;      int left = 0 ;      int right = s.length()-1 ;      while(left<right)&#123;        if(s[left] != s[right])&#123;            if(isornot(s,left+1,right) ||isornot(s,left,right-1))            return true ;            else            return false ;        &#125;        left++ ;        right-- ;      &#125;    &#125;    return true ;    &#125;    public:bool isornot(string t,int l,int r)&#123;    while(l<r)&#123;     if(t[l] == t[r])&#123;     l++ ;     r-- ;     &#125;     else     return false ;    &#125;    return true ;&#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49.字母异位词分组"></a>49.字母异位词分组</h2><hr><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p><p>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母都恰好只用一次。</p><hr><hr><p>示例 1:</p><p>输入: strs = [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]<br>输出: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]<br>示例 2:</p><p>输入: strs = [“”]<br>输出: [[“”]]<br>示例 3:</p><p>输入: strs = [“a”]<br>输出: [[“a”]]</p><hr><hr><p><strong>提示：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 104</code></li><li><code>0 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code> 仅包含小写字母</li></ul><hr><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    vector<vector<string>> groupAnagrams(vector<string>& strs) &#123;        int num[26] = &#123;2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101&#125; ;        unordered_map<unsigned long long ,vector<string>> mp ;        vector<vector<string>> result ;        for(string s : strs)&#123;            unsigned long long key = 1 ;            for(char c: s)&#123;                key *= num[c-'a'] ;            &#125;            mp[key].push_back(s) ;        &#125;        for(auto p : mp)&#123;            result.push_back(p.second) ;        &#125;        return result ;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="524-通过删除字母匹配到字典里最长单词"><a href="#524-通过删除字母匹配到字典里最长单词" class="headerlink" title="524.通过删除字母匹配到字典里最长单词"></a>524.通过删除字母匹配到字典里最长单词</h2><hr><p>给你一个字符串 s 和一个字符串数组 dictionary 作为字典，找出并返回字典中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。</p><p>如果答案不止一个，返回长度最长且字典序最小的字符串。如果答案不存在，则返回空字符串。</p><hr><hr><p>示例 1：</p><p>输入：s = “abpcplea”, dictionary = [“ale”,”apple”,”monkey”,”plea”]<br>输出：”apple”<br>示例 2：</p><p>输入：s = “abpcplea”, dictionary = [“a”,”b”,”c”]<br>输出：”a”</p><hr><hr><p>提示：</p><p>1 &lt;= s.length &lt;= 1000<br>1 &lt;= dictionary.length &lt;= 1000<br>1 &lt;= dictionary[i].length &lt;= 1000<br>s 和 dictionary[i] 仅由小写英文字母组成</p><hr><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    string findLongestWord(string s, vector<string>& dictionary) &#123;     sort(dictionary.begin(),dictionary.end(),[](string a,string b)&#123;         if(a.length() == b.length())         return a<b ;         return a.length()>b.length() ;     &#125;) ;     for(string str:dictionary)&#123;        int i = 0 ;        for(char c: s)&#123;            if(i<str.size() && c == str[i])            i++ ;           if(i == str.size())           return str ;        &#125;     &#125;     return "" ;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76.最小覆盖子串"></a>76.最小覆盖子串</h2><h2 id="443-压缩字符串"><a href="#443-压缩字符串" class="headerlink" title="443.压缩字符串"></a>443.压缩字符串</h2>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法专题</title>
      <link href="/2021/09/08/tan-xin-suan-fa-zhuan-ti/"/>
      <url>/2021/09/08/tan-xin-suan-fa-zhuan-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="贪心算法总结"><a href="#贪心算法总结" class="headerlink" title="贪心算法总结"></a>贪心算法总结</h1><h2 id="贪心算法简述"><a href="#贪心算法简述" class="headerlink" title="贪心算法简述"></a>贪心算法简述</h2><p>贪心算法是原理最简单的一种算法，甚至可以将其中一些部分理解为常识或者是常规思维。</p><p>他采取贪心的策略，即保证每次操作都是最优的，先得到局部的最优解，从而使最终的结果是最优的。</p><h2 id="leetcode刷题"><a href="#leetcode刷题" class="headerlink" title="leetcode刷题"></a>leetcode刷题</h2><h3 id="分配问题"><a href="#分配问题" class="headerlink" title="分配问题"></a>分配问题</h3><h3 id="455-Assign-Cookies-Easy"><a href="#455-Assign-Cookies-Easy" class="headerlink" title="455.Assign Cookies(Easy)"></a>455.Assign Cookies(Easy)</h3><h5 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h5><p>有一群孩子和一堆饼干，每个孩子都有一个饥饿度，每个饼干都有一个大小。每个孩子只能吃最多一个饼干，且只有饼干的大小大于孩子的饥饿度时，这个孩子才可以吃饱。求解最多有多少个孩子可以吃饱。</p><h5 id="输入输出样例："><a href="#输入输出样例：" class="headerlink" title="输入输出样例："></a>输入输出样例：</h5><hr><p>Input : [1,2],[1,2,3] </p><p>Output : 2</p><hr><h5 id="一些想法："><a href="#一些想法：" class="headerlink" title="一些想法："></a>一些想法：</h5><p>这里的贪心策略就是尽可能的将剩余孩子中饥饿度最小的满足，每一次只考虑最小的饥饿度。</p><p>所以算法实现就是先将所有孩子的饥饿度和饼干的大小从大到小进行排序，然后设置两个指针分别指向child和cookie，当遇到cookie的值大于等于孩子的饥饿度时，即满足条件，故将指针均后移即可。若不满足，cookie后移即可。当有一个到达尽头时，循环结束。返回已经满足的孩子数量。</p><h5 id="代码部分："><a href="#代码部分：" class="headerlink" title="代码部分："></a>代码部分：</h5><pre class="line-numbers language-c++"><code class="language-c++">int findContentChildren(vector<int>& children,vector<int>& cookies) &#123;    int child = 0 ;    int cookie = 0 ;    while(child<children.size() && cookie<cookies.size())&#123;        if(children[child] <= cookies[cookie])&#123;            child++ ;            cookie++ ;        &#125;        else            cookie++ ;    &#125;    return child ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="135-Candy-Hard"><a href="#135-Candy-Hard" class="headerlink" title="135.Candy(Hard)"></a>135.Candy(Hard)</h3><h5 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h5><p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p><p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p><p>每个孩子至少分配到 1 个糖果。</p><p>评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。</p><p>那么这样下来，老师至少需要准备多少颗糖果呢？</p><h5 id="输入输出样例：-1"><a href="#输入输出样例：-1" class="headerlink" title="输入输出样例："></a>输入输出样例：</h5><hr><p>Input : [1,0,2]</p><p>Output : 5</p><hr><hr><p>Input : [1,2,2]</p><p>Output : 4</p><hr><h5 id="一些想法：-1"><a href="#一些想法：-1" class="headerlink" title="一些想法："></a>一些想法：</h5><p>一开始为了有一个基准值，方便比较，同时题目要求所有孩子都至少有一个糖果，所以先应该将所有孩子的糖果全部初始化为1.</p><p>可以分成两边进行考虑，进行两轮的遍历。如果遇到自己比邻位大的话，就在邻位的基础上加一即可。</p><p>最后将所有值相加并返回即可。</p><h5 id="代码部分：-1"><a href="#代码部分：-1" class="headerlink" title="代码部分："></a>代码部分：</h5><pre class="line-numbers language-c++"><code class="language-c++">int candy(vector<int>& ratings)&#123;    int size = ratings.size() ;    if(size <= 1)    return size ;    vector<int> candies(,1) ;   //将所有的糖果数全部初始化为1    //第一轮，从左往右进行比对    for(int i = 1 ;i < size ; i++)&#123;        if(ratings[i] > ratings[i-1])&#123;            candies[i] = candies[i-1]+1 ;        &#125;    &#125;    //第二轮，从右向左进行比对    for(int i = size-1 ; i > 0; i--)&#123;        if(ratings[i-1] > ratings[i])&#123;            candies[i-1] = max(candies[i-1],ratings[i]+1) ;        &#125;    &#125;    //最终返回所有值的和    return accumulate(candies.begin(),candies.end(),0) ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h3><h3 id="435-Non-overlapping-Intervals-Medium"><a href="#435-Non-overlapping-Intervals-Medium" class="headerlink" title="435.Non-overlapping Intervals(Medium)"></a>435.Non-overlapping Intervals(Medium)</h3><h5 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h5><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><h5 id="输入输出样例：-2"><a href="#输入输出样例：-2" class="headerlink" title="输入输出样例："></a>输入输出样例：</h5><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20210730165723809.png" alt="image-20210730165723809" style="zoom:100%;" /><h5 id="一些想法：-2"><a href="#一些想法：-2" class="headerlink" title="一些想法："></a>一些想法：</h5><p>选取的贪心策略是先对于所有区间的尾节点，进行升序排序，然后以保留尾节点最小而且与前一个结点无重叠区间为优先。</p><p>排序的时候会用到c++的lamda表达式，可以利用其与sort结合进行自定义排序。</p><h5 id="代码部分：-2"><a href="#代码部分：-2" class="headerlink" title="代码部分："></a>代码部分：</h5><pre class="line-numbers language-c++"><code class="language-c++">int eraseOverlapIntervals(vector<vector<int>>& intervals)&#123;    int sum = 0 ; //肯定要先设置一个计数器    //进行按照尾节点的升序排序    sort(intervals.begin(),intervals.end(),[](vector<int> a,vector<int> b)&#123;        return a[1]>b[1] ;    &#125;) ;    int pre = intervals[0][1] ;    for(int i = 1 ; i < intervals.size() ; i++)&#123;        if(intervals[i][0] < pre)&#123;            sum++ ;        &#125;        else&#123;            pre = intervals[i][1] ;        &#125;    &#125;    return sum ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>luolin-first-blog</title>
      <link href="/2021/09/05/luolin-first-blog/"/>
      <url>/2021/09/05/luolin-first-blog/</url>
      
        <content type="html"><![CDATA[<p>这是我的第一篇博客，等熟悉了流程之后会频繁的更新博客，因为这也算是自己学习的过程的记录。</p><p>我是罗林 来自南京农业大学 专业是数据科学与大数据技术 </p><p>这个博客是为了记录我的学习生活，以及生活中的一些有趣的事情。</p><p>应该会先分为两个板块：机器学习，数据结构与算法。</p><p>之后有新的认知或者是对新的领域有兴趣可能会在追加几个板块。</p><p>我的座右铭是 一直学习，做一个有趣的人！希望有同样热爱计算机的geek们与我交流！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> selfintroduction </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
