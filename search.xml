<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>动态规划一日一题-10-12-最长公共上升子序列</title>
      <link href="/2021/10/12/dong-tai-gui-hua-yi-ri-yi-ti-10-12-zui-chang-gong-gong-shang-sheng-zi-xu-lie/"/>
      <url>/2021/10/12/dong-tai-gui-hua-yi-ri-yi-ti-10-12-zui-chang-gong-gong-shang-sheng-zi-xu-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="最长公共上升子序列"><a href="#最长公共上升子序列" class="headerlink" title="最长公共上升子序列"></a>最长公共上升子序列</h1><hr><p>熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目。</p><p>小沐沐先让奶牛研究了最长上升子序列，再让他们研究了最长公共子序列，现在又让他们研究最长公共上升子序列了。</p><p>小沐沐说，对于两个数列 A 和 B，如果它们都包含一段位置不一定连续的数，且数值是严格递增的，那么称这一段数是两个数列的公共上升子序列，而所有的公共上升子序列中最长的就是最长公共上升子序列了。</p><p>奶牛半懂不懂，小沐沐要你来告诉奶牛什么是最长公共上升子序列。</p><p>不过，只要告诉奶牛它的长度就可以了。</p><p>数列 A 和 B 的长度均不超过 3000。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含一个整数 N，表示数列 A，B的长度。</p><p>第二行包含 N 个整数，表示数列 A。</p><p>第三行包含 N 个整数，表示数列 B。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最长公共上升子序列的长度。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤3000,序列中的数字均不超过 231−1。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>42 2 1 32 1 2 3</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>2</code></pre><hr><p>好吧，我承认看到题就直接懵逼了…….</p><p>我们之前做过最长上升子序列和最长公共子序列。这里就简单回顾一下一些基本的参数。</p><p>LIS：</p><p>状态表示：dp[i] 表示从1到i的序列中，最长的上升子序列的长度，不一定非要是i结尾。</p><p>状态属性：max</p><p>base case：dp[i] = 1 ; </p><p>状态转移：用i做一次遍历，然后用j往前进行遍历，如果遇到符合要求的，继续找最大值即可。</p><pre class="line-numbers language-c++"><code class="language-c++">for(int i = 1 ; i <= n ; ++ i)&#123;    dp[i] = 1 ;     for(int j = i-1 ; j >= 0 ; --j)    &#123;        if(a[i] > a[j])        dp[i] = max(dp[i] , dp[j]  + 1) ;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>LCS：</p><p>状态表示：dp[i] [j] 表示a串的1-i， 到b串的1-j，中最长的公共子序列，不一定要是以j结尾。</p><p>状态属性：max</p><p>base case：dp[i] [0] = 0 ;  dp[0] [i] = 0  ;</p><p>状态转移：</p><p>if 相等  dp[i] [j] = dp[i-1] [j-1]  + 1 ;  </p><p>else      dp[i] [j] = max(dp[i-1] [j] , dp[i] [j-1]) ;</p><pre class="line-numbers language-c++"><code class="language-c++">for(int i = 1 ; i <= n ; ++i)&#123;    for(int j = 1 ; j <= n ;++ j)    &#123;        if(a[i] == b[j])        &#123;            f[i][j] = f[i-1][j-1]  + 1 ;         &#125;        else        &#123;            f[i][j] = max(f[i-1][j] , f[i][j-1]) ;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好，其实这一题就是上述两题的融合。</p><p>我们学着来自行分析一下基本参数：</p><p>状态表示：dp[i] [j] 表示a串1-i ， b串1-j， 且b串以j结尾的序列的包含的最长公共上升子序列。</p><p>(为什么非要是以j结尾呢？不以任何结尾行吗)（为什么不以i结尾？）</p><p>状态属性：max</p><p>base case：同LCS，但是申请全局变量了，就不需要显性的申明了。</p><p>状态转移：</p><p>if 相等  由于j是定位符的特性，找到倒数第二个满足最长公共上升子序列的j的下标，要以此来进行转移。</p><p>贴个代码：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 3010 ; int a[N] , b[N] ; int f[N][N] ;int main()&#123;    int n ;     cin >> n ;     for(int i = 1 ; i <= n ; ++ i)    &#123;        cin >> a[i] ;     &#125;        for(int i = 1 ;  i <= n ; ++ i)    &#123;        cin >> b[i] ;    &#125;        for(int i = 1 ; i <= n ; ++i)    &#123;        for(int j = 1 ; j <= n ; ++ j)        &#123;            f[i][j] = f[i-1][j] ;             if(a[i] == b[j])            &#123;                 f[i][j] = max(f[i][j] , 1) ;                for(int k = 1 ;  k < j ; ++ k)                &#123;                    if(b[k] < b[j])                    &#123;                        f[i][j] = max(f[i][j] , f[i-1][k] + 1) ;                    &#125;                &#125;            &#125;        &#125;    &#125;        int res = 0 ;     for(int i = 1 ; i <= n ; ++i)    &#123;        res = max(res , f[n][i]) ;    &#125;    cout << res << endl ;    return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码是完全根据我们的思路来走的，属于是最朴素的代码，我们可以看到有三层循环。数据范围是在1000左右的，最后应该会TLE。</p><p>所以，我们如何才能有三轮优化成两轮？？？</p><p>明天再更….. 今天累了</p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>其实在看y总的讲解之后，我是感觉有点被打破思考模式的感觉，就是感觉就算是做了前置的LIS与LCS，但是遇到这种题，思路还是没有明显。</p><p>甚至有很多问题：</p><p>一、为什么要以j定位？</p><p>二、如何体现有c有l？</p><p>总之，刷题的意义在于利用旧的知识，在遇到新的问题的时候，可以顺利的想到多种以前可以顺利解决的思路。所以，如果遇到一个问题，你感觉他不是你的框架里面的东西，但是看了答案之后，却发现你可以利用现有的知识完全的解决他们。这可以说明两个事情：</p><p>一、对以往的问题思考不够深入</p><p>二、知识框架过于片面与呆板</p><p>总之，学习能力的提升过程其实就是不断建立自己的思维模式的过程，不断建立，然后不断打破，然后再进行建立，这是正常过程。</p><p>继续坚持，随着时间与问题的堆积，你的思维模式会越来越多元化，框架会越来越硬，由flask变成django(hhhhh，玩个小梗) 。量变引起质变。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 一日一题 线性dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++类的基本概念与实例</title>
      <link href="/2021/10/12/c-lei-de-ji-ben-gai-nian-yu-shi-li/"/>
      <url>/2021/10/12/c-lei-de-ji-ben-gai-nian-yu-shi-li/</url>
      
        <content type="html"><![CDATA[<h1 id="类的基本数据成员与成员函数的总结"><a href="#类的基本数据成员与成员函数的总结" class="headerlink" title="类的基本数据成员与成员函数的总结"></a>类的基本数据成员与成员函数的总结</h1>]]></content>
      
      
      
        <tags>
            
            <tag> c++学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划一日一题-10-11-最长回文子串</title>
      <link href="/2021/10/11/dong-tai-gui-hua-yi-ri-yi-ti-10-11-zui-chang-hui-wen-zi-chuan/"/>
      <url>/2021/10/11/dong-tai-gui-hua-yi-ri-yi-ti-10-11-zui-chang-hui-wen-zi-chuan/</url>
      
        <content type="html"><![CDATA[<h1 id="最长回文子串与最长回文子序列的爱恨情仇"><a href="#最长回文子串与最长回文子序列的爱恨情仇" class="headerlink" title="最长回文子串与最长回文子序列的爱恨情仇"></a>最长回文子串与最长回文子序列的爱恨情仇</h1><hr><p>给定一个字符串，请你求出其中的最长回文子串的长度。</p><p>例如，给定字符串 <code>Is PAT&amp;TAP symmetric?</code>，最长回文子串为 <code>s PAT&amp;TAP s</code>，其长度是 1111。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>包含一个非空字符串。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示给定字符串的最长回文子串的长度。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>给定字符串的长度不超过 1000。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>Is PAT&amp;TAP symmetric?</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>11</code></pre><hr><p>好吧，这道题目实属非常经典的一道例题，有很多种做法，下面开始介绍两种方法。</p><p>(小声bb，其实还有一种马拉车算法，之后有时间再讲，其实不是很重点的一种方法，也比较简单)</p><p>在介绍这三种方法之后，我们需要对比一下，leetcode上面的一道题目</p><p><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">516. 最长回文子序列 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>仔细想一下，子序列与子串的difference在什么地方。在dp做法的时候，在状态表示，状态转移的过程中有什么明显的区别？？？</p><h2 id="一、线性dp"><a href="#一、线性dp" class="headerlink" title="一、线性dp"></a>一、线性dp</h2><p>状态表示：f[i] [j] 表示什么呢？因为其实线性dp不是我第一次做出来这个题目所用的方法。</p><p>我闪过几个角度，like 从i到j这一段中最长的子串的长度？ 其实有点像后面要说的，子序列的表示。</p><p>或者是f[i] [j] 表示i到j是回文子串同时储存着长度？有点脱裤子放… 不对，就像是为了dp而dp的感觉….</p><p>最终选择dp[i] [j] 不仅表示回文子串而且存贮这长度这种表示方式，没什么原因，就是感觉思路简单，便于比较。</p><p>状态属性：max</p><p>base case：每一个字符都可以表示为长度为一的回文子串。</p><p>状态转移：这样想，所有回文子串(注意连续)，都是只可能有一种状态转移来的，dp[i+1] [j-1]  +2 转移来的，so 只需要一种语句即可。</p><p>直接</p><pre class="line-numbers language-c++"><code class="language-c++">if(a[i] == a[j])&#123;    f[i][j] = f[i+1][j-1] + 2 ; &#125;else&#123;    f[i][j] = -1000 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="两个雷区"><a href="#两个雷区" class="headerlink" title="两个雷区"></a>两个雷区</h4><p>一是遍历顺序，这个注意即可，细心就行。</p><p>二是对不满足条件的处理，我之前就是因为，没有上述的else的语句，被卡了大概5分钟…..</p><p>我们这样想，因为f表示的是连续符合要求的子串，如果不满足a[i] == a[j]，其实就是等于把这个i到j给pass了，给他一个大的负数就是等于，不让他影响后续res的max函数的判断，这样会省下很多烦恼。</p><p>代码如下：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N  = 1010 ; string a ; int f[N][N] ; int main()&#123;    getline(cin , a) ;    int n = a.size() ;     if(n == 1)     &#123;        cout << 1 << endl ;    &#125;    else    &#123;    int res = 1 ;     for(int i = 0 ; i < n ; ++ i)    &#123;        f[i][i] = 1 ;     &#125;        for(int i = n-1 ; i >= 0 ; --i)    &#123;        for(int j = i + 1  ; j < n ; j ++)        &#123;            if(a[i] == a[j])            &#123;                f[i][j] = f[i+1][j-1] + 2 ;             &#125;            else            &#123;                f[i][j] = -10000 ;             &#125;                res = max(res , f[i][j]) ;        &#125;    &#125;    cout << res << endl  ;    &#125;    return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、中心扩散法"><a href="#二、中心扩散法" class="headerlink" title="二、中心扩散法"></a>二、中心扩散法</h2><p>这一种方法其实是我第一次做出来的方法，我觉得他比较符合一般思维的特点。具体逻辑是先进行一次循环遍历，将自己所指向的下标作为回文子串的中心。向左右开始扩散，判断方法是字符是否相同，如果字符相同，即为之前的数量加上2即可。再用一个res储存最大值就可以。</p><p>但是，最主要注意的是需要分成奇数回文字符串与偶数回文字符串，分别循环，最后取大值即可。</p><h3 id="OK。Talk-is-cheap-show-me-your-code"><a href="#OK。Talk-is-cheap-show-me-your-code" class="headerlink" title="OK。Talk is cheap, show me your code"></a>OK。Talk is cheap, show me your code</h3><p>贴个代码：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 1010 ; int f[N][N] ; string a ; int main()&#123;    getline(cin , a) ;        int n = a.size() ;        if(n == 1) cout << 1 << endl ;    else    &#123;    int res = -1000 ;     for(int i = 0 ; i < n ; ++ i)        f[i][i] = 1 ;         for(int i = 0 ; i < n ;++ i)                 //奇数回文    &#123;        int l = i - 1 ; int r  = i + 1 ;                 while(l >= 0 && r < n && a[l] == a[r])        &#123;            f[l][r] = f[l+1][r-1] + 2 ;             l -- ;  r ++ ;        &#125;        res = max(res ,f[l+1][r-1] ) ;    &#125;        for(int i = 0 ; i < n ; ++ i)                 //偶数回文    &#123;        int l  = i  ; int r = i + 1 ;         while(l >= 0 && r < n && a[l] == a[r])        &#123;            f[l][r] = f[l+1][r-1] + 2 ;             l -- ;  r ++ ;        &#125;        res = max(res ,f[l+1][r-1] ) ;    &#125;    cout << res << endl ;     &#125;    return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>———-10-12 添加———————————————————————————————————————————————————</p><p>ok，在看manacher算法的时候，他的预处理也可以用在中心扩散法(暴力)。因为暴力解法需要分两种情况，一种是偶数的，还有一种是奇数的。可以在string a的每一个字符左右两面都添加一个额外符号，相同即可。所以原数据范围由n到2*n+1 ; </p><p>一定可以转化为奇数来做。</p><p>但是注意两个细节：</p><p>一、申请的范围N, 因为数据由1000到了2001，所以申请超过2010就可以了。</p><p>二、最后的输出结果，由于c++除法自动向下取整，所以结果就是res &gt;&gt; 1即可。别的没有什么。</p><p>所以，贴个代码：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ; const int N = 2010 ; string a ; int f[N][N] ; int main()&#123;    getline(cin , a) ;     string b = "" ;         int n = a.size() ;     for(int i = 0 ; i < n  ; ++ i)    &#123;        b.push_back('#') ;        b.push_back(a[i]) ;    &#125;     b.push_back('#') ;    n = b.size() ;     for(int i = 0 ; i < n  ; ++ i)    &#123;        f[i][i] = 1 ;     &#125;    int res = 1 ;    for(int i = 1;  i < n ; ++  i)    &#123;        int l = i -1 ;         int r = i + 1 ;         while(l >= 0  && r < n && b[l] == b[r])        &#123;            f[l][r] = f[l+1][r-1]  + 2 ;           l -- ; r++ ;          &#125;                res = max(res , f[l+1][r-1])  ;     &#125;    int ans = res / 2 ;     cout << ans << endl ;    return 0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ok.以上就是最长回文子串的做法，我们来看最长回文子序列的题目。</p><p><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">516. 最长回文子序列 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>这就是典型的线性dp可以做出来的题，我们按照经典模板走一下。</p><p>状态表示：dp[i] [j] 表示在下标为i到j的一段字符串中， 最长子序列的长度。</p><p>状态属性：max</p><p>base case：每一个字符都可以看成是一个长度为一的回文字符串。</p><p>状态转移：字符串经典分割，按照遍历时候，字符是否相同进行分割。</p><p>​                    如果相同，f[i] [j] =  f[i+1] [j-1]  + 2  ; </p><p>​                    如果不同 ， f[i] [j] = max(f[i] [j-1] , f[i+1] [j]) ;</p><p>感觉都成了肌肉记忆了…………</p><p>贴个代码：</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    int longestPalindromeSubseq(string s) &#123;        int n = s.size() ;        if(n == 1) return 1 ;         vector<vector<int>> f(n , vector<int> (n,  0)) ;         for(int i = 0 ; i < n  ; ++ i)        &#123;            f[i][i] = 1 ;         &#125;                for(int i = n-1 ; i >= 0 ; --i)        &#123;             for(int j = i + 1 ; j < n ; ++ j)      //一个小细节，注意遍历的顺序，这是根据状态转移的式子来的。             &#123;                 if(s[i] == s[j])                 &#123;                     f[i][j] = f[i+1][j-1] + 2 ;                  &#125;                 else                 &#123;                     f[i][j] = max(f[i][j-1] , f[i+1][j]) ;                 &#125;             &#125;        &#125;        return f[0][n-1] ;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以明显的感觉到两者之间的方法的差异。</p><p>本质上，其实就是定义的差别，即连续与不连续的区别。这就导致了在dp的时候，状态表示的差异。</p><h3 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h3><p>状态表示：是饱满的，就是相当于中间不能有任何空隙，任何使得中间有空隙的f段都会被直接pass。</p><p>状态属性：max</p><p>base case：不说了</p><p>状态转移：唯一一种形成的方式，就是相等才会前进，如果不等，就直接pass</p><h3 id="子序列"><a href="#子序列" class="headerlink" title="子序列"></a>子序列</h3><p>状态表示：相等于很宽容，里面既可以有合乎要求的，也可以有方案外的。</p><p>状态属性：同子串</p><p>base case：同子串</p><p>状态转移：经典按照字符串==方式进行划分， if 就+2 else 就回退。</p><p>好了，终于写完了！！！ </p><p>之后有时间介绍一下，马拉车算法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 一日一题 线性dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell语法学习</title>
      <link href="/2021/10/10/shell-yu-fa-xue-xi/"/>
      <url>/2021/10/10/shell-yu-fa-xue-xi/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git基本原理以及常用命令</title>
      <link href="/2021/10/10/git-ji-ben-yuan-li-yi-ji-chang-yong-ming-ling/"/>
      <url>/2021/10/10/git-ji-ben-yuan-li-yi-ji-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>由回文平方讲一种无脑转进制的方法</title>
      <link href="/2021/10/10/you-hui-wen-ping-fang-jiang-yi-chong-wu-nao-zhuan-jin-zhi-de-fang-fa/"/>
      <url>/2021/10/10/you-hui-wen-ping-fang-jiang-yi-chong-wu-nao-zhuan-jin-zhi-de-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="回文平方"><a href="#回文平方" class="headerlink" title="回文平方"></a>回文平方</h1><hr><p>回文数是指数字从前往后读和从后往前读都相同的数字。</p><p>例如数字 12321 就是典型的回文数字。</p><p>现在给定你一个整数 B，请你判断 1∼300之间的所有整数中，有哪些整数的<strong>平方</strong>转化为 B 进制后，其 B 进制表示是回文数字。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>一个整数 B。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>每行包含两个<strong>在 B 进制下</strong>表示的数字。</p><p>第一个表示满足平方值转化为 B 进制后是回文数字那个数，第二个数表示第一个数的平方。</p><p>所有满足条件的数字按从小到大顺序依次输出。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>2≤B≤20,<br>对于大于 9 的数字，用 A 表示 10，用 B 表示 11，以此类推。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>10</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>1 12 43 911 12122 48426 676101 10201111 12321121 14641202 40804212 44944264 69696</code></pre><hr><p>思路比较简单，这里主要讲一种无脑转进制的方法。</p><p>先贴代码</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ; int B ; string a = "0123456789ABCDEFGHIJK" ; string tob(int sum)&#123;    string res = "" ;     while(sum)    &#123;        res += a[sum%B] ;         sum /= B ;     &#125;    reverse(res.begin(), res.end()) ;    return res ;&#125;bool check(string a)&#123;    int l = 0 ;     int r = a.size() -1 ;    while(l < r)    &#123;        if(a[l] == a[r])        &#123;            l ++ ; r -- ;        &#125;        else        &#123;            return false ;         &#125;    &#125;    return true ; &#125;int main()&#123;    cin >> B ;         for(int i = 1 ; i <= 300 ; ++i)    &#123;        string x = tob(i*i) ;         if(check(x))        &#123;            string y = tob(i) ;            cout << y << " " << x << endl ;         &#125;    &#125;    return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里可以注意到，我在将任意数转换成B进制的时候，直接采用了一种比较万能的方法，直接将备选的string组给展示出来。然后就直接可以套用模板来进行转换了。如果最后是要用int型的，直接调用atoi函数即可。</p><p>例如，leetcode的一道题目：</p><p><a href="https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/">405. 数字转换为十六进制数 - 力扣（LeetCode） (leetcode-cn.com)</a></p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    string toHex(int num) &#123;        string a = "0123456789ABCDEF" ;                 long long n = num < 0 ? (long long) (num + pow(2,32)) : num ;         string res = "" ;         while(n)        &#123;            res += a[n%16] ;             n /= 16 ;        &#125;        reverse(res.begin() , res.end()) ;        return res ;     &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特别要注意的是，当负数要进行进制转换的时候，因为要按照补码进行运算，就是再十进制基础上，加上了pow(2,32) 。但是同时也要注意，会不会爆int,因为int的范围是2的-31~2的31，直接加上pow(2，32)就会爆int ，所以我们需要有一个强制转换，ok，除此之外就没有什么了。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划一日一题-10-10-最长公共子序列</title>
      <link href="/2021/10/10/dong-tai-gui-hua-yi-ri-yi-ti-10-10-zui-chang-gong-gong-zi-xu-lie/"/>
      <url>/2021/10/10/dong-tai-gui-hua-yi-ri-yi-ti-10-10-zui-chang-gong-gong-zi-xu-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><hr><p>给定两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 N 和 M。</p><p>第二行包含一个长度为 N 的字符串，表示字符串 A。</p><p>第三行包含一个长度为 M 的字符串，表示字符串 B。</p><p>字符串均由小写字母构成。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大长度。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N,M≤1000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>4 5acbdabedc</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>3</code></pre><hr><p>这题也是经典的双串的线性dp问题，按照模板来进行分析即可。</p><p>状态表示：dp[i] [j] 表示串a的1-i与串b的1-j之间的最长common子序列。所以最终答案的返回值应该是dp[n] [m] ; </p><p>状态属性：max</p><p>base case：dp[i] [0] =  0 ; dp[0] [j] = 0 ;</p><p>状态转移：按照典型的字符相等判断</p><p>​                    如果两者是相等的，dp[i] [j] = dp[i-1] [j-1] + 1 ; </p><p>​                    如果不等 ， dp[i] [ j] = max(dp[i-1] [j] , dp[ i] [j-1]) ; </p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 1010 ; int f[N][N] ; char a[N] , b[N] ; int main()&#123;    int n , m ;         cin >> n >> m ;         scanf("%s%s" , a + 1 , b + 1) ;         for(int i = 1 ;  i <= n ; ++i)        a[i][0] = 0  ;     for(int j = 1 ; j <= m ; ++j)        a[0][j] = 0 ;         for(int i = 1 ;  i <= n ; ++i )    &#123;        for(int j = 1 ; j <= m ; ++j)        &#123;            if(a[i] == b[j])            &#123;                f[i][j] = f[i-1][j-1] + 1 ;             &#125;            else            &#123;                f[i][j] = max(f[i-1][j] , f[i][j-1]) ;            &#125;        &#125;    &#125;    cout << f[n][m] << endl ;     return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>经典的模板题，按照模板走即可，没有什么说的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 一日一题 线性dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蛇形矩阵</title>
      <link href="/2021/10/09/she-xing-ju-zhen/"/>
      <url>/2021/10/09/she-xing-ju-zhen/</url>
      
        <content type="html"><![CDATA[<h1 id="蛇形矩阵"><a href="#蛇形矩阵" class="headerlink" title="蛇形矩阵"></a>蛇形矩阵</h1><hr><p>输入两个整数 n和 m，输出一个 n行 m 列的矩阵，将数字 1 到 n×m 按照回字蛇形填充至矩阵中。</p><p>具体矩阵形式可参考样例。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入共一行，包含两个整数 n 和 m。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出满足要求的矩阵。</p><p>矩阵占 n 行，每行包含 m 个空格隔开的整数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n,m≤100</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>3 3</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>1 2 38 9 47 6 5</code></pre><hr><p>好家伙，纯模拟，耐心就可以，纯耗时间，没有技巧…..</p><p>贴个代码：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 1010 ;int f[N][N] ; int main()&#123;    int n , m  ;    cin >> n >> m  ;     int all = n*m ;     int cnt = 0 ;    int top1 =n , top2 = m  , bottom1 = 1 , bottom2 = 1 ;    while(all > 0 )    &#123;        for(int j = bottom2 ; j <= top2 ;  j++)        &#123;            f[bottom1][j] = ++cnt ;            all -- ;        &#125;        top2 -- ;        for(int i = bottom1 ; i <= top1 ; ++i)        &#123;            f[i][top2+1] = ++cnt ;            all -- ;        &#125;        top1 -- ;                 for(int j = top2 ; j >= bottom2 ; --j)        &#123;            f[top1+1][j] = ++cnt ;            all -- ;        &#125;        bottom2 ++ ;                 for(int i = top1 ; i <= bottom1 ; --i)        &#123;            f[i][bottom2] = ++cnt ;            all -- ;        &#125;        bottom1 ++ ;             &#125;        for(int i  = 1 ; i <= n ; ++i)    &#123;        for(int j = 1 ; j <= m ;++j)        &#123;            cout << f[i][j] << " " ;        &#125;        cout << endl ;    &#125;    return  0 ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意对称美还有一些细节就行了……. 模拟的题目是最无聊的…….</p>]]></content>
      
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划一日一题-10-9-最长上升子序列</title>
      <link href="/2021/10/09/dong-tai-gui-hua-yi-ri-yi-ti-10-9-zui-chang-shang-sheng-zi-xu-lie/"/>
      <url>/2021/10/09/dong-tai-gui-hua-yi-ri-yi-ti-10-9-zui-chang-shang-sheng-zi-xu-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h1><p>给定一个长度为 N的数列，求数值严格单调递增的子序列的长度最长是多少。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 N。</p><p>第二行包含 N 个整数，表示完整序列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大长度。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤1000<br>−109≤数列中的数≤109</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>73 1 2 1 8 5 6</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>4</code></pre><p>此题在审题的时候就要注意一下子串和子序列的区别。子串必须是连续的，但是子序列只要是有左右顺序即可，可以不需要是连续的。</p><p>给出的数据是个数，以及一支长串字符序列，要求返回的是最长递增序列的长度。</p><p>状态表示：f[i] 表示的是以第i个字符结尾的从1-i的最长上升子序列的长度。</p><p>状态属性：max</p><p>base case：f[i] = 1 ; 因为每一个字符可以看作是只有一个字符的序列</p><p>状态转移：对于每一个f[i] 他的值其实来源于他前面的序列中比他小的f[j] 集合中最大的然后在加上一</p><pre class="line-numbers language-c++"><code class="language-c++">//表示的是大概意思，代码是不对的，但是思路是这样的for(int i = 1 ; i <= n ; ++i)&#123;    for(int j = i-1 ; j >= 0 ; --j)    &#123;        if(a[i] > a[j])        &#123;            f[i] = f[j]+1 ;         &#125;        res = max(res, f[i]) ;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>So,代码如下：</p><pre class="line-numbers language-c++"><code class="language-c++">#include<bits/stdc++.h>using namespace std ; const int N = 1010 ; int a[N] , f[N] ; int main()&#123;    int n ;     cin >> n ;         int res = -1e9-1 ;         for(int i = 1 ; i <= n ; ++i)    &#123;        cin >> a[i] ;     &#125;        for(int i = 1 ; i <= n ; ++i)    &#123;        f[i]  = 1;         for(int j = i-1 ; j >= 0 ; --j)        &#123;            if(a[i] >  a[j])            &#123;                f[i] = max(f[i] , f[j]  + 1) ;             &#125;        &#125;        res = max(res , f[i]) ;     &#125;        cout << res << endl ;     return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ok，分析一下上面代码的时间复杂度O(n2) 。</p><p>那么是否存在更加优化时间的方案呢？</p><h2 id="贪心加二分"><a href="#贪心加二分" class="headerlink" title="贪心加二分"></a>贪心加二分</h2><p>我们想到其实对于f[i]表示的是以a[i]结尾的子序列来说，我们可以有这样的想法：</p><p>1.首先明确一点：我们维护一个上升子序列，想让子序列的长度更长，那就相当于往后遍历的时候遇到了比已经维护的子序列中最大的要小的数字a[i]的时候，我们应该找子序列中小于a[i]的最大的数字，然后将其替换成a[i] 。这样就可以保证之后理论上可以替换更多的数字，从而维护了最长的子序列。</p><p>2.那么我们如果仅仅是两轮循环遍历，来实现上述思想，那么细心的同学就可以发现，时间复杂度并没有优化，只是思路发生了变化而已。所以，可以这样实现的重点就是我们在维护的子序列中可以采用二分的方法来找到小于a[i]的最大数字。所以时间复杂度优化为O(nlgn).</p><p>actually，这种思路的话，其实个人感觉不太像dp，而是更像是贪心算法，在加上二分。</p><p>ok，下面是代码实现：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 100010 ;//q[N]是我们要维护的序列//w[N]负责读入数据int q[N] , w[N] ; int cnt ; int find(int *q , int num)&#123;    int l = 1 ;     int r = cnt ;     while(l < r)    &#123;        int mid = l + r >> 1  ;        if(q[mid] < num)        &#123;            l = mid + 1 ;         &#125;        else        &#123;            r  = mid ;         &#125;    &#125;    return  l ;&#125;int main()&#123;    int n ;     cin >> n ;     for(int i = 1 ; i <= n ;++i)    &#123;        cin >> w[i] ;     &#125;    q[++cnt] = w[1] ;     for(int i = 2 ; i <= n ;++i)    &#123;        if(w[i] > q[cnt])        &#123;            q[++cnt] = w[i] ;    //如果是个比维护序列的最大值大的，就直接加入即可        &#125;       else       &#123;           int t = find(q ,  w[i]) ;            q[t] = w[i] ;        &#125;    &#125;        cout << cnt << endl ;    return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ok,以上是解决了长度的问题，那我们开始举一反三，是否可以在举一个同类的问题</p><h2 id="能否返回所有长度为最长的上升子序列的个数？"><a href="#能否返回所有长度为最长的上升子序列的个数？" class="headerlink" title="能否返回所有长度为最长的上升子序列的个数？"></a>能否返回所有长度为最长的上升子序列的个数？</h2><p>好吧，今天时间有限，等下次在更…….</p>]]></content>
      
      
      
        <tags>
            
            <tag> 一日一题 线性dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划一日一题-10-8-混合背包问题</title>
      <link href="/2021/10/08/dong-tai-gui-hua-yi-ri-yi-ti-10-8-hun-he-bei-bao-wen-ti/"/>
      <url>/2021/10/08/dong-tai-gui-hua-yi-ri-yi-ti-10-8-hun-he-bei-bao-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="混合背包问题"><a href="#混合背包问题" class="headerlink" title="混合背包问题"></a>混合背包问题</h1><hr><p>有 N种物品和一个容量是 V 的背包。</p><p>物品一共有三类：</p><ul><li>第一类物品只能用1次（01背包）；</li><li>第二类物品可以用无限次（完全背包）；</li><li>第三类物品最多只能用 si次（多重背包）；</li></ul><p>每种体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 N行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。</p><ul><li>si=−1 表示第 i种物品只能用1次；</li><li>si=0 表示第 ii 种物品可以用无限次；</li><li>si&gt;0表示第 i 种物品可以使用 si 次；</li></ul><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N,V≤1000<br>0&lt;vi,wi≤1000<br>−1≤si≤1000</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><pre><code>4 51 2 -12 4 13 4 04 5 2</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>8</code></pre><hr><p>其实从大体上来看，背包问题其实只有01，完全两大问题。对于混合背包，分组背包，多重背包其实就是通过某种优化手段，将其映射到01和完全两大背包类型中。</p><p>例如，此题的混合背包问题，昨天我们做了多重背包问题，不同体积与价值的物品可以有不同的数量。我们采用了一种二进制优化的方法，将多重背包映射成为01背包，然后套用01的模板即可。</p><p>好的 ，那么我们开始举一反三，混合背包可以简化成什么问题。</p><p>我们从数量开始入手，对于有固定容积的背包来说，其实是不存在无穷这一概念的，也就是说物品的无穷相对于优先的背包容积来说，是不存在的。本质上，全是多重背包问题。</p><p>ok，明确了这一点后，我们就可以把此题当做多重背包来做，然后可以用二进制优化的方法进行转化成01背包。</p><p>代码如下：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 10010 ; int f[N] ; int w[N] , v[N] ;int main()&#123;    int n , m ;          cin >> n >> m ;         int cnt = 0 ;         for(int i = 1 ; i <= n ; ++i)    &#123;        int a , b , c ;                 cin >> a >> b >> c ;         if(c == -1)        &#123;            cnt ++ ;            v[cnt] = a  ;             w[cnt] = b ;         &#125;        else if(c == 0)        &#123;            c = m / a ;            int k = 1 ;            while(c >= k )            &#123;                cnt ++ ;                v[cnt] = a * k ;                 w[cnt] = b * k ;                c -= k ;                 k *= 2  ;            &#125;            if (c)            &#123;                cnt ++ ;                v[cnt] = a * c;                 w[cnt] = b * c  ;            &#125;        &#125;        else         &#123;            int k = 1 ;             while(c >= k)            &#123;                cnt ++ ;                v[cnt] = a * k ;                 w[cnt] = b * k ;                c -= k ;                 k *= 2  ;            &#125;            if(c)            &#123;                cnt ++ ;                 v[cnt] = a * c ;                 w[cnt] = b * c ;             &#125;        &#125;    &#125;    n = cnt ;     for(int i = 1 ; i <= n ; ++i)    &#123;        for(int j = m ; j >= v[i] ; --j)        &#123;            f[j] = max(f[j] , f[j-v[i]] + w[i]) ;        &#125;    &#125;    cout << f[m] << endl ;    return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 一日一题 背包dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh相关</title>
      <link href="/2021/10/07/ssh-xiang-guan/"/>
      <url>/2021/10/07/ssh-xiang-guan/</url>
      
        <content type="html"><![CDATA[<h1 id="ssh相关知识点"><a href="#ssh相关知识点" class="headerlink" title="ssh相关知识点"></a>ssh相关知识点</h1><p>一、基本概念</p><p>二、两个作用：</p><p>1.远程登陆自己的server</p><p>(1)将user和hostname省略</p><p>(2)免密登录 可以登录多个server</p><p>2.scp本地与server、server与server之间传输文件</p><p>三、密钥公钥的概念</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划一日一题-10.7-多重背包问题</title>
      <link href="/2021/10/07/dong-tai-gui-hua-yi-ri-yi-ti-10-7-duo-chong-bei-bao-wen-ti/"/>
      <url>/2021/10/07/dong-tai-gui-hua-yi-ri-yi-ti-10-7-duo-chong-bei-bao-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h1><hr><p>有 N 种物品和一个容量是 V 的背包。</p><p>第 i 种物品最多有 si件，每件体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 N行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i种物品的体积、价值和数量。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N,V≤100<br>0&lt;vi,wi,si≤100</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><pre><code>4 51 2 32 4 13 4 34 5 2</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>10</code></pre><hr><p>综合前面两个来看，相比于01背包是单纯的只有一个，完全背包是可以有无穷多个来看，多重背包就像是前面两种的综合。更加符合实际情况，不同体积与价值的物品有不同的数量。</p><p>于是，综合前面两个的dp表示以及dp转移方式，可以自然而然的想到可以在完全背包的时候，我们第一次所使用的三次循环的方式。因为这里的数据不是非常强。所以三次循环是不会TLE的。</p><h2 id="最朴素的代码如下"><a href="#最朴素的代码如下" class="headerlink" title="最朴素的代码如下:"></a>最朴素的代码如下:</h2><pre class="line-numbers language-c++"><code class="language-c++">//极其朴素做法#include <bits/stdc++.h>using namespace std ;const int N = 110 ; int f[N][N] ; int w[N] , v[N] ,s[N]; int main()&#123;    int n , m ;     cin >> n >> m ;     for(int i = 1 ; i <= n ; ++i)    &#123;        cin >> v[i] >> w[i] >> s[i] ;     &#125;        int i , j , k ;         for(i = 1 ; i <= n ; ++i)    &#123;        for(j = 1 ; j <= m ; ++j )        &#123;            f[i][j] = f[i-1][j] ;                         for(k = 1 ; k <= s[i] && j >= k*v[i] ; ++k)            &#123;                f[i][j] = max(f[i][j] , f[i-1][j-k*v[i]] + k * w[i]) ;            &#125;        &#125;    &#125;    cout << f[n][m] << endl ;    return 0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种做法在这种强度的数据面前是可以过的，但是一旦数据到达了1000，这样的循环直接就GG了。</p><p>我们又来考虑一下，是否有可以将三次循环优化成两次的方法，唉，没错，我们又想到了完全背包问题的优化，他是根据递推公式进行优化的。</p><p>亦或者是根据有穷性的特性将多重背包问题转化成01背包问题，即为二进制优化。</p><p>先上代码。之后，我会解释二进制为什么可行？优化在什么地方？为什么会想到二进制来进行优化？是否还会有更好的优化方法？</p><h2 id="二进制优化"><a href="#二进制优化" class="headerlink" title="二进制优化"></a>二进制优化</h2><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 10010 ; int f[N]  ; int v[N] , w[N]; int main()&#123;    int n , m  ;        int cnt = 0 ;       cin >> n >> m ;         for(int i = 1 ; i <= n ; ++i)    &#123;        int a , b , c ;                 cin >> a >> b >> c ;                 int k = 1 ;         while(c >= k )        &#123;            cnt ++ ;            v[cnt] = a * k ;             w[cnt] = b * k ;             c -= k ;             k *= 2 ;         &#125;        if(c > 0)        &#123;            cnt ++ ;            v[cnt] = a * c ;             w[cnt] = b * c  ;        &#125;    &#125;        n = cnt ;     for(int i = 1 ; i <= n ; ++i)    &#123;        for(int j = m ; j >=v[i] ; --j)        &#123;            f[j] = max(f[j] , f[j-v[i]] + w[i]) ;        &#125;    &#125;        cout << f[m] << endl ;         return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用STL是这样的"><a href="#使用STL是这样的" class="headerlink" title="使用STL是这样的"></a>使用STL是这样的</h2><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 10010 ; vector < pair <int ,int> > vc ;  int f[N] ;int main()&#123;    int n , m ;     cin >> n >> m ;         for(int i = 1 ; i <= n ; ++i)    &#123;        int a , b ,c ;         cin >> a >> b >> c ;        int k = 1 ;         while(c >= k )        &#123;            vc.push_back(&#123;a*k , b*k&#125;) ;            c -= k ;              k *= 2 ;         &#125;                 if(c > 0)        &#123;            vc.push_back(&#123;c*a , c*b&#125;) ;        &#125;    &#125;           for(auto num : vc)   &#123;       for(int j  = m;  j >= num.first ;--j)       &#123;               f[j] = max(f[j] , f[j-num.first]+num.second) ;        &#125;   &#125;        cout << f[m] << endl  ;    return 0  ;     &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二进制优化的思路："><a href="#二进制优化的思路：" class="headerlink" title="二进制优化的思路："></a>二进制优化的思路：</h2><p>1.明确一个思想，例如一堆数字，1，2，4，8，16，32，64……可以用来表示1~128的任何一个数字。</p><p>所以对于多重背包问题，对于他的价值和体积来说，我们可以使用二进制将其拆解成一些子项。这样在朴素暴力的时候，我们是一个一个遍历的，但是二进制的时候，我们可以通过选取其中的一些值来达到之前需要选取多个同样体积与价值的累加的效果。</p><h4 id="当然，你也可以直接将过程理解成这样一个故事-估计会方便理解一些-："><a href="#当然，你也可以直接将过程理解成这样一个故事-估计会方便理解一些-：" class="headerlink" title="当然，你也可以直接将过程理解成这样一个故事(估计会方便理解一些)："></a>当然，你也可以直接将过程理解成这样一个故事(估计会方便理解一些)：</h4><p>我们想要从我们以前做过的题目中寻求思路，但是我们只写过01背包呀。唉！！正好，这些也是正好是有穷个数的物品，我们完全可以将其拆成一个一个的，但是你会发现，不行哎，没卵用，因为它仍然是一个个的，同之前的暴力做法不是一样的吗？？？(我是sb)</p><p>于是，我就在百度上或者是google上搜索，将一个大数如何可以拆解成很多小数，同时可以表示一段范围内的任意一个实数，唉，这时候你突然看到了，可以用二进制进行优化。</p><p>2.将有限个固定体积与价值的东西通过二进制累加变成不同体积与价值但是数量为1的物品，就转变成了01背包问题，然后套用01背包的模板即可。</p><p>所以优化在什么地方呢？</p><p>从时间复杂度来看，朴素做法的时间复杂度为O(mns) 。经过二进制优化后为O(2mnlogs).</p><p>其实就是相当于本来有n个东西，你需要一个个来看，但是通过二进制优化，我们可以用lgn的东西来进行表示。其实对于代码来说，循环的次数是没有发生变化的，只是做选择的次数由n变成lgn了。</p><p>这时候，提一句，</p><p>对于dp来说，dp的时间复杂度可以简单理解为</p><pre><code>dp的时间复杂度 == 问题的个数 * 问题选项的个数</code></pre><p>对了，还可以用dequeue，也就是单调队列进行优化，过一段时间在更……….</p>]]></content>
      
      
      
        <tags>
            
            <tag> 一日一题 背包dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划一日一题-10.6-完全背包问题</title>
      <link href="/2021/10/06/dong-tai-gui-hua-yi-ri-yi-ti-10-6-wan-quan-bei-bao-wen-ti/"/>
      <url>/2021/10/06/dong-tai-gui-hua-yi-ri-yi-ti-10-6-wan-quan-bei-bao-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h1><hr><p>有 N种物品和一个容量是 V的背包，每种物品都有无限件可用。</p><p>第 i种物品的体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 N行，每行两个整数 vi,wi，用空格隔开，分别表示第 i种物品的体积和价值。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N,V≤1000<br>0&lt;vi,wi≤1000</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><pre><code>4 51 22 43 44 5</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>10</code></pre><hr><p>我们会根据01背包自然而然的想到会用三次循环，但是这里的数据是1000，三次循环很显然会TLE。</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 1010 ; int f[N][N] ;int w[N] , v[N]  ;int main()&#123;    int n , m ;         cin >> n >> m ;         for(int i = 1 ; i <= n ; i++)    &#123;        cin >> v[i] >> w[i] ;     &#125;        for(int i = 1 ; i <= n  ; ++i)    &#123;        for(int j = 1 ; j <= m ; ++j)        &#123;            f[i][j] = f[i-1][j] ;             for(int 1 = 0 ; j - v[i] * k >= 0 ; k++)            &#123;                f[i][j] = max(f[i][j] , f[i-1][j-k*v[i]] + k*w[i]) ;            &#125;        &#125;    &#125;    cout << f[i][j] << endl ;    return 0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以我们后面开始考虑用二轮循环进行优化 。 </p><p>状态表示：同01背包问题，dp[i] [j] 表示的是，使用前i个物品并且体积不超过j的所能够实现的最大价值。</p><p>状态属性：max</p><p>base case：同01背包问题</p><p>状态转移：这可以通过小学数学来进行一个推导。</p><pre><code>f[i][j] = max(f[i-1][j] , f[i-1][j-v[i]] + w[i] , f[i-1][j-2*v[i]] + 2*w[i] + .....)f[i][j-v[i]] = max(f[i-1][j-v[i]] , f[i-1][j-2*v[i]]+2*w[i] + .....)//所以由一式与二式相消可知f[i][j] = max(f[i-1][j] , f[i][j-v[i]]+ w[i]) ;</code></pre><h2 id="错误的做法："><a href="#错误的做法：" class="headerlink" title="错误的做法："></a>错误的做法：</h2><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 1010 ;int f[N][N] ;int w[N] , v[N] ;int main()&#123;     int n , m ;         cin >> n >> m  ;         for(int i = 1 ; i <= n ; ++i)    &#123;        cin >> v[i] >> w[i] ;     &#125;        for(int i = 1 ; i <= n  ;++i)    &#123;        for(int j = 1 ; j <= m ; ++j)        &#123;            if(j >= v[i])            &#123;                f[i][j] = max(f[i-1][j] , f[i][j-v[i]]+w[i]) ; // 注意这样写是错的，这样会导致当j< v[i]的时候，没有东西进行迭代            &#125;        &#125;    &#125;    cout << f[n][m] << endl ;    return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="正确的做法："><a href="#正确的做法：" class="headerlink" title="正确的做法："></a>正确的做法：</h2><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 1010 ;int f[N][N] ;int w[N] , v[N] ;int main()&#123;     int n , m ;         cin >> n >> m  ;         for(int i = 1 ; i <= n ; ++i)    &#123;        cin >> v[i] >> w[i] ;     &#125;        for(int i = 1 ; i <= n  ;++i)    &#123;        for(int j = 1 ; j <= m ; ++j)        &#123;            f[i][j] = f[i-1][j] ;             if(j >= v[i])            &#123;                f[i][j] = max(f[i][j] , f[i][j-v[i]]+w[i]) ;             &#125;        &#125;    &#125;    cout << f[n][m] << endl ;    return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>形同01背包问题，由于完全背包问题也仅仅是用到了前一轮的值，所以我们完全可以进行一维的优化。</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 1010 ; int w[N] , v[N] ; int f[N] ; int main()&#123;    int n , m ;        cin >> n >> m ;             for(int i = 1 ; i <= n ; ++i)    &#123;        cin >> v[i] >> w[i] ;     &#125;            for(int i = 1 ; i <= n ; ++i)    &#123;        for(int j = v[i] ; j <= m ; ++j)        &#123;            f[j] = max(f[j] , f[j-v[i]]+w[i]) ;        &#125;    &#125;        cout << f[m] << endl ;        return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有的人肯定又会进行纠结，纠结的点就是在于j的循环顺序的问题，为什么这一次的j就是由小到大进行穷举的呢？</p><p>我们说一维的运算其实就是对二维的简化(这…. 好像是说了一句废话…..)，其实意思就是一维的逻辑就是二维的逻辑。我们反过来看二维的dp转移方程就知道了。</p><pre><code>f[i][j] = max(f[i-1][j] , f[i][j-v[i]]+w[i]) ;</code></pre><p>我们发现对于f[i-1] [j]来说，一维的毋庸置疑就是上一轮遗留下来的，对于f[i] [j-v[i]] + w[i] 来说，在一维的状态下必须是由该轮转移下来的，所以必须由小到大进行列举，小的赋值完了之后，才轮到大的进行赋值。</p><p>其实完全背包问题可以延申很多，例如我们之前说过的，整数划分问题。就可以理解为是一种完全背包问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 一日一题 背包dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL算法详解</title>
      <link href="/2021/10/05/stl-suan-fa-xiang-jie/"/>
      <url>/2021/10/05/stl-suan-fa-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="C-STL详解-建议收藏！！！"><a href="#C-STL详解-建议收藏！！！" class="headerlink" title="C++ STL详解(建议收藏！！！)"></a>C++ STL详解(建议收藏！！！)</h1><p>本蒟蒻写这篇分享的目的一个是为了写一个归纳总结方便自己以后随时能够复习还有就是给那些对STL还不是很了解的萌新介绍一下什么是STL以及如何使用STL更高效(偷懒)地解题。本篇文章将会长期更新<del>欢迎大家一起监督学习</del>有错误的地方或者需要补充的欢迎在评论区留言哦~</p><h2 id="一、什么是STL"><a href="#一、什么是STL" class="headerlink" title="一、什么是STL?"></a>一、什么是STL?</h2><p>STL(Standard Template Library，标准模板库)，是惠普实验室开发的一系列软件的统称。现主要出现在C++中，STL从广义上分为：容器(container)、算法(algorithm)和迭代器(iterator)。STL几乎所有的代码都采用了模板类或者模板函数，这相比传统的由函数和类组成的库来说提供了更好的代码重用机会。</p><h2 id="二、STL六大组件是什么"><a href="#二、STL六大组件是什么" class="headerlink" title="二、STL六大组件是什么?"></a>二、STL六大组件是什么?</h2><p>STL提供了六大组件，彼此之间可以组合套用，这六大组件分别是容器、算法、迭代器、仿函数、适配器、空间配置器。其中，在算法竞赛中用到最多的为容器、算法与迭代器。</p><p>容器(Container)：STL容器为各种数据结构，如vector、stack、queue、map、set等，用来存放数据，从实现角度来看，STL容器是一种class template。<br>算法(Algorithm)：STL的算法多数定义在<algorithm>头文件中，其中包括了各种常用的算法，如sort、find、copy、reverse等，从实现角度来看，STL算法是一种function template。<br>迭代器(Iterator)：STL迭代器扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将opetator*、opetator-&gt;、operator++等指针相关操作予以重载的class template。所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。<br>仿函数(Functor)：行为类似函数，可作为算法的某种策略，从实现角度来看，仿函数是一种重载了operator()的class或者class template。<br>适配器(Adaptor)：一种用来修饰容器或仿函数或迭代器接口的东西。<br>空间配置器(Allocator)：负责空间的配置与管理。从实现角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。</p><h2 id="三、STL容器详解"><a href="#三、STL容器详解" class="headerlink" title="三、STL容器详解"></a>三、STL容器详解</h2><p>相信很多人学习STL就是为了在比赛中能够更好地装B运用各种数据结构和算法，提高解题速度。确实，使用STL中的容器能够不需要自己手写定义各种数据结构，使用STL中的算法能够不需要自己手写实现各种基本算法，因此本部分对于算法巨巨们是最为重要的一部分，那么STL容器究竟有哪些呢?在做题中该如何使用呢?</p><h3 id="①-vector："><a href="#①-vector：" class="headerlink" title="① vector："></a>① vector：</h3><p>又称变长数组，定义在<vector>头文件中，vector容器是动态空间，随着元素的加入，它的内部机制会自动扩充空间以容纳新的元素。因此vector的运用对于内存的合理利用与运用的灵活性有很大的帮助。</p><p>vector的定义方式<br>    vector<int> v;//定义一个vector，其中的元素为int类型<br>    vector<int> v[N];//定义一个vector数组，其中有N个vector<br>    vector<int> v(len);//定义一个长度为len的vector<br>    vector<int> v(len, x);//定义一个长度为len的vector，初始化每个元素为x<br>    vector<int> v2(v1);//用v1给v2赋值，v1的类型为vector<br>    vector<int> v2(v1.begin(), v1.begin() + 3);//将v1中第0~2三个元素赋值给v2<br>vector的常用内置函数<br>    //vector中的常用内置函数<br>    vector<int> v = { 1, 2, 3 };//初始化vector，v:{1, 2, 3}<br>    vector<int>::iterator it = v.begin();//定义vector的迭代器，指向begin()</p><pre><code>v.push_back(4);//在vector的尾部插入元素4，v:&#123;1, 2, 3, 4&#125;v.pop_back();//删除vector的最后一个元素，v:&#123;1, 2, 3&#125;v.size();//返回vector中元素的个数v.empty();//返回vector是否为空，若为空则返回true否则返回falsev.front();//返回vector中的第一个元素v.back();//返回vector中的最后一个元素v.begin();//返回vector第一个元素的迭代器v.end();//返回vector最后一个元素后一个位置的迭代器v.clear();//清空vectorv.erase(v.begin());//删除迭代器it所指向的元素v.insert(v.begin(), 1);//在迭代器it所指向的位置前插入元素1//根据下标进行遍历for (int i = 0; i &lt; v.size(); i++)    cout &lt;&lt; v[i] &lt;&lt; &#39; &#39;;//使用迭代器遍历for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)    cout &lt;&lt; *it &lt;&lt; &#39; &#39;;//for_each遍历(C++11)for (auto x : v)    cout &lt;&lt; x &lt;&lt; &#39; &#39;;</code></pre><h3 id="②stack："><a href="#②stack：" class="headerlink" title="②stack："></a>②stack：</h3><p>又称栈，是一种后进先出(Last In First Out，LIFO)的数据结构，定义在<stack>头文件中，stack容器允许新增元素、移除元素、取得栈顶元素，但是除了最顶端以外，没有任何方法可以存取stack的其它元素，换言之，stack不允许有遍历行为。</p><p>stack的定义方式<br>    stack<int> stk;//定义一个stack，其中元素的类型为int<br>    stack<int> stk[N];//定义一个stack数组，其中有N个stack<br>stack的常用内置函数<br>    //stack中的常用内置函数<br>    stack<int> stk;<br>    stk.push(x);//在stack中插入元素x<br>    stk.pop();//弹出stack的栈顶元素<br>    stk.top();//返回stack的栈顶元素<br>    stk.size();//返回stack中元素的个数<br>    stk.empty();//返回stack是否为空，若为空则返回true否则返回false</p><h3 id="③string："><a href="#③string：" class="headerlink" title="③string："></a>③string：</h3><p>又称字符串，定义在<string>头文件中。C风格的字符串(以空字符结尾的字符数组)太过复杂难于掌握，因此C++标准库定义了一种string类。string玩得好，天梯和蓝桥拿个国奖真的有手就行，去年我刚大二的时候从零开始学算法，两个星期没学多少只学了string，校选拔就进前几了，后来的国赛也拿了点小奖(ACM就被打爆了)。因此熟练地运用string还是很重要滴~</p><p>string的定义方式<br>    string str;//定义一个空的字符串<br>    string str[N];//定义一个string数组，其中有N个string<br>    string str(5, ‘a’);//使用5个字符’a’初始化<br>    string str(“abc”);//使用字符串初始化<br>string的常用内置函数<br>    //string中的常用内置函数<br>    string str(“abcabc”);<br>    str.push_back(‘d’);//在string尾部插入字符，”abcabcd”<br>    str.pop_back();//删除string尾部的字符，”abcabc”<br>    str.length();//返回string中字符的个数<br>    str.size();//作用与length()相同<br>    str.empty();//返回string是否为空，若为空返回true否则返回false<br>    str.substr(1);//返回string中从下标为1开始至末尾的子串，”bc”<br>    str.substr(0, 2);//返回string中从下标为0开始长度为2的子串，”ab”<br>    str.insert(1, 2, ‘x’);//在下标为1的字符前插入2个字符’x’，”axxbcabc”<br>    str.insert(1, “yy”);//在下标为1的字符前插入字符串”yy”，”ayyxxbcabc”<br>    str.erase(1, 4);//删除从位置1开始的4个字符，”abcabc”<br>    str.find(‘b’);//返回字符’b’在string中第一次出现的位置，返回1<br>    str.find(‘b’, 2);//返回从位置2开始字符’b’在string中第一次出现的位置，返回4<br>    str.find(“bc”);//同上，返回字符串第一次出现的位置，返回1<br>    str.find(“bc”, 2);//返回4<br>    str.rfind(‘b’);//反向查找，原理同上，返回4<br>    str.rfind(‘b’, 3);//返回1<br>    str.rfind(“bc”);//返回4<br>    str.rfind(“bc”, 3);//返回1<br>    str[0];//用下标访问string中的字符<br>    cout &lt;&lt; (str == str) &lt;&lt; endl;//string可比较大小，按字典序<br>string的erase()与remove()函数的用法<br>    //string中erase()与remove()的用法<br>    string str1, str2, str3, str4, str5;<br>    str1 = str2 = str3 = str4 = str5 = “I love AcWing! It’s very funny!”;<br>    str1.erase(15);//删除[15,end())的所有元素，”I love AcWing!”<br>    str2.erase(6, 11);//从第6个元素(包括)开始往后删除11个元素，”I love’s very funny!”<br>    str3.erase(str3.begin() + 2);//删除迭代器所指的元素，”I ove AcWing! It’s very funny!”<br>    str4.erase(str4.begin() + 7, str4.end() - 11);//删除[str4.begin()+7,str4.end()-11)的所有元素，”I love very funny!”<br>    str5.erase(remove(str5.begin(), str5.end(), ‘n’), str5.end());//删除[str5.begin(),str5.end())中所有字符’n’，”I love AcWig! It’s very fuy!”</p><h3 id="④queue："><a href="#④queue：" class="headerlink" title="④queue："></a>④queue：</h3><p>又称队列，是一种先进先出(First In First Out，FIFO)的数据结构，定义在<queue>头文件中，queue容器允许从一端(称为队尾)新增元素(入队)，从另一端(称为队头)移除元素(出队)。</p><h3 id="⑤priority-queue："><a href="#⑤priority-queue：" class="headerlink" title="⑤priority_queue："></a>⑤priority_queue：</h3><p>又称优先队列，同样定义在<queue>头文件中，与queue不同的地方在于我们可以自定义其中数据的优先级，优先级高的排在队列前面，优先出队。priority_queue具有queue的所有特性，包括基本操作，只是在这基础上添加了内部的一个排序，它的本质是用堆实现的，因此可分为小根堆与大根堆，小根堆中较小的元素排在前面，大根堆中较大的元素排在前面。注意：创建priority_queue时默认是大根堆！</p><p>queue的定义方式<br>    queue<int> que;//定义一个queue，其中元素的类型为int<br>    queue<int> que[N];//定义一个queue数组，其中有N个queue<br>    priority_queue<int> smallHeap;//定义一个小根堆<br>    priority_queue&lt;int, vector<int>, greater<int> &gt; bigHeap;//定义一个大根堆<br>queue的常用内置函数<br>    //queue中的常用内置函数<br>    queue<int> que;<br>    que.push(x);//在queue的队尾插入元素x<br>    que.pop();//出队queue的队头元素<br>    que.front();//返回queue的队头元素<br>    que.back();//返回queue的队尾元素<br>    que.size();//返回stack中元素的个数<br>    que.empty();//返回stack是否为空，若为空则返回true否则返回false</p><h3 id="⑥deque："><a href="#⑥deque：" class="headerlink" title="⑥deque："></a>⑥deque：</h3><p>又称双端队列，定义在<deque>头文件中，vector容器是单向开口的连续内存空间，deque则是一种双向开口的连续线性空间。所谓的双向开口，意思是可以在头尾两端分别做元素的插入和删除操作，当然，vector也可以在头尾两端插入元素，但是在其头部进行插入操作效率奇差，无法被接受。deque和vector最大的差异一是在于deque允许使用常数项时间在头部进行元素的插入和删除操作，二是在于deque没有容量的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。</p><p>deque的定义方式<br>    deque<int> deq;//定义一个deque，其中的元素为int类型<br>    deque<int> deq[N];//定义一个deque数组，其中有N个deque<br>    deque<int> deq(len);//定义一个长度为len的deque<br>    deque<int> deq(len, x);//定义一个长度为len的deque，初始化每个元素为x<br>    deque<int> deq2(deq1);//用deq1给v2赋值，deq2的类型为deque<br>    deque<int> deq2(deq1.begin(), deq1.begin() + 3);//将deq1中第0~2三个元素赋值给deq2<br>deque的常用内置函数<br>    //deque中的常用内置函数<br>    deque<int> deq = { 1, 2, 3 };//初始化vector，v:{1, 2, 3}<br>    deque<int>::iterator it = deq.begin();//定义vector的迭代器，指向begin()</p><pre><code>deq.push_back(4);//在deque的尾部插入元素4，v:&#123;1, 2, 3, 4&#125;deq.pop_back();//删除deque的尾部元素，v:&#123;1, 2, 3&#125;deq.push_front(4);//在deque的头部插入元素4，v:&#123;4, 1, 2, 3&#125;deq.pop_front();//删除deque的头部元素，v:&#123;1, 2, 3&#125;deq.size();//返回vector中元素的个数deq.empty();//返回vector是否为空，若为空则返回true否则返回falsedeq.front();//返回vector中的第一个元素deq.back();//返回vector中的最后一个元素deq.begin();//返回vector第一个元素的迭代器deq.end();//返回vector最后一个元素后一个位置的迭代器deq.clear();//清空vectordeq.erase(deq.begin());//删除迭代器it所指向的元素deq.insert(deq.begin(), 1);//在迭代器it所指向的位置前插入元素1//根据下标进行遍历for (int i = 0; i &lt; deq.size(); i++)    cout &lt;&lt; deq[i] &lt;&lt; &#39; &#39;;//使用迭代器遍历for (deque&lt;int&gt;::iterator it = deq.begin(); it != deq.end(); it++)    cout &lt;&lt; *it &lt;&lt; &#39; &#39;;//for_each遍历(C++11)for (auto x : deq)    cout &lt;&lt; x &lt;&lt; &#39; &#39;;</code></pre><h3 id="⑦map-multimap："><a href="#⑦map-multimap：" class="headerlink" title="⑦map/multimap："></a>⑦map/multimap：</h3><p>又称映射，定义在<map>头文件中，map和multimap的底层实现机制都是红黑树。map的功能是能够将任意类型的元素映射到另一个任意类型的元素上，并且所有的元素都会根据元素的键值自动排序。map所有的元素都是pair，同时拥有实值和键值，pair的第一元素被视为键值，第二元素被视为实值，map不允许两个元素有相同的键值。multimap和map的操作类似，唯一区别是multimap的键值允许重复。</p><p>map/multimap的定义方式<br>    map&lt;string, int&gt; mp;//定义一个将string映射成int的map<br>    map&lt;string, int&gt; mp[N];//定义一个map数组，其中有N个map<br>    multimap&lt;string, int&gt; mulmp;//定义一个将string映射成int的multimap<br>    multimap&lt;string, int&gt; mulmp[N];//定义一个multimap数组，其中有N个multimap<br>map/multimap的常用内置函数<br>    //map/multimap中的常用内置函数<br>    map&lt;string, int&gt; mp;<br>    mp[“abc”] = 3;//将”abc”映射到3<br>    mp[“ab”]++;//将”ab”所映射的整数++<br>    mp.insert(make_pair(“cd”, 2));//插入元素<br>    mp.insert({ “ef”, 5 });//同上<br>    mp.size();//返回map中元素的个数<br>    mp.empty();//返回map是否为空，若为空返回true否则返回false<br>    //mp.clear();//清空map<br>    mp.erase(“ef”);//清除元素{“ef”, 5}<br>    mp[“abc”];//返回”abc”映射的值<br>    mp.begin();//返回map第一个元素的迭代器<br>    mp.end();//返回map最后一个元素后一个位置的迭代器<br>    mp.lower_bound(“abc”);//返回第一个键值大于等于”abc”的元素的迭代器，{“abc”, 3}<br>    mp.upper_bound(“abc”);//返回第一个键值大于”abc”的元素的迭代器，{“cd”, 2}</p><pre><code>//使用迭代器遍历for (map&lt;string, int&gt;::iterator it = mp.begin(); it != mp.end(); it++)    cout &lt;&lt; (*it).first &lt;&lt; &#39; &#39; &lt;&lt; (*it).second &lt;&lt; endl;//for_each遍历(C++11)for (auto x : mp)    cout &lt;&lt; x.first &lt;&lt; &#39; &#39; &lt;&lt; x.second &lt;&lt; endl;//扩展推断范围的for_each遍历(C++17)for (auto &amp;[k, v] : mp)    cout &lt;&lt; k &lt;&lt; &#39; &#39; &lt;&lt; v &lt;&lt; endl;</code></pre><h3 id="⑧set-multiset："><a href="#⑧set-multiset：" class="headerlink" title="⑧set/multiset："></a>⑧set/multiset：</h3><p>又称集合，定义在<set>头文件中。set的特性是所有元素都会根据元素的键值自动被排序，set的元素不像map那样可以同时拥有实值和键值，set的元素既是键值又是实值，set不允许两个元素有相同的键值，因此总结来说就是set中的元素是有序且不重复的。multiset的特性和用法和set完全相同，唯一的区别在于multiset允许有重复元素，set和multiset的底层实现都是红黑树。</p><p>set/multiset的定义方式<br>    set<int> st;//定义一个set，其中的元素类型为int<br>    set<int> st[N];//定义一个set数组，其中有N个set<br>    multiset<int> mulst;//定义一个multiset<br>    multiset<int> mulst[N];//定义一个multiset数组，其中有N个multiset<br>set/multiset的常用内置函数<br>    //set/multiset中的常用内置函数<br>    set<int> st;<br>    st.insert(5);//插入元素5<br>    st.insert(6);//同上<br>    st.insert(7);//同上<br>    st.size();//返回set中元素的个数<br>    st.empty();//返回set是否为空，若为空返回true否则返回false<br>    st.erase(6);//清除元素6<br>    st.begin();//返回set第一个元素的迭代器<br>    st.end();//返回set最后一个元素后一个位置的迭代器<br>    st.clear();//清空set<br>    st.lower_bound(5);//返回第一个键值大于等于5的元素的迭代器，返回元素5的迭代器<br>    st.upper_bound(5);//返回第一个键值大于5的元素的迭代器，返回元素7的迭代器</p><pre><code>//使用迭代器遍历for (set&lt;int&gt;::iterator it = st.begin(); it != st.end(); it++)    cout &lt;&lt; (*it) &lt;&lt; &#39; &#39;;//for_each遍历(C++11)for (auto x : st)    cout &lt;&lt; x &lt;&lt; &#39; &#39;;</code></pre><h3 id="⑨unordered-map-unordered-set："><a href="#⑨unordered-map-unordered-set：" class="headerlink" title="⑨unordered_map/unordered_set："></a>⑨unordered_map/unordered_set：</h3><p>分别定义在<unordered_map>与<unordered_set>头文件中，内部采用的是hash表结构，拥有快速检索的功能。与map/set相比最大的区别在于unordered_map/unordered_set中的元素是无序的，增删改查的时间复杂度为O(1)(map/set增删改查的时间复杂度为O(logn))，但是不支持lower_bound()/upper_bound()函数。</p><p>unordered_map/unordered_set的定义方式<br>    unordered_set<int> st;//定义一个unordered_set，其中的元素类型为int<br>    unordered_set<int> st[N];//定义一个unordered_set数组，其中有N个unordered_set<br>    unordered_map&lt;int, int&gt; mp;//定义一个unordered_map<br>    unordered_map&lt;int, int&gt; mp[N];//定义一个unordered_map数组，其中有N个unordered_map<br>unordered_map/unordered_set的常用内置函数<br>    //unordered_map/unordered_set中的常用内置函数<br>    unordered_set<int> st;<br>    unordered_map&lt;int, int&gt; mp;<br>    st.insert(5);//插入元素5<br>    st.insert(6);//同上<br>    st.insert(7);//同上<br>    st.size();//返回unordered_set中元素的个数<br>    st.empty();//返回unordered_set是否为空，若为空返回true否则返回false<br>    st.erase(6);//清除元素6<br>    st.begin();//返回unordered_set第一个元素的迭代器<br>    st.end();//返回unordered_set最后一个元素后一个位置的迭代器<br>    st.clear();//清空unordered_set<br>    mp.insert(make_pair(1, 2));//插入元素{1, 2}<br>    mp.insert({ 3, 4 });//同上<br>    mp.size();//返回unordered_map中元素的个数<br>    mp.empty();//返回unordered_map是否为空，若为空返回true否则返回false<br>    mp.erase(3);//清除元素{3, 4}<br>    mp.begin();//返回unordered_map第一个元素的迭代器<br>    mp.end();//返回unordered_map最后一个元素后一个位置的迭代器<br>    mp.clear();//清空unordered_map</p><pre><code>//使用迭代器遍历for (unordered_set&lt;int&gt;::iterator it = st.begin(); it != st.end(); it++)    cout &lt;&lt; (*it) &lt;&lt; &#39; &#39;;//for_each遍历(C++11)for (auto x : st)    cout &lt;&lt; x &lt;&lt; &#39; &#39;;//使用迭代器遍历for (unordered_map&lt;int, int&gt;::iterator it = mp.begin(); it != mp.end(); it++)    cout &lt;&lt; (*it).first &lt;&lt; &#39; &#39; &lt;&lt; (*it).second &lt;&lt; endl;//for_each遍历(C++11)for (auto x : mp)    cout &lt;&lt; x.first &lt;&lt; &#39; &#39; &lt;&lt; x.second &lt;&lt; endl;//扩展推断范围的for_each遍历(C++17)for (auto &amp;[k, v] : mp)    cout &lt;&lt; k &lt;&lt; &#39; &#39; &lt;&lt; v &lt;&lt; endl;</code></pre><h2 id="四、STL算法详解"><a href="#四、STL算法详解" class="headerlink" title="四、STL算法详解"></a>四、STL算法详解</h2><p>C++标准库定义了一组泛型算法，之所以称为泛型指的是它们可以操作在多种容器上，不但可以作用于标准库类型，还可以用在内置数组类型甚至其它类型的序列上。泛型算法定义在<algorithm>头文件中，标准库还定义了一组泛化的算术算法(Generalized Numeric Algorithm)，定义在<numeric>头文件中。</p><p>作者：AsanoSaki<br>链接：<a href="https://www.acwing.com/blog/content/10558/">https://www.acwing.com/blog/content/10558/</a><br>来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 好资源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划一日一题-10.5-01背包问题</title>
      <link href="/2021/10/05/dong-tai-gui-hua-yi-ri-yi-ti-10-5-01-bei-bao-wen-ti/"/>
      <url>/2021/10/05/dong-tai-gui-hua-yi-ri-yi-ti-10-5-01-bei-bao-wen-ti/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h1><p>有 N 件物品和一个容量是 V的背包。每件物品只能使用一次。</p><p>第 i件物品的体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N,V≤1000<br>0&lt;vi,wi≤1000</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><pre><code>4 51 22 43 44 5</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>8</code></pre><hr><p>还是用之前的分析方法来分析：</p><p>状态表示：f[i] [j] 表示使用前i个物品，且总体积不大于j的时候，所实现的最大价值</p><p>状态属性：max</p><p>base case：f[i] [0] = 0 ; f[0]  [i] = 0 (因为此题的base case来说，我们申请dp数组的时候就是申请的全局变量，默认值直接是0，所以这一题的base case没有显性的展现出来)。</p><p>状态转移：分成两块，任何状态都可以分成两个状态，一是不使用第i个物品，二是使用第i件物品。分隔条件是v[i] 与j的大小关系。</p><p>代码如下：</p><pre class="line-numbers language-c++"><code class="language-c++">#include<bits/stdc++.h>using namespace std ;const int N = 1010 ; int f[N][N] ;int w[N] , v[N] ;int main()&#123;    int n , m ;         cin >> n >> m ;         for(int i = 1 ; i <= n ; ++i)    &#123;        cin >> v[i] >> w[i] ;    &#125;            for(int i = 1 ; i <= n ; ++i)    &#123;        for(int j = 1 ; j <= m ;++j)        &#123;            f[i][j] = f[i-1][j] ;            if(v[i] <= j)            &#123;                f[i][j] = max(f[i][j] , f[i-1][j-v[i]]  + w[i]) ;            &#125;        &#125;    &#125;    cout << f[n][m] << endl ;    return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>仔细阅读上述代码之后，我们发现可以采用一维数组进行优化。因为i在这题来说，可以根据循环的由小到大的次序进行省略。</p><p>其中有一个比较难理解的点就是，对于二层循环的j来说，不应该是有小到大进行穷举，而是应该是由大到小进行穷举，因为对于二维代码来说，有一个i用来指向此时的j是上一次的循环的还是下一次循环的，状态转移是由上一次循环转移来的，所以不管j是大还是小，都是上一次循环来赋值的。但是对于一维的dp数组来说，没有i作为指向，必须通过j的列举顺序来体现是上一轮循环的状态转移。</p><p>当然，最简单的理解就是一维的dp方法必须要满足二维的dp方法的逻辑思路。所以对于j的列举顺序必须满足，f[j]的状态必须是上次循环中j的值比现在小的dp值转移过来的。</p><p>所以，根据这一条原则，j如果不变化，仍然是由小到大进行列举的话，虽然是由比自己小的j的dp值转移过来的，但是这些值都是由本轮循环进行迭代之后得到的值，并不是上一轮循环所遗留下来的，这就导致了逻辑出现了错误。</p><p>优化空间后的代码如下：</p><pre class="line-numbers language-c++"><code class="language-c++">#include<bits/stdc++.h>using namespace std ;const int N = 1010 ; int f[N] ;int w[N] , v[N] ;int main()&#123;    int n , m ;         cin >> n >> m ;         for(int i = 1 ; i <= n ; ++i)    &#123;        cin >> v[i] >> w[i] ;    &#125;            for(int i = 1 ; i <= n ; ++i)    &#123;        for(int j = m ; j >= 0 ; --j)        &#123;            if(v[i] <= j)            &#123;                f[j] = max(f[j] , f[j-v[i]]  + w[i]) ;            &#125;        &#125;    &#125;        cout << f[m] << endl ;        return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 一日一题 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器删除的大坑</title>
      <link href="/2021/10/04/die-dai-qi-shan-chu-de-da-keng/"/>
      <url>/2021/10/04/die-dai-qi-shan-chu-de-da-keng/</url>
      
        <content type="html"><![CDATA[<h1 id="迭代器删除的坑"><a href="#迭代器删除的坑" class="headerlink" title="迭代器删除的坑"></a>迭代器删除的坑</h1><p>今天在字符串定点删除固定元素的时候，出现了大问题，百思不得其解。</p><p>题目简单描述是这样的：</p><hr><p>给定一个字符串str,targe元素是‘a’，通过erase方法进行删除</p><p>代码是这样的:</p><pre class="line-numbers language-c++"><code class="language-c++">#include<bits/stdc++.h>using namespace std ;int main()&#123;    string str = "ahsdjkafbnaasdfjkanasjkdfbhjasddkaldfasa" ;         for(auto it = str.begin() ;  it != str.end() ;  ++ it)    &#123;        if(*it == 'a')        &#123;            str.erase(it) ;        &#125;    &#125;    cout << str << endl ;    return 0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>但是出现了大问题，呜呜呜呜……</p><p>在leetcode的ide里面，我是发现了根本删不干净，于是我调试了好久，并且上网查找资料，终于找到了问题所在。</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;int main()&#123;    string str = "ahsdjkafbnaasdfjkanasjkdfbhjasddkaldfasa" ;         auto it = str.begin() ;         while( it != str.end())    &#123;        if(*it == 'a')        &#123;            str.erase(it) ;        &#125;        else        &#123;            it ++ ;        &#125;    &#125;        cout << str << endl ;        return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="对于关联容器"><a href="#对于关联容器" class="headerlink" title="对于关联容器"></a>对于关联容器</h2><p>如map,set,unordered_map容器来说，例如map的底层是由红黑树实现的，当删除一个或者多个节点的时候，并不会导致其他节点的波动。</p><h2 id="对于非关联式的容器-序列容器"><a href="#对于非关联式的容器-序列容器" class="headerlink" title="对于非关联式的容器(序列容器)"></a>对于非关联式的容器(序列容器)</h2><p>例如vector，string，list，queue等容器，这些是有连续分配内存的，所以当删除了当前迭代器的指针，会使后来的元素都往前移动一位，所以会使后续的所有元素的指针都失效。</p><p>目前有两种可以用的方法：</p><p>第一种是采用while循环：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;int main()&#123;    string str = "asfhjkasnaaseelfha" ;        auto it = str.begin() ;         while(it != str.end())    &#123;        if(* it == 'a')        &#123;            str.erase(it) ;        &#125;        else        &#123;            it ++ ;        &#125;    &#125;    cout << str << endl ;    return 0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二种采用的是用erase方法得到下一个有效的迭代器指针：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;int main()&#123;    string str = "asfhjkasnaaseelfha" ;        for(auto it = str.begin() ; it != str.end() ; )    &#123;        if(*it == 'a')        &#123;            it = it.erase(it) ;         &#125;        else        &#123;            it ++ ;        &#125;    &#125;    cout << str << endl ;    return 0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划一日一题-10.4-编辑距离</title>
      <link href="/2021/10/04/dong-tai-gui-hua-yi-ri-yi-ti-10-4-bian-ji-ju-chi/"/>
      <url>/2021/10/04/dong-tai-gui-hua-yi-ri-yi-ti-10-4-bian-ji-ju-chi/</url>
      
        <content type="html"><![CDATA[<h1 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h1><hr><p>给定 n个长度不超过 10 的字符串以及 m 次询问，每次询问给出一个字符串和一个操作次数上限。</p><p>对于每次询问，请你求出给定的 n 个字符串中有多少个字符串可以在上限操作次数内经过操作变成询问给出的字符串。</p><p>每个对字符串进行的单个字符的插入、删除或替换算作一次操作。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 n和 m。</p><p>接下来 n行，每行包含一个字符串，表示给定的字符串。</p><p>再接下来 m 行，每行包含一个字符串和一个整数，表示一次询问。</p><p>字符串中只包含小写字母，且长度均不超过 10。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出共 m 行，每行输出一个整数作为结果，表示一次询问中满足条件的字符串个数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n,m≤1000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>3 2abcacdbcdab 1acbd 2</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>13</code></pre><hr><p>总体考察dp的方式就是同最小编辑距离是一致的，这里再次将最小编辑距离再次巩固一次。</p><p>设置一个函数，用于返回从字符串a变化到字符串b的时候，所需要的最小的次数。</p><p>主函数则用每次返回的次数与limit进行比较，如果比limit小，num++即可。</p><p>对于edit_distance函数来说：</p><p>状态表示：f [i] [j] 就是字符串a的1-i位置变化到字符串b的1-j位置所需要的最小次数</p><p>状态属性：min</p><p>base case : 一般考虑是包括f[0]的初始化</p><p>状态转移：每一次将f[i-1] [j] and f[i] [j-1]  的最小值先赋值给f[i] [j] (也就是所谓的删除和插入)</p><p>​                    一般对于字符串类型的题目来说，分界限很多是字符是否是相等的，如果相等的话，直接pass掉。</p><p>​                    如果不相等，就是各自回到原来的一步，然后做一个替换即可。</p><p>代码如下：</p><pre class="line-numbers language-c++"><code class="language-c++">#include<bits/stdc++.h>using namespace std ;const int N = 1010 ; int f[N][N] ;char str[N][N] ;int edit_distance(char a[] , char b[])&#123;    int la = strlen(a+1) ;  int lb = strlen(b+1) ;        for(int i = 1 ; i <= la ; ++i)    &#123;        f[i][0] = i ;    &#125;        for(int i = 1 ; i <= lb ;++i)    &#123;        f[0][i] = i  ;    &#125;        for(int i = 1 ; i <= la ;++i)    &#123;        for(int j = 1 ; j <= lb ;++j)        &#123;            f[i][j] = min(f[i-1][j] , f[i][j-1])  + 1 ;            if(a[i] == b[j])            &#123;                f[i][j] = min(f[i][j] , f[i-1][j-1]) ;              &#125;            else            &#123;                f[i][j] = min(f[i][j] , f[i-1][j-1]  +1) ;            &#125;        &#125;    &#125;    return f[la][lb] ;&#125;int main()&#123;    int n , m  ;         cin >> n >> m ;        for(int i = 1 ; i <= n ;++ i)    &#123;        cin >> (str[i]  +1 );     &#125;        while(m--)    &#123;        int num = 0 ;         char c[N] ;        int limit = 0 ;         cin >> (c+1) >> limit ;         for(int i = 1 ; i <= n ;++i)        &#123;            if(edit_distance(str[i] , c) <= limit)            &#123;                num ++ ;            &#125;        &#125;        cout << num << endl ;     &#125;    return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 一日一题 线性dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划一日一题-10.3-整数划分</title>
      <link href="/2021/10/03/dong-tai-gui-hua-yi-ri-yi-ti-10-3-zheng-shu-hua-fen/"/>
      <url>/2021/10/03/dong-tai-gui-hua-yi-ri-yi-ti-10-3-zheng-shu-hua-fen/</url>
      
        <content type="html"><![CDATA[<h1 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h1><hr><p>一个正整数 n 可以表示成若干个正整数之和，形如：n=n1+n2+…+nk，其中 n1≥n2≥…≥nk,k≥1。</p><p>我们将这样的一种表示称为正整数 n 的一种划分。</p><p>现在给定一个正整数 n，请你求出 n 共有多少种不同的划分方法。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>共一行，包含一个整数 n。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含一个整数，表示总划分数量。</p><p>由于答案可能很大，输出结果请对 109+7取模。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤1000</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h4><pre><code>5</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>7</code></pre><hr><p>该题是典型的整数划分类问题，也可以将其理解成完全背包问题。所以该题就可以转换为现在有n种物品，第i种背包的容量是i，数量为无穷，请问能装满体积为n的背包的方案数是多少？</p><p>同完全背包问题，我们先想朴素算法。用f[i] [j] 表示用前i个物品来装满体积为j的背包的方案数。</p><p>状态表示：f[i] [j] 表示用前i个物品装满j的背包的方案数，最终的结果就可以标示为f[n] [ n] ; </p><p>状态属性：无</p><p>状态转移：f[i] [j] = f[i-1] [ j] +f[i-1] [j-i] +f[i-1] [j-2*i] + …+ </p><p>​                    f[i] [j-i] =                f[i-1] [j-i] + f[i-1] [j- 2*i] + … + </p><p>故有数学推导可得：</p><p>f[i] [j] = f[i-1] [j] + f[i] [j-i] </p><p>base case ：比较玄学，基于现在的水平，我觉得就是把二维数组涉及下标为0的可以提前知道的给初始化一下，比如这一题：</p><p>f[i] [0] 是可以提前知道的，同时也是转移的起始点。</p><pre class="line-numbers language-c++"><code class="language-c++">//朴素做法#include <bits/stdc++.h>using namespace std ;const int N = 1010  , mod = 1e9+7;int f[N][N] ;int main()&#123;    int n ;     cin >> n  ;        //base case        for(int i = 1 ; i <= n ;++i)    &#123;        f[i][0] = 1 ;    &#125;        for(int i = 1 ; i <= n ;++i)    &#123;        for(int j = 1 ; j <= n ;++j)        &#123;            f[i][j] = f[i-1][j] % mod ;            if(j >= i)                 f[i][j] = (f[i-1][j] + f[i][j-i]) % mod ;         &#125;    &#125;    cout << f[n][n] << endl ;    return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">//做了一点优化#include <bits/stdc++.h>using namespace std ;const int  N = 1010 , mod = 1e9+7;int f[N] ; int main()&#123;    int n ;     cin >> n ;      for(int i = 1 ; i <= n ;++i)        f[0] = 1 ;          for(int i = 1 ; i <= n ;++i)    &#123;        for(int j = 1 ; j <= n ; ++j)        &#123;            if(j >= i)                f[j] = (f[j] +f[j-i]) % mod ;        &#125;    &#125;    cout << f[n] << endl ;    return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 一日一题 计数dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>没有问题的答案</title>
      <link href="/2021/10/02/mei-you-wen-ti-de-da-an/"/>
      <url>/2021/10/02/mei-you-wen-ti-de-da-an/</url>
      
        <content type="html"><![CDATA[<h1 id="没有答案的问题"><a href="#没有答案的问题" class="headerlink" title="没有答案的问题"></a>没有答案的问题</h1><p>今天在看文献的时候突然想到一个有趣的问题，每一篇文献里面都有很多篇引用。如果用一个数据结构来表示，所有文献的集合就是一张非常复杂的网络图。所以说，只要从当前任意一篇文献开始，顺着其中任意一篇引用文献，不断向前找，终可以找到一篇甚至说是第一篇没有任何引用文献的论文。</p><p>又想到年初Clubhouse爆火的时候，由于当时注册软件只能是邀请制，所以每一个注册的用户都有一个比他更早注册的邀请人。而这个邀请人正好就被放在了每一个用户的个人主页上，于是当时我很好奇地顺着整个链条点到了最后。不意外，最后这个没有邀请人的用户就是这个软件的创始人之一。</p><p>这么想，顺着链条去找寻一个东西还是一件挺有趣的事。但是呢，有时候这个链条可能没有终点，找寻的过程也没有这么简单。</p><p>之前有看到一篇文章讲《如何把一个成年人逼疯？》，那你只需要不断地问他问题。</p><p>就拿一个简单的问题说：为什么天空是蓝色的？ 有点常识的人会回答：因为光的散射。那继续追问：什么是散射，又为什么只散射蓝色的光？这个时候你可能就得去查查资料了：这是因为瑞利散射，波长越短的光波散射强度更大… 那么光为什么会发生散射？光的本质是什么？人眼为什么能看到这些颜色…</p><p>如果真的这么一直追问下去，不说把人逼疯，至少会让人觉得你这是在故意找茬，最后让一个人生气还是很容易的。</p><p>上面回答的过程，就是不断用一个概念去解释另一个概念，然后在回答的过程中又引出了更多的概念。所以说，有时候你认为的答案可能并不是真正的答案，至少很大可能下都不是那个最终的答案。</p><p>面对一个问题，我们都想要得到一个答案。但是最终的答案止步于哪，对不同的人来说可能是不一样的。因为每个人对答案的追求是不一样的。有趣的是，如果你愿意不断追问，在这个过程中，你问得越深，可能会发现原来的答案并不是自己想要的那个答案了，自己原本以为懂的东西发现又不懂了。</p><p>所以即使当你停止追问时，当你以为你已经找到答案时，当前的答案也不一定是最终答案，但它一定是一个你愿意接受的答案。</p><p>所以啊，人就是要保持无知，“我知道”三个字就还是不要轻易说出口了。你以为的你知道可能对别人来说并不是他们想要的答案，你我认为的答案也都不一定是最终答案，它们只是不同的人在不同思考维度不同深度上的一个临时结果罢了。</p><p>回答里面有回答，问题里面有问题，这一个链条的探索过程和上面是一样的。科学家通过这种不断提问，发现问题，想知道这最后的答案究竟是什么，然后去不断追寻一切背后的答案。于是在这个过程中，科学家们为了解释创造出了无数的概念，人们也在这个过程中更好地认识了这个世界，也学到了更多的知识。</p><p>之前在学模拟集成电路的时候，从CMOS管开始，为了了解底层细节转向学习了半导体物理，为了更好地理解电子运动，顺着知识的脉络又看到电动力学，再深究，是量子力学…虽然最后说服了自己，有许多东西是没有必要看的，但是这个追寻知识链条的过程还是很有意义的。不断问问题和寻找答案的过程并不容易，这也是为什么大部分人都成为不了科学家。</p><p>小时候就知道对问题要刨根问底，多问一些为什么。但是越长大，由于环境的原因，思维越惰性，越来越不愿意思考，越不愿意问为什么了。</p><p>上面这种不断问问题的方式，其实也为我们构建自己的知识系统提供了一个思路。一般来说，我们学习的知识是离散的，一个个孤立的知识点，当它们足够多的时候就会编织成网。但是，我们也可以主动地顺着知识点，不断去找出一条可以串起来的知识脉络。</p><p>虽然问问题是一个能够让人思考的很好的办法，在这个过程中我们会发现自己的无知，会学习到新的知识。但是现实中的问题往往没有那么简单，有的问题不能立即得到答案，可能需要很多年去解答，甚至有的问题，都没有一个正确答案。真正重要的，是我们问问题过程中的思考，与我们思考的结果。为什么问问题的能力如此重要，因为这个世界需要的是解决问题的人，真正稀缺的有技术的人是具有独立思考自己独立解决问题的人。</p><p>又比如有这样一个问题：已知有一个直角三角形，斜边长是 10，斜边上的高是 6，问这个直角三角形的面积是多少？</p><p>乍一看，三角形面积 = 底 × 高 / 2 = 30</p><p>但事实却是无解，这样的直角三角形并不存在。大家以前都学过，圆直径所对的圆周角是90度。所以以直角三角形的斜边为直径作一个圆，连接圆上任意一点就可以得到以该直径为斜边的所有直角三角形。但是以这道题为例，这些三角形中斜边上的高最大只能为这个圆的半径长度，也就是5，这就是说并不可能存在高为6的直角三角形。</p><p>以前在学校的时候，学习一个知识点要做好多题，为的是再遇到时能够更快地上手。做更多的题能提高熟练度是没错，最后还能很好的达到一个平均水准。但是在这个过程中渐渐淡化了我们真正的分析问题的能力，于是遇到新问题，大部分时候都习惯性地套用经验，甚至忘了如何从根本上发现问题，分析问题和解决问题。</p><p>分析能力，更是一种底层逻辑能力，之前一直在想底层逻辑能力是什么。后来觉得底层逻辑可能就像亚里士多德的“三段论”那样的一个思维模型。这个世界这么复杂，现实的问题也各种各样，每天面对的信息也越来越多，我们需要学会要建立自己的一个思考模型。例如考虑信息源的可靠性，数据的真实性，结论的因果性…但是要做到下意识地去思考分析问题，还是挺难的，多思考吧。</p><p>另一方面，以前做题的时候，如果做不出来，第一时间会觉得肯定不是自己的问题，会觉得是题出错了。到后来，会先反思一下是不是自己题读错了，因为认为自己犯错的几率会大更多。现在有时候对一些现象也好，问题也好，也会想不通，就会反思是自己的问题呢还是别人的问题。唉，有时候质疑别人质疑自己都是一件挺难的事。</p><p>像上面的问题，其实如果不是指出了问题，可能自己觉得算出来的已经是正确答案了。就像上面说到的，你认为自己知道的答案不一定是真正的答案，即使看起来很正确，可能也只是无知的体现。</p><p>当然了，有一些问题也确实无解，生活中，想不明白的事多了去了，解释不了，解决不了的事也多了去了。导致问题无解的出现可能是由于限制太多，有时候卸下一些条件，可能就有解了。</p><p>面对生活中的问题，无解时会焦虑，有解时又想着最优解，人啊，总是这么贪心。</p><p>但是呢，其实无解也是一个答案，只是看你愿不愿意接受罢了。</p><p>作者：Coderoger<br>链接：<a href="https://www.acwing.com/file_system/file/content/whole/index/content/3006746/">https://www.acwing.com/file_system/file/content/whole/index/content/3006746/</a><br>来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划一日一题-10.2-石子合并</title>
      <link href="/2021/10/02/dong-tai-gui-hua-yi-ri-yi-ti-10-2-shi-zi-he-bing/"/>
      <url>/2021/10/02/dong-tai-gui-hua-yi-ri-yi-ti-10-2-shi-zi-he-bing/</url>
      
        <content type="html"><![CDATA[<h1 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h1><p>设有 NN 堆石子排成一排，其编号为 1，2，3，…，N1，2，3，…，N。</p><p>每堆石子有一定的质量，可以用一个整数来描述，现在要将这 NN 堆石子合并成为一堆。</p><p>每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。</p><p>例如有 44 堆石子分别为 <code>1 3 5 2</code>， 我们可以先合并 1、21、2 堆，代价为 44，得到 <code>4 5 2</code>， 又合并 1，21，2 堆，代价为 99，得到 <code>9 2</code> ，再合并得到 1111，总代价为 4+9+11=244+9+11=24；</p><p>如果第二步是先合并 2，32，3 堆，则代价为 77，得到 <code>4 7</code>，最后一次合并代价为 1111，总代价为 4+7+11=224+7+11=22。</p><p>问题是：找出一种合理的方法，使总的代价最小，输出最小代价。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行一个数 NN 表示石子的堆数 NN。</p><p>第二行 NN 个数，表示每堆石子的质量(均不超过 10001000)。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最小代价。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤300</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>41 3 5 2</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>22</code></pre><h3 id="经典区间dp问题："><a href="#经典区间dp问题：" class="headerlink" title="经典区间dp问题："></a>经典区间dp问题：</h3><p>状态表示：采用二维数组，f[i] [j] 表示的是合并了从i到j的石子之后，所得到的最小代价.最后答案的表示即为f[1] [n] .</p><p>状态属性： min</p><p>base case: </p><p>状态转移：因为我们选定的状态其实是一段区间的最小状态，所以我们先要选取区间用len来表示，然后对于每一个区间内部来说.</p><p>我们考虑到每一个区间所谓的最小代价，最后必将是左边一个连续的集合与右边一个连续的集合进行相加，这两个集合同时也是可以用我们的f数组来表示，这也就是我们这一题可以用dp来做的原因。我们采用设置一个k，来作为起点和终点的一个中断点，通过对k在i到j(即每个区间)的放置位置，来选择局部最优的方式。最终，不断迭代，即可得到最终的答案。</p><p>不说了，上代码：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 310  ; int f[N][N] ;int w[N] ;int main()&#123;    int n ;     cin >> n ;         for(int i = 1 ; i <= n ;++i)    &#123;        cin >> w[i] ;        w[i] += w[i-1] ;    &#125;            for(int len = 2 ; len <= n ; ++len)    &#123;        for(int i = 1 ; i <= n + 1 -len; i ++)        &#123;            int j = len + i - 1 ;            f[i][j] = 1e9  ;        for(int k = i ; k < j ;++k)        &#123;            f[i][j] = min(f[i][j] , f[i][k]+f[k+1][j]+ w[j] -w[i-1]) ;        &#125;           &#125;    &#125;    cout << f[1][n] << endl  ;     return 0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 一日一题 区间dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划一日一题-10-1-最小编辑距离</title>
      <link href="/2021/10/01/dong-tai-gui-hua-yi-ri-yi-ti-10.1-zui-xiao-bian-ji-ju-chi/"/>
      <url>/2021/10/01/dong-tai-gui-hua-yi-ri-yi-ti-10.1-zui-xiao-bian-ji-ju-chi/</url>
      
        <content type="html"><![CDATA[<h1 id="最小编辑距离"><a href="#最小编辑距离" class="headerlink" title="最小编辑距离"></a>最小编辑距离</h1><hr><p>给定两个字符串 A 和 B，现在要将 A 经过若干操作变为 B，可进行的操作有：</p><ol><li>删除–将字符串 A 中的某个字符删除。</li><li>插入–在字符串 A 的某个位置插入某个字符。</li><li>替换–将字符串 A 中的某个字符替换为另一个字符。</li></ol><p>现在请你求出，将 A 变为 B 至少需要进行多少次操作。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n，表示字符串 A 的长度。</p><p>第二行包含一个长度为 n 的字符串 A。</p><p>第三行包含整数 m，表示字符串 B 的长度。</p><p>第四行包含一个长度为 m 的字符串 B。</p><p>字符串中均只包含大写字母。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最少操作次数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n,m≤1000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>10 AGTCTGACGC11 AGTAAGTAGGC</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>4</code></pre><hr><p>由dp的思想，显然需要创建一个二维的数组。</p><h3 id="定义明确"><a href="#定义明确" class="headerlink" title="定义明确"></a>定义明确</h3><p>首先明确dp数组的定义，dp[i] [j] 表示的是第一个数组的1-i转变成1-j需要的最小的操作次数(即最小的编辑距离)。</p><h3 id="base-case"><a href="#base-case" class="headerlink" title="base case"></a>base case</h3><p>该题的启动点是0-i和0-j对于第一个数组转换成第二个数组的次数是明确的。</p><h3 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h3><p>1.注意是从已有值转移过来的，所以设计状态方程时候需要考虑base case。</p><p>2.一般涉及字符串转换的题都有一个思路是根据双指针指到的字符相等与否来进行状态转移考虑，再结合dp数组的含义即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 10010 ;int f[N][N] ;char p[N] ,q[N] ;int main()&#123;        int n , m  ;     scanf("%d%s",&n , p+1) ;    //这有一个小技巧，当涉及字符串的读入的时候，尽量使用%s，防止空格的读入    scanf("%d%s",&m , q+1) ;        //base case        for(int i = 1 ; i <= n ;++i)    &#123;        f[i][0] = i ;     &#125;    for(int j = 1 ; j <= m ;++j)    &#123;        f[0][j] = j ;    &#125;        //状态转移        for(int i = 1 ; i <= n ;++i)    &#123;        for(int j = 1 ; j <= m ;++j)        &#123;            f[i][j] = min(f[i-1][j] , f[i][j-1]) ; //之前我一直在想这一步的必要性，后来其实是如果不写的话，后面的转移就直接没有值            if(p[i] == q[j])            &#123;                f[i][j] = min(f[i][j] , f[i-1][j-1]) ;            &#125;            else            &#123;                f[i][j] = min(f[i][j] , f[i-1][j-1] + 1) ;            &#125;        &#125;    &#125;        cout << f[n][m] << endl ;       return 0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 一日一题 线性dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算</title>
      <link href="/2021/09/27/wei-yun-suan/"/>
      <url>/2021/09/27/wei-yun-suan/</url>
      
        <content type="html"><![CDATA[<h1 id="85-不用加减乘除做加法"><a href="#85-不用加减乘除做加法" class="headerlink" title="85.不用加减乘除做加法"></a>85.不用加减乘除做加法</h1><hr><p>写一个函数，求两个整数之和，要求在函数体内不得使用 ＋、－、×、÷＋、－、×、÷ 四则运算符号。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><pre><code>输入：num1 = 1 , num2 = 2输出：3</code></pre><hr><p>对于对二进制数进行位运算来说，将其异或就是进行无进位的运算，得出的用于进位的数字可以用两数进行相与操作得到，乘以进制即可。</p><p>代码如下：</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    int add(int num1, int num2)&#123;        while(num2)        &#123;          int m = num1^num2 ;         unsigned int n = ((unsigned int)num1&num2 ) << 1;         num1 = m ;         num2 = n ;     &#125;      return num1 ;     &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存限制比较严格的一题(怪)</title>
      <link href="/2021/09/23/nei-cun-xian-zhi-bi-jiao-yan-ge-de-yi-ti-guai/"/>
      <url>/2021/09/23/nei-cun-xian-zhi-bi-jiao-yan-ge-de-yi-ti-guai/</url>
      
        <content type="html"><![CDATA[<hr><p>地图上有 N 个目标，用整数 Xi,Yi 表示目标在地图上的位置，每个目标都有一个价值 Wi。</p><p><strong>注意</strong>：不同目标可能在同一位置。</p><p>现在有一种新型的激光炸弹，可以摧毁一个包含 R×R 个位置的正方形内的所有目标。</p><p>激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个正方形的边必须和 x，y 轴平行。</p><p>求一颗炸弹最多能炸掉地图上总价值为多少的目标。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入正整数 N 和 R，分别代表地图上的目标数目和正方形的边长，数据用空格隔开。</p><p>接下来 N 行，每行输入一组数据，每组数据包括三个整数 Xi,Yi,Wi，分别代表目标的 x 坐标，y 坐标和价值，数据用空格隔开。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>0≤R≤109<br>0&lt;N≤10000<br>0≤Xi,Yi≤5000<br>0≤Wi≤1000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>2 10 0 11 1 1</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>1</code></pre><hr><p>这就比较显然是一道二维前缀和的题目，具体思路还是比较简单的.</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 5050 ;int s[N][N] ;int main()&#123;    int n , R ;    cin >> n >> R ;    R = min(R , 5010) ;     int x = R, y = R ;        for(int i = 0 ; i < n ;++i)    &#123;        int a, b ,w ;        cin >>a >>b >>w ;                s[a+1][b+1] += w ;                x = max(x , a+1) ; y = max(y , b+1) ;     &#125;        for(int i = 1 ; i <= x; ++i)    &#123;        for(int j = 1 ; j <= y ;++j)        &#123;            s[i][j] = s[i][j] + s[i-1][j] + s[i][j-1] -s[i-1][j-1] ;        &#125;    &#125;        int res= 0 ;     for(int i = R ; i <= x ; ++i)        for(int j = R ; j <= y ;++j)        &#123;            res = max(res , (s[i][j] + s[i-R][j-R] - s[i-R][j] - s[i][j-R])) ;        &#125;        cout << res <<endl  ;    return 0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(奇怪哦~~~，同样的代码今天交就AC了，昨天明明就不可以的…….)</p>]]></content>
      
      
      
        <tags>
            
            <tag> acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>头痛的二分查找</title>
      <link href="/2021/09/19/tou-tong-de-er-fen-cha-zhao/"/>
      <url>/2021/09/19/tou-tong-de-er-fen-cha-zhao/</url>
      
        <content type="html"><![CDATA[<h1 id="二分手册-持续总结更新"><a href="#二分手册-持续总结更新" class="headerlink" title="二分手册(持续总结更新)"></a>二分手册(持续总结更新)</h1><p>经过长时间的保守二分法调试的折磨(主要是边界条件的一些细节).</p><p>经常看着别人的代码与自己的代码明明是一样的，但是别人的直接AC,我的要么TLE，要么CE，要么SF……..</p><p>所以，经过长时间的血泪教训与总结，我开始渐渐摸清楚二分的方法了吧(Maybe?)</p><h2 id="对于常用的二分模板来说"><a href="#对于常用的二分模板来说" class="headerlink" title="对于常用的二分模板来说"></a>对于常用的二分模板来说</h2><h3 id="最应该考虑二分的目的与意义"><a href="#最应该考虑二分的目的与意义" class="headerlink" title="最应该考虑二分的目的与意义"></a>最应该考虑二分的目的与意义</h3><p>二分：翻译成通俗易懂的语言来说，就是找到第一个满足XX条件的数据(前提是在一个有序的数组中)</p><p>主要有两种，一种是a[mid] &gt;= target型的，一种是a[mid] &lt;= target型的。</p><p>两种不同的表达方式对应着不同的left与right的部署。</p><pre class="line-numbers language-c++"><code class="language-c++">while(left < right)&#123;    int mid = left + right >> 1 ;     if(a[mid] >= target)    &#123;        right = mid ;     &#125;    else    &#123;        left = mid + 1 ;     &#125;&#125;//中文就是大于等于target的第一个数字<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">while(left < right)&#123;    int mid = left + right + 1>> 1 ;     if(a[mid] > target)    &#123;        right = mid-1 ;     &#125;    else    &#123;        left = mid  ;    &#125;&#125;//找到的是小于等于target的第一个数字 (只要是right = mid -1 ，要在mid的来源+1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="举一些例子："><a href="#举一些例子：" class="headerlink" title="举一些例子："></a>举一些例子：</h3><h2 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h2><hr><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p><p>输入一个升序的数组的一个旋转，输出旋转数组的最小元素。</p><p>例如数组 {3,4,5,1,2}为 {1,2,3,4,5}的一个旋转，该数组的最小值为 1。</p><p>数组可能包含重复项。</p><p><strong>注意</strong>：数组内所含元素非负，若数组大小为 0，请返回 −1。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><pre><code>输入：nums = [2, 2, 2, 0, 1]输出：0</code></pre><hr><p>这一题是比较经典的利用二分来做的，找最小值的模板题目。</p><p>其实如果是比赛做到了，那其实直接sort一下，return nums[0] 好像就可以了……..(好吧，某种程度上说他显然是一道弱智题…….)</p><p>但是！！！但是！！！但是！！！</p><p>这道题可以锻炼一下我们的二分的熟练度，好吧，现在就用二分来分析一下这道题目，就用刚刚的二分模板。</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    int findMin(vector<int>& nums) &#123;        int n = nums.size() ;         if(n == 0) return  -1 ;                 nums.erase(unique(nums.begin() , nums.end()) , nums.end()) ;                n = nums.size() ;                 int left = 0  ; int right = n-1 ; //左闭右开                if(nums[right] > nums[0]) return nums[0] ;                 while(left < right)        &#123;            int mid = left + right >> 1 ;                         if(nums[mid] >= nums[0])            &#123;                left = mid + 1 ;             &#125;            else            &#123;                right = mid ;             &#125;        &#125;        return nums[left] ;     &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>回顾一下代码：</p><p>写二分，重要的一下几点：</p><p>一、找到target，即你的对比值是什么。比如这一题他的对比值就是nums[0]。</p><p>二、找到你想要的值与target之间的关系，无非就是几种：</p><p>第一个小于等于target的数、第一个大于等于target的数，或者是把小于等于什么的改成小于而已…….</p><p>三、找对应的模板，背模板的时候注意几点即可。</p><p>我个人习惯是一般采用左闭右开的方式，来初始化的left和right。</p><p>然后找target与关系，找到之后呢，比如这一题，我要找的是小于nums[0]的第一个数字，那我就考虑left最终应该指向&gt;=nums[0]的最后一个元素的位置再加一。</p><p>一般来说，我们最终的破除循环的条件为</p><pre class="line-numbers language-c++"><code class="language-c++">while(left < right)&#123;    ...........&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>所以最终状态其实是left == right的，那我们就可以反向进行考虑，最后一步变化的那必然是xxx = mid + 1/mid -1什么的，另外一个值其实再倒数几步的时候是不会变化的，已经锁定住我们要的值了，剩下的其实可以理解为等另外一个变量靠过来，然后破圈即可。所以我们主要考虑的对象其实是xxx = mid ; 的部分。如果是right = mid -1 ;什么的，要注意再确定mid的时候，就需要</p><pre class="line-numbers language-c++"><code class="language-c++">mid = left + right + 1>> 1 ; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要不然，血泪教训是</p><p>TLE……….死循环……</p><p>好的，之后如果有更加经典的例子，我再次会更新。</p><p>—————————————-ok 今天是-10-10更新————————————————————————</p><p>又发现了一个比较经典的例子</p><h2 id="数的范围"><a href="#数的范围" class="headerlink" title="数的范围"></a>数的范围</h2><hr><p>给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。</p><p>对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。</p><p>如果数组中不存在该元素，则返回 <code> -1</code>。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n 和 q，表示数组长度和询问个数。</p><p>第二行包含 n 个整数（均在 1∼10000 范围内），表示完整数组。</p><p>接下来 q 行，每行包含一个整数 k，表示一个询问元素。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 q行，每行包含两个整数，表示所求元素的起始位置和终止位置。</p><p>如果数组中不存在该元素，则返回 <code>-1</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤100000<br>1≤q≤10000<br>1≤k≤10000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>6 31 2 2 3 3 4345</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>3 45 5-1 -1</code></pre><hr><p>ok，main函数的部分应该是相当简单了，主要的难点就是在于，如何返回两个值，满足起始与终点的要求。</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 100010  ; int a[N] ; int n , m ;int findlow(int *a , int num)&#123;    int left = 0 ;    int right = n ;     while(left < right)    &#123;        int mid = left + right >> 1 ;         if(a[mid] >= num)        &#123;            right = mid ;         &#125;        else        &#123;            left = mid + 1 ;         &#125;    &#125;    return left ; &#125;int findhigh(int *a , int num)&#123;    int left = 0 ;    int right = n ;     while(left < right)    &#123;        int mid = left + right >> 1 ;         if(a[mid] > num)        &#123;            right = mid ;         &#125;        else        &#123;            left = mid + 1 ;         &#125;    &#125;    return left - 1; &#125;int main()&#123;    cin >> n >> m ;         for(int i = 0 ; i < n ;++i)    &#123;        cin >> a[i] ;     &#125;    for(int i = 0 ; i < m ; ++ i)    &#123;        int b ;         cin >> b ;         int low = findlow(a , b) ;         int high = findhigh(a , b) ;         if(low > high)            low = high = -1 ;         cout << low << " " << high << endl ;     &#125;    return  0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运用之前的二分查找法的模板来说，</p><p>我们已经知道该题的target，就是目标值了。现在关系也明确了，就是查找&gt;=target的第一个数字和&lt;=target的最后一个数字。</p><p>我们知道二分查找模板的宗旨是返回第一个满足的值。那大于等于target的第一个值非常好找，小于等于target的最后一个值应该怎么找呢？</p><p>换个思路，那就是找&gt;target的第一个值的位置再减去一咯！！！！！</p><pre class="line-numbers language-c++"><code class="language-c++">int findlow(int *a , int num)&#123;    int left = 0 ;  int right = n ;     while(left < right)    &#123;        int mid = left + right >> 1 ;         if(a[mid] >= num)        &#123;            right = mid  ;        &#125;        else        &#123;            left = mid + 1 ;         &#125;    &#125;    return left ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">int findhigh(int *a , int num)&#123;    int left = 0 ; int right = n ;     while(left < right)    &#123;        int mid = left + right >> 1 ;         if(a[mid] > num)        &#123;            right = mid ;         &#125;        else        &#123;            left = mid + 1  ;        &#125;    &#125;    return left - 1 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性DP专题</title>
      <link href="/2021/09/18/xian-xing-dp-zhuan-ti/"/>
      <url>/2021/09/18/xian-xing-dp-zhuan-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="1-最长公共子序列"><a href="#1-最长公共子序列" class="headerlink" title="1.最长公共子序列"></a>1.最长公共子序列</h1><hr><p>给定两个长度分别为 N和M 的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 N 和 M。</p><p>第二行包含一个长度为 N 的字符串，表示字符串 A。</p><p>第三行包含一个长度为 M 的字符串，表示字符串 B。</p><p>字符串均由小写字母构成。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大长度。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N,M≤1000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>4 5acbdabedc</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>3</code></pre><hr><p>一、可以用二维dp，dp[i] [j] 表示在第一个序列的第i位到第二个序列的j位的最长公共子串的长度。</p><p>二、二维数组要想给每一个赋值，即需要从底往上遍历。</p><p>三、讲遇到的情况分成两大类，一类是相等，一类是不等。</p><p>即状态转移方程我为</p><pre><code>if(a[i] == b[j])dp[i][j] = dp[i-1][j-1] + 1 ;else if(a[i] != b[j])dp[i][j] = max(dp[i-1][j] , dp[i][j-1]) ;</code></pre><p>具体代码如下:</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 1010 ;int f[N][N] ;char a[N], b[N] ;int main()&#123;    int n , m ;     cin >>n >> m  ;    for(int i = 1 ; i <= n ;++i)        cin >> a[i] ;     for(int j = 1 ; j <= m ;++j)        cin >> b[j] ;            for(int i = 1 ; i <= n ; ++i)    &#123;        for(int j = 1 ; j <= m ; ++j)        &#123;            if(a[i] == b[j])            &#123;                f[i][j] = f[i-1][j-1] +1 ;            &#125;            else            &#123;                f[i][j] = max(f[i-1][j] , f[i][j-1]) ;            &#125;        &#125;            &#125;            cout << f[n][m] <<endl ;            return  0  ;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二、最长上升子序列"><a href="#二、最长上升子序列" class="headerlink" title="二、最长上升子序列"></a>二、最长上升子序列</h1><p>给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 N。</p><p>第二行包含 N 个整数，表示完整序列。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大长度。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤1000<br>−109≤数列中的数≤109</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>73 1 2 1 8 5 6</code></pre><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>4</code></pre><p>数据范围给的比较大，所以直接暴力dp就可以了。</p><p>一、创建一个一维的dp数组，dp[i]表示的是从1到i的字串中， 以q[i]所结尾的子序列的最长子序列的长度.</p><p>二、dp思路，搜索数组中目标值前面的值，找到严格比target小的index， 将本target接在后面即可。然后一直比较，将最大的值赋给dp即可。</p><p>三、最终的结果不一定是最后的dp结果，而是过程中出现最大的值，因此需要在每一个小循环结束的时候，设置一个res，专门用来记录出现的最大的dp值。</p><p>代码如下：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 1010 ;int w[N] ;int f[N] ; int main()&#123;    int n ;     cin >>n ;            int res =0  ;    for(int i = 1 ; i <= n ;++i)    &#123;        cin >> w[i] ;    &#125;    for(int i = 1 ; i <= n ;++i)    &#123;        f[i] = 1 ;        for(int j = 1 ; j <= i ;++j)        &#123;            if(w[i] > w[j]) f[i] = max(f[i] , f[j] +1) ;        &#125;        res = max(res , f[i]) ;    &#125;        cout << res <<endl ;    return  0  ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、最长上升子序列II"><a href="#三、最长上升子序列II" class="headerlink" title="三、最长上升子序列II"></a>三、最长上升子序列II</h1><p>题目同二，但是数据范围从1000改到了1e5。</p><p>所以，直接把暴力给毙了.</p><p>我们想到最多可以用nlogn来优化，于是可以用二分来优化.</p><p>dp是用不了了，可以用贪心加二分。</p><p>具体思路：</p><p>一、对于原数组中的值，依次在二分数组中找到小于他的最大值，二分数组的作用是一边存储，一边用于搜索。</p><p>二、最后返回q数组的长度即可。</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 100010 ;int w[N] ;int q[N] ;int main()&#123;    int n ;     cin >> n ;    q[0] = -2e9 ;         for(int i = 1 ; i <=  n ;++i)    &#123;        cin >> w[i] ;    &#125;        int len = 0  ;    for(int i = 1 ; i <= n ;++i)    &#123;        int left = 0 ; int right = len ;        while(left < right)        &#123;            int mid = (left + right +1) >> 1 ;            if(q[mid] < w[i])            &#123;                left = mid  ;             &#125;            else             &#123;                right = mid - 1  ;             &#125;        &#125;        q[right+1] = w[i] ;        len = max(len , right+1) ;    &#125;    cout << len <<endl ;    return  0  ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2021/09/15/bing-cha-ji/"/>
      <url>/2021/09/15/bing-cha-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="1-目的"><a href="#1-目的" class="headerlink" title="1.目的"></a>1.目的</h2><h3 id="一、合并两个集合"><a href="#一、合并两个集合" class="headerlink" title="一、合并两个集合"></a>一、合并两个集合</h3><p>即将其中的一个集合作为另外一个集合的son。</p><h3 id="二、判断两个元素是否在同一个集合里面"><a href="#二、判断两个元素是否在同一个集合里面" class="headerlink" title="二、判断两个元素是否在同一个集合里面"></a>二、判断两个元素是否在同一个集合里面</h3><p>集合的表示方式是用树来表示(不一定是二叉树)， 每个节点存储的是当前的节点的父亲节点，根节点存储的是该集合的编号。即只需要两个元素(树的节点)一直溯源，查找到根节点对应的编号。若编号相同，则在同一个集合里面。</p><h2 id="2-优化"><a href="#2-优化" class="headerlink" title="2.优化"></a>2.优化</h2><p>优化的环节主要在于查找根节点的步骤。</p><p>朴素的做法是，假设p[x]是x节点的上一个节点.</p><pre class="line-numbers language-c++"><code class="language-c++">while(p[x] == x) x = p[x] ; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样会导致时间复杂度较高。</p><p>优化方式：路径压缩。即从一个节点查找根节点之后，将途中的所有的节点的p[x]都指向根节点。这样一旦在需要重复寻根的时候，可以大大节省时间。</p><h2 id="3-模板题"><a href="#3-模板题" class="headerlink" title="3.模板题"></a>3.模板题</h2><h3 id="一、合并集合"><a href="#一、合并集合" class="headerlink" title="一、合并集合"></a>一、合并集合</h3><p>一共有 n 个数，编号是 1∼n，最开始每个数各自在一个集合中。</p><p>现在要进行 m 个操作，操作共有两种：</p><ol><li><code>M a b</code>，将编号为 a和 b 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；</li><li><code>Q a b</code>，询问编号为 a和b 的两个数是否在同一个集合中；</li></ol><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入整数 n 和 m。</p><p>接下来 m 行，每行包含一个操作指令，指令为 <code>M a b</code> 或 <code>Q a b</code> 中的一种。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个询问指令 <code>Q a b</code>，都要输出一个结果，如果 a和 b 在同一集合内，则输出 <code>Yes</code>，否则输出 <code>No</code>。</p><p>每个结果占一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n,m≤105</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>4 5M 1 2M 3 4Q 1 2Q 1 3Q 3 4</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>YesNoYes</code></pre><pre class="line-numbers language-c++"><code class="language-c++">#include<bits/stdc++.h>using namespace std ;const int N = 100010 ;int p[N] ;int find(int num)&#123;   //这一步是比较妙的，既找到了num的祖宗节点，而且还实现了路径压缩，每一个节点的父节点都是根节点了    if(p[num] != num)    &#123;        p[num] = find(p[num]) ;    &#125;    return p[num] ;&#125;int main()&#123;    int n ,m ;    cin>>n>>m ;    for(int i = 1 ;i <= n ;++i)        p[i] = i ;  //相当于初始化，将每一个元素存放到对应的集合中        for(int i = 0 ; i < m ;++i)&#123;        char op ;        cin>> op ;        int a , b ;        cin>> a >> b ;        if(op == 'M')        &#123;            p[find(a)] = find(b) ;        &#125;        else        &#123;            if(find(a) == find(b))                cout<<"Yes"<<endl ;            else                cout<<"No"<<endl ;        &#125;            &#125;return  0 ;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二、连通块中点的数量"><a href="#二、连通块中点的数量" class="headerlink" title="二、连通块中点的数量"></a>二、连通块中点的数量</h3><p>给定一个包含 n个点（编号为 1∼n1∼n）的无向图，初始时图中没有边。</p><p>现在要进行 m 个操作，操作共有三种：</p><ol><li><code>C a b</code>，在点 a 和点b 之间连一条边，aa 和 bb 可能相等；</li><li><code>Q1 a b</code>，询问点 a 和点b 是否在同一个连通块中，a 和 b 可能相等；</li><li><code>Q2 a</code>，询问点 a 所在连通块中点的数量；</li></ol><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入整数 n 和 m。</p><p>接下来 m 行，每行包含一个操作指令，指令为 <code>C a b</code>，<code>Q1 a b</code> 或 <code>Q2 a</code> 中的一种。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个询问指令 <code>Q1 a b</code>，如果 a 和 b 在同一个连通块中，则输出 <code>Yes</code>，否则输出 <code>No</code>。</p><p>对于每个询问指令 <code>Q2 a</code>，输出一个整数表示点 a 所在连通块中点的数量</p><p>每个结果占一行。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n,m≤105</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>5 5C 1 2Q1 1 2Q2 1C 2 5Q2 5</code></pre><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>Yes23</code></pre><pre class="line-numbers language-c++"><code class="language-c++">#include<bits/stdc++.h>using namespace std ;const int N = 100010 ;int n  , m ;int father[N] ;int find(int num)&#123;    if(father[num] != num)         father[num] = find(father[num]) ;    return father[num] ;&#125;int main()&#123;    cin>>n>>m ;    int size[N]  ;    for(int i = 1 ; i <= n ;++i )    &#123;        father[i] = i ;            size[i] = 1 ;    &#125;        string op;    int a, b ;    for(int i = 0 ; i < m ; ++i )    &#123;        cin>>op ;        if(op == "C")        &#123;            cin>>a>>b ;            int x = find(a) ; int y = find(b) ;            if(x != y)            &#123;                father[x] = y ;                size[y] += size[x] ;            &#125;        &#125;        else if(op == "Q1")        &#123;            cin>>a>>b ;            (find(a) == find(b)) ? puts("Yes") : puts("No") ;        &#125;        else if(op == "Q2")        &#123;            cin>>a ;            cout<<size[find(a)]<<endl ;        &#125;      &#125;    return 0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、食物链"><a href="#三、食物链" class="headerlink" title="三、食物链"></a>三、食物链</h3><p>动物王国中有三类动物 A,B,CA,B,C，这三类动物的食物链构成了有趣的环形。</p><p>A 吃 B，B 吃 C，C 吃A。</p><p>现有 N 个动物，以 1∼N 编号。</p><p>每个动物都是 A,B,C 中的一种，但是我们并不知道它到底是哪一种。</p><p>有人用两种说法对这 N 个动物所构成的食物链关系进行描述：</p><p>第一种说法是 <code>1 X Y</code>，表示 X 和 Y 是同类。</p><p>第二种说法是 <code>2 X Y</code>，表示 X 吃 Y。</p><p>此人对 N 个动物，用上述两种说法，一句接一句地说出 K 句话，这 K 句话有的是真的，有的是假的。</p><p>当一句话满足下列三条之一时，这句话就是假话，否则就是真话。</p><ol><li>当前的话与前面的某些真的话冲突，就是假话；</li><li>当前的话中 X 或 Y 比 N 大，就是假话；</li><li>当前的话表示 X吃 X，就是假话。</li></ol><p>你的任务是根据给定的 N 和 K 句话，输出假话的总数。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行是两个整数 NN 和 KK，以一个空格分隔。</p><p>以下 KK 行每行是三个正整数 D，X，YD，X，Y，两数之间用一个空格隔开，其中 DD 表示说法的种类。</p><p>若 D=1，则表示 X 和 Y 是同类。</p><p>若 D=2，则表示 X 吃 Y。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>只有一个整数，表示假话的数目。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤50000<br>0≤K≤100000</p><h4 id="输入样例：-2"><a href="#输入样例：-2" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>100 71 101 1 2 1 22 2 3 2 3 3 1 1 3 2 3 1 1 5 5</code></pre><h4 id="输出样例：-2"><a href="#输出样例：-2" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>3</code></pre><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;const int N = 100010 ;int n , m ;int p[N] ; int dis[N] ;int find(int num)&#123;     if(p[num] != num)    &#123;         int t = find(p[num]) ;       dis[num]  += dis[p[num]] ;       p[num] = t;    &#125;    return p[num] ;&#125;int main()&#123;     cin >> n >> m ;        int res = 0 ;    for(int i = 1 ;i <= n ;++i)       p[i] = i  ;       while(m--)    &#123;         int op , a ,b ;                cin>> op >>a >>b ;            if(a > n || b> n ) res++ ;        else        &#123;             int pa = find(a) ; int pb = find(b) ;            if(op == 1)            &#123;                 if(pa == pb && (dis[a] - dis[b]) %3 )                 &#123;                     res++ ;                &#125;                else if(pa != pb)                &#123;                     p[pa] = pb ;                      dis[pa] = dis[b] - dis[a] ;                &#125;            &#125;            else            &#123;                 if(pa == pb && (dis[a] - dis[b] -1) %3 )                   res++ ;                else if(pa != pb)                &#123;                     p[pa] = pb ;                    dis[pa] = dis[b]+1-dis[a] ;                                 &#125;             &#125;        &#125;     &#125;    cout<<res<<endl ;    return 0  ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串哈希的理解</title>
      <link href="/2021/09/15/zi-fu-chuan-ha-xi-de-li-jie/"/>
      <url>/2021/09/15/zi-fu-chuan-ha-xi-de-li-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h2><hr><p>给定一个长度为 n 的字符串，再给定 m个询问，每个询问包含四个整数 l1,r1,l2,r2请你判断 [l1,r1][l1,r1] 和 [l2,r2][l2,r2] 这两个区间所包含的字符串子串是否完全相同。</p><p>字符串中只包含大小写英文字母和数字。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n 和 m，表示字符串长度和询问次数。</p><p>第二行包含一个长度为 n 的字符串，字符串中只包含大小写英文字母和数字。</p><p>接下来 m 行，每行包含四个整数 l1,r1,l2,r2表示一次询问所涉及的两个区间。</p><p>注意，字符串的位置从 1 开始编号。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个询问输出一个结果，如果两个字符串子串完全相同则输出 <code>Yes</code>，否则输出 <code>No</code>。</p><p>每个结果占一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n,m≤105</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>8 3aabbaabb1 3 5 71 3 6 81 2 1 2</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>YesNoYes</code></pre><hr><pre class="line-numbers language-c++"><code class="language-c++">#include<bits/stdc++.h>using namespace std ;typedef unsigned long long ULL ;const int N  = 1e5+10 , P = 131; //P一般采用131，或者是13331。根据经验判断，这样的将字符串映射成为数值的时候，99%的情况下是不hULL h[N] , p[N] ;//h数组其实就是可以看作是存储前缀和的数组//p其实就是记录当前的进制的数组，当前的位数的价值可以这么理解ULL ToPnumber(int l , int r)&#123;    return h[r]-h[l-1]*p[r-l+1] ;  &#125;/*这个思想就比较妙了，想要算出有固定起始区间的一段字符串的P进制数，其实可以拿少的数扩展来进行相减。举个例子，比如一段数组453672，我想要计算出来3~5区间的数值即367.我可以用45367-45*10的(5-3+1)次方。同样的道理，想要算出l~r的区间代表的P进制的数字，目前有已知h[r]和h[l].直接return h[r]-h[l-1]*(r-l+1) ;*/int main()&#123;    int n , m ;    cin>>n>>m ;    string x ;    cin>>x ;    h[0] = 0 ; p[0] = 1 ;        for(int i = 0 ;i < n ;++i)    &#123;        p[i+1] = p[i]*P  ;        h[i+1] = h[i]*P + x[i] ; //这就是算前缀和的操作    &#125;        for(int i = 0 ; i < m ;++i)    &#123;        int l1 , l2 , l3 ,l4 ;        cin>>l1>>l2>>l3>>l4 ;        if(ToPnumber(l1,l2) == ToPnumber(l3,l4))            cout<<"Yes"<< endl ;        else             cout<<"No"<< endl ;    &#125;        return  0 ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL的用法总结-摘自acwing</title>
      <link href="/2021/09/15/stl-de-yong-fa-zong-jie-zhai-zi-acwing/"/>
      <url>/2021/09/15/stl-de-yong-fa-zong-jie-zhai-zi-acwing/</url>
      
        <content type="html"><![CDATA[<p>vector（变长数组），倍增的思想，支持比较运算（按字典序）<br>    定义：：<br>        vector <int> a; 定义：一个vector数组a<br>        vector <int> a(10); 定义：一个长度为10的vector数组a<br>        vector <int> a(10,3); 定义：一个长度为10的vector数组a，并且所有元素都为3<br>    常用函数：：<br>        size(); 返回元素个数<br>        empty(); 返回是否是空<br>        clear(); 清空<br>        front(); 返回vector的第一个数<br>        back(); 返回vector的最后一个数<br>        push_back(); 向vector的最后插入一个数<br>        pop_back(); 把vector的最后一个数删掉<br>        begin(); vector的第0个数<br>        end(); vector的最后一个的数的后面一个数<br>    倍增的思想：<br>        系统为某一程序分配空间是，所需时间，与空间大小无关，与申请次数有关<br>    遍历方法<br>        假设有个vector <int> a;<br>        第一种：<br>            for(int i = 0;i &lt; a.size();i ++) cout&lt;&lt;a[i]&lt;&lt;” “;<br>        第二种：<br>            for(vector <int>::iterator i = a.begin();i != a.end();i ++) cout&lt;&lt;*i&lt;&lt;” “;  vector <int>::iterator可以写为auto<br>        第三种：<br>            for(auto  x : a) cout&lt;&lt;x&lt;&lt;” “;</p><p>pair，支持比较运算，以first为第一关键字，以second为第二关键字（按字典序）<br>    定义：：<br>        pair &lt;类型,类型&gt; 变量名;    两个类型可以不同<br>    初始化方式：<br>        假设有个pair &lt;int,string&gt; p;<br>        第一种：<br>            p = make_pair(10,”abc”);<br>        第二种：<br>            p = {10,”abc”);<br>    常用函数：：<br>        first(); 第一个元素<br>        second(); 第二个元素</p><p>string（字符串）<br>    常用函数：：<br>        substr(); 返回每一个子串<br>        c_str(); 返回这个string对应的字符数组的头指针<br>        size(); 返回字母个数<br>        length(); 返回字母个数<br>        empty(); 返回字符串是否为空<br>        clear(); 把字符串清空<br>queue（队列）<br>    定义：：<br>        queue &lt;类型&gt; 变量名;<br>    常用函数：：<br>        size(); 这个队列的长度<br>        empty(); 返回这个队列是否为空<br>        push(); 往队尾插入一个元素<br>        front(); 返回队头元素<br>        back(); 返回队尾元素<br>        pop(); 把队头弹出<br>        注意：队列没有clear函数！！！<br>    清空：<br>        变量名 = queue <int> ();<br>priority_queue（优先队列，堆）<br>    注意：默认是大根堆！！！<br>    定义：：<br>        大根堆：priority_queue &lt;类型&gt; 变量名;<br>        小根堆：priority_queue &lt;类型,vecotr &lt;类型&gt;,greater &lt;类型&gt;&gt; 变量名<br>    常用函数：<br>        size(); 这个堆的长度<br>        empty(); 返回这个堆是否为空<br>        push();往堆里插入一个元素<br>        top(); 返回堆顶元素<br>        pop(); 弹出堆顶元素<br>        注意：堆没有clear函数！！！</p><p>stack（栈）<br>    常用函数：<br>        size(); 这个栈的长度<br>        empty(); 返回这个栈是否为空<br>        push(); 向栈顶插入一个元素<br>        top(); 返回栈顶元素<br>        pop(); 弹出栈顶元素</p><p>deque（双端队列）<br>    常用函数：<br>        size(); 这个双端队列的长度<br>        empty(); 返回这个双端队列是否为空<br>        clear(); 清空这个双端队列<br>        front(); 返回第一个元素<br>        back(); 返回最后一个元素<br>        push_back(); 向最后插入一个元素<br>        pop_back(); 弹出最后一个元素<br>        push_front(); 向队首插入一个元素<br>        pop_front(); 弹出第一个元素<br>        begin(); 双端队列的第0个数<br>        end(); 双端队列的最后一个的数的后面一个数</p><p>set，map，multiset，multimap 基于平衡二叉树（红黑树），动态维护有序序列<br>    set/multiset<br>        注意：set不允许元素重复，如果有重复就会被忽略，但multiset允许！！！<br>        常用函数：<br>            size(); 返回元素个数<br>            empty(); 返回set是否是空的<br>            clear(); 清空<br>            begin(); 第0个数，支持++或–，返回前驱和后继<br>            end(); 最后一个的数的后面一个数，支持++或–，返回前驱和后继<br>            insert(); 插入一个数<br>            find(); 查找一个数<br>            count(); 返回某一个数的个数<br>            erase();<br>                （1）输入是一个数x，删除所有x    O(k + log n)<br>                （2）输入一个迭代器，删除这个迭代器<br>            lower_bound(x); 返回大于等于x的最小的数的迭代器<br>            upper_bound(x); 返回大于x的最小的数的迭代器<br>    map/multimap<br>        常用函数：<br>            insert(); 插入一个数，插入的数是一个pair<br>            erase();<br>                （1）输入是pair<br>                （2）输入一个迭代器，删除这个迭代器<br>            find(); 查找一个数<br>            lower_bound(x); 返回大于等于x的最小的数的迭代器<br>            upper_bound(x); 返回大于x的最小的数的迭代器</p><p>unordered_set，unordered_map，unordered_muliset,unordered_multimap 基于哈希表<br>    和上面类似，增删改查的时间复杂度是O(1)<br>    不支持lower_bound()和upper_bound()</p><p>bitset 压位<br>    定义：<br>        bitset &lt;个数&gt; 变量名;<br>    支持：<br>        <del>，&amp;，|，^<br>        &gt;&gt;，&lt;&lt;<br>        ==，!=<br>        []<br>    常用函数：<br>        count(); 返回某一个数的个数<br>        any(); 判断是否至少有一个1<br>        none(); 判断是否全为0<br>        set(); 把所有位置赋值为1<br>        set(k,v); 将第k位变成v<br>        reset(); 把所有位变成0<br>        flip(); 把所有位取反，等价于</del><br>        flip(k); 把第k位取反</p><p>作者：yxc<br>链接：<a href="https://www.acwing.com/video/20/">https://www.acwing.com/video/20/</a><br>来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      
        <tags>
            
            <tag> acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据范围的判断-摘自acwing</title>
      <link href="/2021/09/12/shu-ju-fan-wei-de-pan-duan-zhai-zi-acwing/"/>
      <url>/2021/09/12/shu-ju-fan-wei-de-pan-duan-zhai-zi-acwing/</url>
      
        <content type="html"><![CDATA[<p>一般ACM或者笔试题的时间限制是1秒或2秒。<br>在这种情况下，C++代码中的操作次数控制在 10的七次方到10的八次方为最佳。</p><p>下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：</p><p>n≤30, 指数级别, dfs+剪枝，状态压缩dp<br>n≤100 =&gt; O(n3)，floyd，dp，高斯消元<br>n≤1000=&gt; O(n2)，O(n2logn)，dp，二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford<br>n≤10000 =&gt; O(n∗√n)，块状链表、分块、莫队<br>n≤100000=&gt; O(nlogn) =&gt; 各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分<br>n≤1000000=&gt; O(n), 以及常数较小的 O(nlogn) 算法 =&gt; 单调队列、 hash、双指针扫描、并查集，kmp、AC自动机，常数比较小的 O(nlogn)的做法：sort、树状数组、heap、dijkstra、spfa<br>n≤10000000=&gt; O(n)，双指针扫描、kmp、AC自动机、线性筛素数<br>n≤10的9次方 =&gt; O(√n)，判断质数<br>n≤10的18次方 =&gt; O(logn)，最大公约数，快速幂<br>n≤10的1000次方=&gt; O((logn)2)，高精度加减乘除<br>n≤10的1000000次方 =&gt; O(logk×loglogk)，k表示位数，高精度加减、FFT/NTT</p><p>作者：yxc<br>链接：<a href="https://www.acwing.com/blog/content/32/">https://www.acwing.com/blog/content/32/</a><br>来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      
        <tags>
            
            <tag> acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题思考</title>
      <link href="/2021/09/09/bei-bao-wen-ti-si-kao/"/>
      <url>/2021/09/09/bei-bao-wen-ti-si-kao/</url>
      
        <content type="html"><![CDATA[<h2 id="背包问题分类："><a href="#背包问题分类：" class="headerlink" title="背包问题分类："></a>背包问题分类：</h2><h3 id="1-01背包问题"><a href="#1-01背包问题" class="headerlink" title="1.01背包问题"></a>1.01背包问题</h3><hr><p>有 NN 件物品和一个容量是 VV 的背包。每件物品只能使用一次。</p><p>第 ii 件物品的体积是 vivi，价值是 wiwi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 NN 行，每行两个整数 vi,wivi,wi，用空格隔开，分别表示第 ii 件物品的体积和价值。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N,V≤10000&lt;N,V≤1000<br>0&lt;vi,wi≤10000&lt;vi,wi≤1000</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><pre><code>4 51 22 43 44 5</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>8</code></pre><hr><pre class="line-numbers language-c++"><code class="language-c++">//朴素算法#include<bits/stdc++.h>using namespace std ;const int N = 1010 ;int dp[N][N] ;int v[N], w[N] ;int main()&#123;    int m, n ; cin>>m >> n ;    for(int i = 1 ; i<= m ;++i ) cin >> v[i]>>w[i] ;        for(int i = 1 ; i<= m ;++i) &#123;        for(int j = 0 ; j<= n ;++j)&#123;            dp[i][j] = dp[i-1][j] ;            if(j>= v[i]) dp[i][j] = max(dp[i-1][j-v[i]]+w[i]) ;        &#125;    &#125;    cout<< dp[m][n]<<endl ;    return 0 ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">//进行优化#include<bits/stdc++.h>using namespace std ;const int N = 1010 ;int dp[N] ; int v[N] ; int w[N] ;int main()&#123;    int m ,n ;     cin>> m >> n ;    for(int i = 1 ;i<= m; ++i) cin>> v[i]>>w[i] ;    for(int i = 1; i<= m ;++i )        for(int j = n ; j>= v[i] ;--j )            dp[j] = max(dp[j], dp[j-v[i]]+w[i]) ;    cout<<dp[n] <<endl ;    return 0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-完全背包问题"><a href="#2-完全背包问题" class="headerlink" title="2.完全背包问题"></a>2.完全背包问题</h3><p>有 NN 种物品和一个容量是 VV 的背包，每种物品都有无限件可用。</p><p>第 ii 种物品的体积是 vivi，价值是 wiwi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，VN，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 NN 行，每行两个整数 vi,wivi,wi，用空格隔开，分别表示第 ii 种物品的体积和价值。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N,V≤10000&lt;N,V≤1000<br>0&lt;vi,wi≤10000&lt;vi,wi≤1000</p><h4 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a>输入样例</h4><pre><code>4 51 22 43 44 5</code></pre><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>10</code></pre><pre class="line-numbers language-c++"><code class="language-c++">#这种算法最直观，但是会超时间，此题的数据是在1000 ，这有一个三层循环应该是在10的九次方左右，会超时,所以就有了之后的优化算法#include<bits/stdc++.h>using namespace std ;const int N = 1010 ;int f[N][N] ; int v[N] ; int w[N] ;int main()&#123;    int m ,n  ;    cin>>m>>n ;    for(int i = 1 ; i<= m ;++i) cin>> v[i]>>w[i] ;    for(int i = 1 ; i<= m ;++i ) &#123;        for(int j = 0 ; j<= n ;++j)&#123;            f[i][j] = f[i-1][j] ;                        for(int k = 1 ; j-k*v[i] >= 0 ; k++)&#123;                f[i][j]  = max(f[i][j] , f[i-1][j-k*v[i]]+k*w[i]) ;            &#125;        &#125;    &#125;    cout<< f[m][n] <<endl ;    return 0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">//朴素算法#include<bits/stdc++.h>using namespace std ;const int N =  1010 ;int dp[N][N] ; int v[N]; int w[N] ;int main()&#123;    int m , n ;    cin>>m >>n ;    for(int i = 1 ;i<= m ;++i) cin>> v[i]>>w[i] ;    for(int i = 1; i<= m ; ++i)         for(int j = 0 ; j<= n ++j)&#123;            dp[i][j] = dp[i-1][j] ;            if(j >= v[i]) dp[i][j] = max(dp[i][j], dp[i][j-v[i]]+w[i]) ;        &#125;    cout<< dp[m][n] <<endl ;    return 0 ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">//优化算法#include<bits/stdc++.h>using namespace std ;const int N = 1010; int dp[N] ; int v[N] ;int w[N] ; int main()&#123;    int m , n ;    cin>>m >> n ;     for(int i =1 ; i <= m ;++i) cin>>v[i]>>w[i] ;        for(int i = 1; i <= m ;++i)        for(int j = v ; j<= n ;++j)            dp[j] = max(dp[j], dp[j-v[i]]+w[i]) ;        cout>>dp[n] ;    return 0 ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-多重背包问题"><a href="#3-多重背包问题" class="headerlink" title="3.多重背包问题"></a>3.多重背包问题</h2><p>有 NN 种物品和一个容量是 VV 的背包。</p><p>第 ii 种物品最多有 sisi 件，每件体积是 vivi，价值是 wiwi。</p><p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，VN，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 NN 行，每行三个整数 vi,wi,sivi,wi,si，用空格隔开，分别表示第 ii 种物品的体积、价值和数量。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N,V≤1000&lt;N,V≤100<br>0&lt;vi,wi,si≤1000&lt;vi,wi,si≤100</p><h4 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例"></a>输入样例</h4><pre><code>4 51 2 32 4 13 4 34 5 2</code></pre><h4 id="输出样例：-2"><a href="#输出样例：-2" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>10</code></pre><pre class="line-numbers language-c++"><code class="language-c++">#这能ac是我妹想到的，总之这是一个最朴素的做法，我估计数据增强之后就不可以了#include<bits/stdc++.h>using namespace std ;const int N = 1010 ;int f[N][N] ;int v[N] ; int w[N] ;int s[N];int main()&#123;    int m ,n  ;    cin>>m >>n ;    for(int i = 1 ; i<= m ;++i) cin>>v[i]>>w[i]>>s[i] ;        for(int i = 1 ;i<= m ;++i)&#123;        for(int j = 0 ;j<=n ;++j)&#123;            f[i][j] = f[i-1][j] ;            for(int k = 1 ; k<= s[i]&& j-k*v[i]>= 0 ;++k)&#123;                f[i][j] = max(f[i][j], f[i-1][j-k*v[i]]+k*w[i]) ;            &#125;        &#125;    &#125;    cout<<f[m][n]<<endl ;    return 0 ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>妙</title>
      <link href="/2021/09/09/miao/"/>
      <url>/2021/09/09/miao/</url>
      
        <content type="html"><![CDATA[<h2 id="799-最长连续不重复子序列"><a href="#799-最长连续不重复子序列" class="headerlink" title="799.最长连续不重复子序列"></a>799.最长连续不重复子序列</h2><hr><p>给定一个长度为 nn 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 nn。</p><p>第二行包含 nn 个整数（均在 0∼1050∼105 范围内），表示整数序列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤105</p><hr><hr><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>51 2 2 3 5</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>3</code></pre><hr><p>核心思路：</p><p>1.对于重复的理解</p><p>不是单纯的判断==的关系，而是多申请了一个额外的数组，充当一个hash table，把原元素当成key值，记录元素的频率。当频率大于1的时候，就是重复了.</p><p>2.对于间断的时机的理解</p><p>由于推理逻辑是具有连续性的，所以，由于前一个i到j的区间是不重复的，但是之后出现了重复。只有一种可能，那就是最新的p[i]与之前区间里面的数据重复了。即只需要“恰头”，一个循环一直丢头，直到p[i]的频率为1为止。</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;#define read(x) scanf("%d",&x) ;const int N = 100010 ;int main()&#123;    int n ; int r = 0 ;  int p[N] ; int s[N] = &#123;0&#125; ;    read(n) ;     for(int i = 0 ,j = 0 ; i< n ;++i)&#123;        read(p[i]) ;        s[p[i]] ++ ;        while(s[p[i]] > 1) --s[p[j++]] ;        r = max(r, i-j+1) ;    &#125;    cout<< r<< endl ;    return 0 ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2007-从双倍数组中还原原数组"><a href="#2007-从双倍数组中还原原数组" class="headerlink" title="2007.从双倍数组中还原原数组"></a>2007.从双倍数组中还原原数组</h2><hr><p>一个整数数组 original 可以转变成一个 双倍 数组 changed ，转变方式为将 original 中每个元素 值乘以 2 加入数组中，然后将所有元素 随机打乱 。</p><p>给你一个数组 changed ，如果 change 是 双倍 数组，那么请你返回 original数组，否则请返回空数组。original 的元素可以以 任意 顺序返回。</p><p>示例 1：</p><p>输入：changed = [1,3,4,2,6,8]<br>输出：[1,3,4]<br>解释：一个可能的 original 数组为 [1,3,4] :</p><ul><li>将 1 乘以 2 ，得到 1 * 2 = 2 。</li><li>将 3 乘以 2 ，得到 3 * 2 = 6 。</li><li>将 4 乘以 2 ，得到 4 * 2 = 8 。<br>其他可能的原数组方案为 [4,3,1] 或者 [3,1,4] 。<br>示例 2：</li></ul><p>输入：changed = [6,3,0,1]<br>输出：[]<br>解释：changed 不是一个双倍数组。<br>示例 3：</p><p>输入：changed = [1]<br>输出：[]<br>解释：changed 不是一个双倍数组。</p><p>提示：</p><p>1 &lt;= changed.length &lt;= 105<br>0 &lt;= changed[i] &lt;= 105</p><hr><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    vector<int> findOriginalArray(vector<int>& a) &#123;        sort(a.begin(), a.end());        int res = 0;        unordered_map<int, int> mp;        vector<int> b;        for(auto &v: a)&#123;            if(mp[v]==0)&#123;                mp[2*v]++;        //只标记双倍的                b.push_back(v);            &#125;else&#123;                mp[v]--;         //如果双倍的值也在changed数组里面，那么双倍标记就会清除掉            &#125;        &#125;        for(auto &[k, v]: mp)&#123;            if(v) res++;            //如果有value值不是零的，说明是因为前面有值的二倍而在后面找不到，所以就冗余下来了        &#125;        if(res) return &#123;&#125;;        return b;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针算法专题</title>
      <link href="/2021/09/09/shuang-zhi-zhen-suan-fa-zhuan-ti/"/>
      <url>/2021/09/09/shuang-zhi-zhen-suan-fa-zhuan-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="一、不修改数组找出重复的数字"><a href="#一、不修改数组找出重复的数字" class="headerlink" title="一、不修改数组找出重复的数字"></a>一、不修改数组找出重复的数字</h1><p>给定一个长度为n+1 的数组<code>nums</code>，数组中所有的数均在 1∼n 的范围内，其中 n≥1。</p><p>请找出数组中任意一个重复的数，但不能修改输入的数组。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><pre><code>给定 nums = [2, 3, 5, 4, 3, 2, 6, 7]。返回 2 或 3。</code></pre><p><strong>思考题</strong>：如果只能使用 O(1) 的额外空间，该怎么做呢？</p><pre class="line-numbers language-c++"><code class="language-c++">//我的第一反应是一般看到重复什么的，我就会下意识的想到hash，于是我就写了一种数组hash的方法class Solution &#123;public:    int duplicateInArray(vector<int>& nums) &#123;        int vim[1000010] = &#123;0&#125; ;        int n = nums.size() ;        for(int i =  0 ; i < n ;++i)        &#123;            vim[nums[i]] ++ ;            if(vim[nums[i]] > 1 )                return nums[i] ;        &#125;        return 0 ;    &#125;&#125;;//这样时间复杂度是o(n) ,空间复杂度是o(n)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我又看到了有大佬用模拟链表来做，觉得是很有意思的思路。于是学习了.</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    int duplicateInArray(vector<int>& nums) &#123;        int slow = 0 , fast = 0 ;                do        &#123;            fast = nums[nums[fast]] ;            slow = nums[slow] ;        &#125;while(slow != fast) ;            fast = 0 ;                do        &#123;            fast = nums[fast] ;             slow = nums[slow] ;        &#125;while(fast != slow) ;   return slow ;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度是o(n) ,空间复杂度是o(1) 。</p><p>妙在用数组模拟链表的思路：</p><p>基于是链表找环的问题，题目是这样的</p><p><a href="https://leetcode-cn.com/problems/c32eOV/">剑指 Offer II 022. 链表中环的入口节点 - 力扣（LeetCode） (leetcode-cn.com)</a></p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    ListNode *detectCycle(ListNode *head) &#123;        if(head == NULL || head->next == NULL) return NULL ;        ListNode* fast = head->next->next ;        ListNode* slow = head->next ;        while(fast && fast->next )        &#123;            fast = fast->next->next ;            slow = slow->next ;            if(slow == fast)             break ;        &#125;        if(slow != fast) return NULL ;        else fast  = head ;        while(slow != fast)        &#123;            slow = slow->next ;            fast = fast->next ;        &#125;        return fast ;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大佬采用的是用数组下标映射值的方法，因为本题正好下标的范围其实在0-n，值的范围在1-n，也就是说存在可以相互映射的可能。</p><p>把数组全部转换成链表之后是</p><p>2-&gt;5-&gt;2 然后就是死循环了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串算法专题</title>
      <link href="/2021/09/08/zi-fu-chuan-suan-fa-zhuan-ti/"/>
      <url>/2021/09/08/zi-fu-chuan-suan-fa-zhuan-ti/</url>
      
        <content type="html"><![CDATA[<p>节选了字符串部分的一些有共性和特性的一些题目</p><h2 id="5-最长回文字符串"><a href="#5-最长回文字符串" class="headerlink" title="5.最长回文字符串"></a>5.最长回文字符串</h2><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><hr><p>示例1：</p><p>输入：s = “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。<br>示例 2：</p><p>输入：s = “cbbd”<br>输出：”bb”<br>示例 3：</p><p>输入：s = “a”<br>输出：”a”<br>示例 4：</p><p>输入：s = “ac”<br>输出：”a”</p><hr><hr><p>提示：</p><p>1 &lt;= s.length &lt;= 1000<br>s 仅由数字和英文字母（大写和/或小写）组成</p><hr><p>法一：中心扩散法</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    vector<int> maxlength(string s, int start, int end)&#123;        int n  = s.size() ;        vector<int> ans(2) ;        while(start>= 0 && end<n )&#123;            if(s[start]  == s[end])&#123;                start -- ; end++ ;            &#125;            else             break;        &#125;            start++ ; end-- ;            ans[0] = start ; ans[1] = end-start+1 ;            return ans ;    &#125;    string longestPalindrome(string s) &#123;        vector<int> ji(2) ; vector<int> ou(2)  ; vector<int> result(2) ;         int n = s.size() ;        if(n == 1) return s ;        int max =0  ;         for(int i = 0 ;i<n-1 ;++i)&#123;            ji = maxlength(s,i,i) ;            ou = maxlength(s,i,i+1) ;            int length = ji[1]>ou[1] ? ji[1]:ou[1] ;            if(length>max)&#123;                max = length ;                result = ji[1]>ou[1] ? ji:ou ;            &#125;        &#125;         return s.substr (result[0], result[1]) ;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>法二：动态规划法</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    string longestPalindrome(string s) &#123;        int n = s.size();        if (n < 2) &#123;            return s;        &#125;        int maxLen = 1;        int begin = 0;        // dp[i][j] 表示 s[i..j] 是否是回文串        vector<vector<int>>  dp(n, vector<int>(n));        // 初始化：所有长度为 1 的子串都是回文串        for (int i = 0; i < n; i++) &#123;            dp[i][i] = true;        &#125;        // 递推开始        // 先枚举子串长度        for (int L = 2; L <= n; L++) &#123;            // 枚举左边界，左边界的上限设置可以宽松一些            for (int i = 0; i < n; i++) &#123;                // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得                int j = L + i - 1;                // 如果右边界越界，就可以退出当前循环                if (j >= n) &#123;                    break;                &#125;                if (s[i] != s[j]) &#123;                    dp[i][j] = false;                &#125; else &#123;                    if (j - i < 3) &#123;                        dp[i][j] = true;                    &#125; else &#123;                        dp[i][j] = dp[i + 1][j - 1];                    &#125;                &#125;                // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置                if (dp[i][j] && j - i + 1 > maxLen) &#123;                    maxLen = j - i + 1;                    begin = i;                &#125;            &#125;        &#125;        return s.substr(begin, maxLen);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516.最长回文子序列"></a>516.最长回文子序列</h2><hr><p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><hr><hr><p>示例 1：</p><p>输入：s = “bbbab”<br>输出：4<br>解释：一个可能的最长回文子序列为 “bbbb” 。<br>示例 2：</p><p>输入：s = “cbbd”<br>输出：2<br>解释：一个可能的最长回文子序列为 “bb” 。</p><hr><hr><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul><hr><p>法一：动态规划法</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    int longestPalindromeSubseq(string s) &#123;        int n = s.size() ;        vector<vector<int>> dp(n,vector<int>(n,0)); //初始化二维的容器        for(int i = 0;i<n;i++)&#123;    //给每一个一个元素的附上初值            dp[i][i] = 1 ;        &#125;        for(int j = 0;j<n;j++)&#123;            for(int i = j-1;i>=0;i--)&#123;                if(s[i] == s[j])                dp[i][j] = dp[i+1][j-1] +2 ;                else                dp[i][j] = max(dp[i+1][j],dp[i][j-1]) ;            &#125;        &#125;       return dp[0][n-1] ;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="541-反转字符串II"><a href="#541-反转字符串II" class="headerlink" title="541.反转字符串II"></a>541.反转字符串II</h2><hr><p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每 2k 个字符反转前 k 个字符。</p><p>如果剩余字符少于 k 个，则将剩余字符全部反转。<br>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p><hr><hr><p>示例 1：</p><p>输入：s = “abcdefg”, k = 2<br>输出：”bacdfeg”<br>示例 2：</p><p>输入：s = “abcd”, k = 2<br>输出：”bacd”</p><hr><p>提示：</p><p>1 &lt;= s.length &lt;= 104<br>s 仅由小写英文组成<br>1 &lt;= k &lt;= 104</p><hr><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    string reverseStr(string s, int k) &#123;        int n = s.size() ;        for(int i = 0;i<n;i+=2*k)&#123;            reverse(s.begin()+i,s.begin()+min(n,k+i)) ;        &#125;        return s ;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763.划分字母区间"></a>763.划分字母区间</h2><hr><p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p><hr><hr><p>示例：</p><p>输入：S = “ababcbacadefegdehijhklij”<br>输出：[9,7,8]<br>解释：<br>划分结果为 “ababcbaca”, “defegde”, “hijhklij”。<br>每个字母最多出现在一个片段中。<br>像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。</p><hr><hr><p><strong>提示：</strong></p><ul><li><code>S</code>的长度在<code>[1, 500]</code>之间。</li><li><code>S</code>只包含小写字母 <code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code> 。</li></ul><hr><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    vector<int> partitionLabels(string s) &#123;       vector<int>ans,ends(26,-1) ;          //这一步是申请两个vector，一个是用来return，一个是用来反映元素最后出现的位置信号       for(int i = 0;i<s.length();i++)&#123;           ends[s[i]-'a'] = i ;                          &#125;       int i = 0 ;       int end = 0 ;       while(i<s.length())&#123;           end = ends[s[i]-'a'] ;           for(int k = i+1;k<end;k++)&#123;               end = max(end,ends[s[k]-'a']) ;           &#125;           ans.push_back(end-i+1) ;           i = end+1 ;       &#125;      return ans ;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="680-验证回文字符串II"><a href="#680-验证回文字符串II" class="headerlink" title="680.验证回文字符串II"></a>680.验证回文字符串II</h2><hr><p>给定一个非空字符串 <code>s</code>，<strong>最多</strong>删除一个字符。判断是否能成为回文字符串。</p><hr><hr><p>示例 1:</p><p>输入: s = “aba”<br>输出: true<br>示例 2:</p><p>输入: s = “abca”<br>输出: true<br>解释: 你可以删除c字符。<br>示例 3:</p><p>输入: s = “abc”<br>输出: false</p><hr><hr><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s</code> 由小写英文字母组成</li></ul><hr><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    bool validPalindrome(string s) &#123;    if(s.length() <= 2)    return true ;    else&#123;      int left = 0 ;      int right = s.length()-1 ;      while(left<right)&#123;        if(s[left] != s[right])&#123;            if(isornot(s,left+1,right) ||isornot(s,left,right-1))            return true ;            else            return false ;        &#125;        left++ ;        right-- ;      &#125;    &#125;    return true ;    &#125;    public:bool isornot(string t,int l,int r)&#123;    while(l<r)&#123;     if(t[l] == t[r])&#123;     l++ ;     r-- ;     &#125;     else     return false ;    &#125;    return true ;&#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49.字母异位词分组"></a>49.字母异位词分组</h2><hr><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p><p>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母都恰好只用一次。</p><hr><hr><p>示例 1:</p><p>输入: strs = [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]<br>输出: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]<br>示例 2:</p><p>输入: strs = [“”]<br>输出: [[“”]]<br>示例 3:</p><p>输入: strs = [“a”]<br>输出: [[“a”]]</p><hr><hr><p><strong>提示：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 104</code></li><li><code>0 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code> 仅包含小写字母</li></ul><hr><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    vector<vector<string>> groupAnagrams(vector<string>& strs) &#123;        int num[26] = &#123;2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101&#125; ;        unordered_map<unsigned long long ,vector<string>> mp ;        vector<vector<string>> result ;        for(string s : strs)&#123;            unsigned long long key = 1 ;            for(char c: s)&#123;                key *= num[c-'a'] ;            &#125;            mp[key].push_back(s) ;        &#125;        for(auto p : mp)&#123;            result.push_back(p.second) ;        &#125;        return result ;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="524-通过删除字母匹配到字典里最长单词"><a href="#524-通过删除字母匹配到字典里最长单词" class="headerlink" title="524.通过删除字母匹配到字典里最长单词"></a>524.通过删除字母匹配到字典里最长单词</h2><hr><p>给你一个字符串 s 和一个字符串数组 dictionary 作为字典，找出并返回字典中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。</p><p>如果答案不止一个，返回长度最长且字典序最小的字符串。如果答案不存在，则返回空字符串。</p><hr><hr><p>示例 1：</p><p>输入：s = “abpcplea”, dictionary = [“ale”,”apple”,”monkey”,”plea”]<br>输出：”apple”<br>示例 2：</p><p>输入：s = “abpcplea”, dictionary = [“a”,”b”,”c”]<br>输出：”a”</p><hr><hr><p>提示：</p><p>1 &lt;= s.length &lt;= 1000<br>1 &lt;= dictionary.length &lt;= 1000<br>1 &lt;= dictionary[i].length &lt;= 1000<br>s 和 dictionary[i] 仅由小写英文字母组成</p><hr><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    string findLongestWord(string s, vector<string>& dictionary) &#123;     sort(dictionary.begin(),dictionary.end(),[](string a,string b)&#123;         if(a.length() == b.length())         return a<b ;         return a.length()>b.length() ;     &#125;) ;     for(string str:dictionary)&#123;        int i = 0 ;        for(char c: s)&#123;            if(i<str.size() && c == str[i])            i++ ;           if(i == str.size())           return str ;        &#125;     &#125;     return "" ;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76.最小覆盖子串"></a>76.最小覆盖子串</h2><h2 id="443-压缩字符串"><a href="#443-压缩字符串" class="headerlink" title="443.压缩字符串"></a>443.压缩字符串</h2>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法专题</title>
      <link href="/2021/09/08/tan-xin-suan-fa-zhuan-ti/"/>
      <url>/2021/09/08/tan-xin-suan-fa-zhuan-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="贪心算法总结"><a href="#贪心算法总结" class="headerlink" title="贪心算法总结"></a>贪心算法总结</h1><h2 id="贪心算法简述"><a href="#贪心算法简述" class="headerlink" title="贪心算法简述"></a>贪心算法简述</h2><p>贪心算法是原理最简单的一种算法，甚至可以将其中一些部分理解为常识或者是常规思维。</p><p>他采取贪心的策略，即保证每次操作都是最优的，先得到局部的最优解，从而使最终的结果是最优的。</p><h2 id="leetcode刷题"><a href="#leetcode刷题" class="headerlink" title="leetcode刷题"></a>leetcode刷题</h2><h3 id="分配问题"><a href="#分配问题" class="headerlink" title="分配问题"></a>分配问题</h3><h3 id="455-Assign-Cookies-Easy"><a href="#455-Assign-Cookies-Easy" class="headerlink" title="455.Assign Cookies(Easy)"></a>455.Assign Cookies(Easy)</h3><h5 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h5><p>有一群孩子和一堆饼干，每个孩子都有一个饥饿度，每个饼干都有一个大小。每个孩子只能吃最多一个饼干，且只有饼干的大小大于孩子的饥饿度时，这个孩子才可以吃饱。求解最多有多少个孩子可以吃饱。</p><h5 id="输入输出样例："><a href="#输入输出样例：" class="headerlink" title="输入输出样例："></a>输入输出样例：</h5><hr><p>Input : [1,2],[1,2,3] </p><p>Output : 2</p><hr><h5 id="一些想法："><a href="#一些想法：" class="headerlink" title="一些想法："></a>一些想法：</h5><p>这里的贪心策略就是尽可能的将剩余孩子中饥饿度最小的满足，每一次只考虑最小的饥饿度。</p><p>所以算法实现就是先将所有孩子的饥饿度和饼干的大小从大到小进行排序，然后设置两个指针分别指向child和cookie，当遇到cookie的值大于等于孩子的饥饿度时，即满足条件，故将指针均后移即可。若不满足，cookie后移即可。当有一个到达尽头时，循环结束。返回已经满足的孩子数量。</p><h5 id="代码部分："><a href="#代码部分：" class="headerlink" title="代码部分："></a>代码部分：</h5><pre class="line-numbers language-c++"><code class="language-c++">int findContentChildren(vector<int>& children,vector<int>& cookies) &#123;    int child = 0 ;    int cookie = 0 ;    while(child<children.size() && cookie<cookies.size())&#123;        if(children[child] <= cookies[cookie])&#123;            child++ ;            cookie++ ;        &#125;        else            cookie++ ;    &#125;    return child ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="135-Candy-Hard"><a href="#135-Candy-Hard" class="headerlink" title="135.Candy(Hard)"></a>135.Candy(Hard)</h3><h5 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h5><p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p><p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p><p>每个孩子至少分配到 1 个糖果。</p><p>评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。</p><p>那么这样下来，老师至少需要准备多少颗糖果呢？</p><h5 id="输入输出样例：-1"><a href="#输入输出样例：-1" class="headerlink" title="输入输出样例："></a>输入输出样例：</h5><hr><p>Input : [1,0,2]</p><p>Output : 5</p><hr><hr><p>Input : [1,2,2]</p><p>Output : 4</p><hr><h5 id="一些想法：-1"><a href="#一些想法：-1" class="headerlink" title="一些想法："></a>一些想法：</h5><p>一开始为了有一个基准值，方便比较，同时题目要求所有孩子都至少有一个糖果，所以先应该将所有孩子的糖果全部初始化为1.</p><p>可以分成两边进行考虑，进行两轮的遍历。如果遇到自己比邻位大的话，就在邻位的基础上加一即可。</p><p>最后将所有值相加并返回即可。</p><h5 id="代码部分：-1"><a href="#代码部分：-1" class="headerlink" title="代码部分："></a>代码部分：</h5><pre class="line-numbers language-c++"><code class="language-c++">int candy(vector<int>& ratings)&#123;    int size = ratings.size() ;    if(size <= 1)    return size ;    vector<int> candies(,1) ;   //将所有的糖果数全部初始化为1    //第一轮，从左往右进行比对    for(int i = 1 ;i < size ; i++)&#123;        if(ratings[i] > ratings[i-1])&#123;            candies[i] = candies[i-1]+1 ;        &#125;    &#125;    //第二轮，从右向左进行比对    for(int i = size-1 ; i > 0; i--)&#123;        if(ratings[i-1] > ratings[i])&#123;            candies[i-1] = max(candies[i-1],ratings[i]+1) ;        &#125;    &#125;    //最终返回所有值的和    return accumulate(candies.begin(),candies.end(),0) ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h3><h3 id="435-Non-overlapping-Intervals-Medium"><a href="#435-Non-overlapping-Intervals-Medium" class="headerlink" title="435.Non-overlapping Intervals(Medium)"></a>435.Non-overlapping Intervals(Medium)</h3><h5 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h5><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><h5 id="输入输出样例：-2"><a href="#输入输出样例：-2" class="headerlink" title="输入输出样例："></a>输入输出样例：</h5><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20210730165723809.png" alt="image-20210730165723809" style="zoom:100%;" /><h5 id="一些想法：-2"><a href="#一些想法：-2" class="headerlink" title="一些想法："></a>一些想法：</h5><p>选取的贪心策略是先对于所有区间的尾节点，进行升序排序，然后以保留尾节点最小而且与前一个结点无重叠区间为优先。</p><p>排序的时候会用到c++的lamda表达式，可以利用其与sort结合进行自定义排序。</p><h5 id="代码部分：-2"><a href="#代码部分：-2" class="headerlink" title="代码部分："></a>代码部分：</h5><pre class="line-numbers language-c++"><code class="language-c++">int eraseOverlapIntervals(vector<vector<int>>& intervals)&#123;    int sum = 0 ; //肯定要先设置一个计数器    //进行按照尾节点的升序排序    sort(intervals.begin(),intervals.end(),[](vector<int> a,vector<int> b)&#123;        return a[1]>b[1] ;    &#125;) ;    int pre = intervals[0][1] ;    for(int i = 1 ; i < intervals.size() ; i++)&#123;        if(intervals[i][0] < pre)&#123;            sum++ ;        &#125;        else&#123;            pre = intervals[i][1] ;        &#125;    &#125;    return sum ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>luolin-first-blog</title>
      <link href="/2021/09/05/luolin-first-blog/"/>
      <url>/2021/09/05/luolin-first-blog/</url>
      
        <content type="html"><![CDATA[<p>这是我的第一篇博客，等熟悉了流程之后会频繁的更新博客，因为这也算是自己学习的过程的记录。</p><p>我是罗林 来自南京农业大学 专业是数据科学与大数据技术 </p><p>这个博客是为了记录我的学习生活，以及生活中的一些有趣的事情。</p><p>应该会先分为两个板块：机器学习，数据结构与算法。</p><p>之后有新的认知或者是对新的领域有兴趣可能会在追加几个板块。</p><p>我的座右铭是 一直学习，做一个有趣的人！希望有同样热爱计算机的geek们与我交流！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> selfintroduction </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
