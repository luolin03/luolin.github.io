<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>并查集</title>
      <link href="/2021/09/15/bing-cha-ji/"/>
      <url>/2021/09/15/bing-cha-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="1-目的"><a href="#1-目的" class="headerlink" title="1.目的"></a>1.目的</h2><h3 id="一、合并两个集合"><a href="#一、合并两个集合" class="headerlink" title="一、合并两个集合"></a>一、合并两个集合</h3><p>即将其中的一个集合作为另外一个集合的son。</p><h3 id="二、判断两个元素是否在同一个集合里面"><a href="#二、判断两个元素是否在同一个集合里面" class="headerlink" title="二、判断两个元素是否在同一个集合里面"></a>二、判断两个元素是否在同一个集合里面</h3><p>集合的表示方式是用树来表示(不一定是二叉树)， 每个节点存储的是当前的节点的父亲节点，根节点存储的是该集合的编号。即只需要两个元素(树的节点)一直溯源，查找到根节点对应的编号。若编号相同，则在同一个集合里面。</p><h2 id="2-优化"><a href="#2-优化" class="headerlink" title="2.优化"></a>2.优化</h2><p>优化的环节主要在于查找根节点的步骤。</p><p>朴素的做法是，假设p[x]是x节点的上一个节点.</p><pre class="line-numbers language-c++"><code class="language-c++">while(p[x] == x) x = p[x] ; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样会导致时间复杂度较高。</p><p>优化方式：路径压缩。即从一个节点查找根节点之后，将途中的所有的节点的p[x]都指向根节点。这样一旦在需要重复寻根的时候，可以大大节省时间。</p><h2 id="3-模板题"><a href="#3-模板题" class="headerlink" title="3.模板题"></a>3.模板题</h2><p>一共有 n 个数，编号是 1∼n，最开始每个数各自在一个集合中。</p><p>现在要进行 m 个操作，操作共有两种：</p><ol><li><code>M a b</code>，将编号为 a和 b 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；</li><li><code>Q a b</code>，询问编号为 a和b 的两个数是否在同一个集合中；</li></ol><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入整数 n 和 m。</p><p>接下来 m 行，每行包含一个操作指令，指令为 <code>M a b</code> 或 <code>Q a b</code> 中的一种。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个询问指令 <code>Q a b</code>，都要输出一个结果，如果 a和 b 在同一集合内，则输出 <code>Yes</code>，否则输出 <code>No</code>。</p><p>每个结果占一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n,m≤105</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>4 5M 1 2M 3 4Q 1 2Q 1 3Q 3 4</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>YesNoYes</code></pre><pre class="line-numbers language-c++"><code class="language-c++">#include<bits/stdc++.h>using namespace std ;const int N = 100010 ;int p[N] ;int find(int num)&#123;   //这一步是比较妙的，既找到了num的祖宗节点，而且还实现了路径压缩，每一个节点的父节点都是根节点了    if(p[num] != num)    &#123;        p[num] = find(p[num]) ;    &#125;    return p[num] ;&#125;int main()&#123;    int n ,m ;    cin>>n>>m ;    for(int i = 1 ;i <= n ;++i)        p[i] = i ;  //相当于初始化，将每一个元素存放到对应的集合中        for(int i = 0 ; i < m ;++i)&#123;        char op ;        cin>> op ;        int a , b ;        cin>> a >> b ;        if(op == 'M')        &#123;            p[find(a)] = find(b) ;        &#125;        else        &#123;            if(find(a) == find(b))                cout<<"Yes"<<endl ;            else                cout<<"No"<<endl ;        &#125;            &#125;return  0 ;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串哈希的理解</title>
      <link href="/2021/09/15/zi-fu-chuan-ha-xi-de-li-jie/"/>
      <url>/2021/09/15/zi-fu-chuan-ha-xi-de-li-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h2><hr><p>给定一个长度为 nn 的字符串，再给定 mm 个询问，每个询问包含四个整数 l1,r1,l2,r2l1,r1,l2,r2，请你判断 [l1,r1][l1,r1] 和 [l2,r2][l2,r2] 这两个区间所包含的字符串子串是否完全相同。</p><p>字符串中只包含大小写英文字母和数字。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 nn 和 mm，表示字符串长度和询问次数。</p><p>第二行包含一个长度为 nn 的字符串，字符串中只包含大小写英文字母和数字。</p><p>接下来 mm 行，每行包含四个整数 l1,r1,l2,r2l1,r1,l2,r2，表示一次询问所涉及的两个区间。</p><p>注意，字符串的位置从 11 开始编号。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个询问输出一个结果，如果两个字符串子串完全相同则输出 <code>Yes</code>，否则输出 <code>No</code>。</p><p>每个结果占一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n,m≤1051≤n,m≤105</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>8 3aabbaabb1 3 5 71 3 6 81 2 1 2</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>YesNoYes</code></pre><hr><pre class="line-numbers language-c++"><code class="language-c++">#include<bits/stdc++.h>using namespace std ;typedef unsigned long long ULL ;const int N  = 1e5+10 , P = 131; ULL h[N] , p[N] ;ULL ToPnumber(int l , int r)&#123;    return h[r]-h[l-1]*p[r-l+1] ;&#125;int main()&#123;    int n , m ;    cin>>n>>m ;    string x ;    cin>>x ;    h[0] = 0 ; p[0] = 1 ;        for(int i = 0 ;i < n ;++i)    &#123;        p[i+1] = p[i]*P  ;        h[i+1] = h[i]*P + x[i] ;    &#125;        for(int i = 0 ; i < m ;++i)    &#123;        int l1 , l2 , l3 ,l4 ;                cin>>l1>>l2>>l3>>l4 ;        if(ToPnumber(l1,l2) == ToPnumber(l3,l4))            cout<<"Yes"<< endl ;        else             cout<<"No"<< endl ;    &#125;        return  0 ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL的用法总结-摘自acwing</title>
      <link href="/2021/09/15/stl-de-yong-fa-zong-jie-zhai-zi-acwing/"/>
      <url>/2021/09/15/stl-de-yong-fa-zong-jie-zhai-zi-acwing/</url>
      
        <content type="html"><![CDATA[<p>vector（变长数组），倍增的思想，支持比较运算（按字典序）<br>    定义：：<br>        vector <int> a; 定义：一个vector数组a<br>        vector <int> a(10); 定义：一个长度为10的vector数组a<br>        vector <int> a(10,3); 定义：一个长度为10的vector数组a，并且所有元素都为3<br>    常用函数：：<br>        size(); 返回元素个数<br>        empty(); 返回是否是空<br>        clear(); 清空<br>        front(); 返回vector的第一个数<br>        back(); 返回vector的最后一个数<br>        push_back(); 向vector的最后插入一个数<br>        pop_back(); 把vector的最后一个数删掉<br>        begin(); vector的第0个数<br>        end(); vector的最后一个的数的后面一个数<br>    倍增的思想：<br>        系统为某一程序分配空间是，所需时间，与空间大小无关，与申请次数有关<br>    遍历方法<br>        假设有个vector <int> a;<br>        第一种：<br>            for(int i = 0;i &lt; a.size();i ++) cout&lt;&lt;a[i]&lt;&lt;” “;<br>        第二种：<br>            for(vector <int>::iterator i = a.begin();i != a.end();i ++) cout&lt;&lt;*i&lt;&lt;” “;  vector <int>::iterator可以写为auto<br>        第三种：<br>            for(auto  x : a) cout&lt;&lt;x&lt;&lt;” “;</p><p>pair，支持比较运算，以first为第一关键字，以second为第二关键字（按字典序）<br>    定义：：<br>        pair &lt;类型,类型&gt; 变量名;    两个类型可以不同<br>    初始化方式：<br>        假设有个pair &lt;int,string&gt; p;<br>        第一种：<br>            p = make_pair(10,”abc”);<br>        第二种：<br>            p = {10,”abc”);<br>    常用函数：：<br>        first(); 第一个元素<br>        second(); 第二个元素</p><p>string（字符串）<br>    常用函数：：<br>        substr(); 返回每一个子串<br>        c_str(); 返回这个string对应的字符数组的头指针<br>        size(); 返回字母个数<br>        length(); 返回字母个数<br>        empty(); 返回字符串是否为空<br>        clear(); 把字符串清空<br>queue（队列）<br>    定义：：<br>        queue &lt;类型&gt; 变量名;<br>    常用函数：：<br>        size(); 这个队列的长度<br>        empty(); 返回这个队列是否为空<br>        push(); 往队尾插入一个元素<br>        front(); 返回队头元素<br>        back(); 返回队尾元素<br>        pop(); 把队头弹出<br>        注意：队列没有clear函数！！！<br>    清空：<br>        变量名 = queue <int> ();<br>priority_queue（优先队列，堆）<br>    注意：默认是大根堆！！！<br>    定义：：<br>        大根堆：priority_queue &lt;类型&gt; 变量名;<br>        小根堆：priority_queue &lt;类型,vecotr &lt;类型&gt;,greater &lt;类型&gt;&gt; 变量名<br>    常用函数：<br>        size(); 这个堆的长度<br>        empty(); 返回这个堆是否为空<br>        push();往堆里插入一个元素<br>        top(); 返回堆顶元素<br>        pop(); 弹出堆顶元素<br>        注意：堆没有clear函数！！！</p><p>stack（栈）<br>    常用函数：<br>        size(); 这个栈的长度<br>        empty(); 返回这个栈是否为空<br>        push(); 向栈顶插入一个元素<br>        top(); 返回栈顶元素<br>        pop(); 弹出栈顶元素</p><p>deque（双端队列）<br>    常用函数：<br>        size(); 这个双端队列的长度<br>        empty(); 返回这个双端队列是否为空<br>        clear(); 清空这个双端队列<br>        front(); 返回第一个元素<br>        back(); 返回最后一个元素<br>        push_back(); 向最后插入一个元素<br>        pop_back(); 弹出最后一个元素<br>        push_front(); 向队首插入一个元素<br>        pop_front(); 弹出第一个元素<br>        begin(); 双端队列的第0个数<br>        end(); 双端队列的最后一个的数的后面一个数</p><p>set，map，multiset，multimap 基于平衡二叉树（红黑树），动态维护有序序列<br>    set/multiset<br>        注意：set不允许元素重复，如果有重复就会被忽略，但multiset允许！！！<br>        常用函数：<br>            size(); 返回元素个数<br>            empty(); 返回set是否是空的<br>            clear(); 清空<br>            begin(); 第0个数，支持++或–，返回前驱和后继<br>            end(); 最后一个的数的后面一个数，支持++或–，返回前驱和后继<br>            insert(); 插入一个数<br>            find(); 查找一个数<br>            count(); 返回某一个数的个数<br>            erase();<br>                （1）输入是一个数x，删除所有x    O(k + log n)<br>                （2）输入一个迭代器，删除这个迭代器<br>            lower_bound(x); 返回大于等于x的最小的数的迭代器<br>            upper_bound(x); 返回大于x的最小的数的迭代器<br>    map/multimap<br>        常用函数：<br>            insert(); 插入一个数，插入的数是一个pair<br>            erase();<br>                （1）输入是pair<br>                （2）输入一个迭代器，删除这个迭代器<br>            find(); 查找一个数<br>            lower_bound(x); 返回大于等于x的最小的数的迭代器<br>            upper_bound(x); 返回大于x的最小的数的迭代器</p><p>unordered_set，unordered_map，unordered_muliset,unordered_multimap 基于哈希表<br>    和上面类似，增删改查的时间复杂度是O(1)<br>    不支持lower_bound()和upper_bound()</p><p>bitset 压位<br>    定义：<br>        bitset &lt;个数&gt; 变量名;<br>    支持：<br>        <del>，&amp;，|，^<br>        &gt;&gt;，&lt;&lt;<br>        ==，!=<br>        []<br>    常用函数：<br>        count(); 返回某一个数的个数<br>        any(); 判断是否至少有一个1<br>        none(); 判断是否全为0<br>        set(); 把所有位置赋值为1<br>        set(k,v); 将第k位变成v<br>        reset(); 把所有位变成0<br>        flip(); 把所有位取反，等价于</del><br>        flip(k); 把第k位取反</p><p>作者：yxc<br>链接：<a href="https://www.acwing.com/video/20/">https://www.acwing.com/video/20/</a><br>来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      
        <tags>
            
            <tag> acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据范围的判断-摘自acwing</title>
      <link href="/2021/09/12/shu-ju-fan-wei-de-pan-duan-zhai-zi-acwing/"/>
      <url>/2021/09/12/shu-ju-fan-wei-de-pan-duan-zhai-zi-acwing/</url>
      
        <content type="html"><![CDATA[<p>一般ACM或者笔试题的时间限制是1秒或2秒。<br>在这种情况下，C++代码中的操作次数控制在 10的七次方到10的八次方为最佳。</p><p>下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：</p><p>n≤30, 指数级别, dfs+剪枝，状态压缩dp<br>n≤100 =&gt; O(n3)，floyd，dp，高斯消元<br>n≤1000=&gt; O(n2)，O(n2logn)，dp，二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford<br>n≤10000 =&gt; O(n∗√n)，块状链表、分块、莫队<br>n≤100000=&gt; O(nlogn) =&gt; 各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分<br>n≤1000000=&gt; O(n), 以及常数较小的 O(nlogn) 算法 =&gt; 单调队列、 hash、双指针扫描、并查集，kmp、AC自动机，常数比较小的 O(nlogn)的做法：sort、树状数组、heap、dijkstra、spfa<br>n≤10000000=&gt; O(n)，双指针扫描、kmp、AC自动机、线性筛素数<br>n≤10的9次方 =&gt; O(√n)，判断质数<br>n≤10的18次方 =&gt; O(logn)，最大公约数，快速幂<br>n≤10的1000次方=&gt; O((logn)2)，高精度加减乘除<br>n≤10的1000000次方 =&gt; O(logk×loglogk)，k表示位数，高精度加减、FFT/NTT</p><p>作者：yxc<br>链接：<a href="https://www.acwing.com/blog/content/32/">https://www.acwing.com/blog/content/32/</a><br>来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      
        <tags>
            
            <tag> acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题思考</title>
      <link href="/2021/09/09/bei-bao-wen-ti-si-kao/"/>
      <url>/2021/09/09/bei-bao-wen-ti-si-kao/</url>
      
        <content type="html"><![CDATA[<h2 id="背包问题分类："><a href="#背包问题分类：" class="headerlink" title="背包问题分类："></a>背包问题分类：</h2><h3 id="1-01背包问题"><a href="#1-01背包问题" class="headerlink" title="1.01背包问题"></a>1.01背包问题</h3><hr><p>有 NN 件物品和一个容量是 VV 的背包。每件物品只能使用一次。</p><p>第 ii 件物品的体积是 vivi，价值是 wiwi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 NN 行，每行两个整数 vi,wivi,wi，用空格隔开，分别表示第 ii 件物品的体积和价值。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N,V≤10000&lt;N,V≤1000<br>0&lt;vi,wi≤10000&lt;vi,wi≤1000</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><pre><code>4 51 22 43 44 5</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>8</code></pre><hr><pre class="line-numbers language-c++"><code class="language-c++">//朴素算法#include<bits/stdc++.h>using namespace std ;const int N = 1010 ;int dp[N][N] ;int v[N], w[N] ;int main()&#123;    int m, n ; cin>>m >> n ;    for(int i = 1 ; i<= m ;++i ) cin >> v[i]>>w[i] ;        for(int i = 1 ; i<= m ;++i) &#123;        for(int j = 0 ; j<= n ;++j)&#123;            dp[i][j] = dp[i-1][j] ;            if(j>= v[i]) dp[i][j] = max(dp[i-1][j-v[i]]+w[i]) ;        &#125;    &#125;    cout<< dp[m][n]<<endl ;    return 0 ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">//进行优化#include<bits/stdc++.h>using namespace std ;const int N = 1010 ;int dp[N] ; int v[N] ; int w[N] ;int main()&#123;    int m ,n ;     cin>> m >> n ;    for(int i = 1 ;i<= m; ++i) cin>> v[i]>>w[i] ;    for(int i = 1; i<= m ;++i )        for(int j = n ; j>= v[i] ;--j )            dp[j] = max(dp[j], dp[j-v[i]]+w[i]) ;    cout<<dp[n] <<endl ;    return 0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-完全背包问题"><a href="#2-完全背包问题" class="headerlink" title="2.完全背包问题"></a>2.完全背包问题</h3><p>有 NN 种物品和一个容量是 VV 的背包，每种物品都有无限件可用。</p><p>第 ii 种物品的体积是 vivi，价值是 wiwi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，VN，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 NN 行，每行两个整数 vi,wivi,wi，用空格隔开，分别表示第 ii 种物品的体积和价值。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N,V≤10000&lt;N,V≤1000<br>0&lt;vi,wi≤10000&lt;vi,wi≤1000</p><h4 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a>输入样例</h4><pre><code>4 51 22 43 44 5</code></pre><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>10</code></pre><pre class="line-numbers language-c++"><code class="language-c++">#这种算法最直观，但是会超时间，此题的数据是在1000 ，这有一个三层循环应该是在10的九次方左右，会超时,所以就有了之后的优化算法#include<bits/stdc++.h>using namespace std ;const int N = 1010 ;int f[N][N] ; int v[N] ; int w[N] ;int main()&#123;    int m ,n  ;    cin>>m>>n ;    for(int i = 1 ; i<= m ;++i) cin>> v[i]>>w[i] ;    for(int i = 1 ; i<= m ;++i ) &#123;        for(int j = 0 ; j<= n ;++j)&#123;            f[i][j] = f[i-1][j] ;                        for(int k = 1 ; j-k*v[i] >= 0 ; k++)&#123;                f[i][j]  = max(f[i][j] , f[i-1][j-k*v[i]]+k*w[i]) ;            &#125;        &#125;    &#125;    cout<< f[m][n] <<endl ;    return 0 ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">//朴素算法#include<bits/stdc++.h>using namespace std ;const int N =  1010 ;int dp[N][N] ; int v[N]; int w[N] ;int main()&#123;    int m , n ;    cin>>m >>n ;    for(int i = 1 ;i<= m ;++i) cin>> v[i]>>w[i] ;    for(int i = 1; i<= m ; ++i)         for(int j = 0 ; j<= n ++j)&#123;            dp[i][j] = dp[i-1][j] ;            if(j >= v[i]) dp[i][j] = max(dp[i][j], dp[i][j-v[i]]+w[i]) ;        &#125;    cout<< dp[m][n] <<endl ;    return 0 ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">//优化算法#include<bits/stdc++.h>using namespace std ;const int N = 1010; int dp[N] ; int v[N] ;int w[N] ; int main()&#123;    int m , n ;    cin>>m >> n ;     for(int i =1 ; i <= m ;++i) cin>>v[i]>>w[i] ;        for(int i = 1; i <= m ;++i)        for(int j = v ; j<= n ;++j)            dp[j] = max(dp[j], dp[j-v[i]]+w[i]) ;        cout>>dp[n] ;    return 0 ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-多重背包问题"><a href="#3-多重背包问题" class="headerlink" title="3.多重背包问题"></a>3.多重背包问题</h2><p>有 NN 种物品和一个容量是 VV 的背包。</p><p>第 ii 种物品最多有 sisi 件，每件体积是 vivi，价值是 wiwi。</p><p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，VN，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 NN 行，每行三个整数 vi,wi,sivi,wi,si，用空格隔开，分别表示第 ii 种物品的体积、价值和数量。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N,V≤1000&lt;N,V≤100<br>0&lt;vi,wi,si≤1000&lt;vi,wi,si≤100</p><h4 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例"></a>输入样例</h4><pre><code>4 51 2 32 4 13 4 34 5 2</code></pre><h4 id="输出样例：-2"><a href="#输出样例：-2" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>10</code></pre><pre class="line-numbers language-c++"><code class="language-c++">#这能ac是我妹想到的，总之这是一个最朴素的做法，我估计数据增强之后就不可以了#include<bits/stdc++.h>using namespace std ;const int N = 1010 ;int f[N][N] ;int v[N] ; int w[N] ;int s[N];int main()&#123;    int m ,n  ;    cin>>m >>n ;    for(int i = 1 ; i<= m ;++i) cin>>v[i]>>w[i]>>s[i] ;        for(int i = 1 ;i<= m ;++i)&#123;        for(int j = 0 ;j<=n ;++j)&#123;            f[i][j] = f[i-1][j] ;            for(int k = 1 ; k<= s[i]&& j-k*v[i]>= 0 ;++k)&#123;                f[i][j] = max(f[i][j], f[i-1][j-k*v[i]]+k*w[i]) ;            &#125;        &#125;    &#125;    cout<<f[m][n]<<endl ;    return 0 ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>妙</title>
      <link href="/2021/09/09/miao/"/>
      <url>/2021/09/09/miao/</url>
      
        <content type="html"><![CDATA[<h2 id="799-最长连续不重复子序列"><a href="#799-最长连续不重复子序列" class="headerlink" title="799.最长连续不重复子序列"></a>799.最长连续不重复子序列</h2><hr><p>给定一个长度为 nn 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 nn。</p><p>第二行包含 nn 个整数（均在 0∼1050∼105 范围内），表示整数序列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤105</p><hr><hr><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>51 2 2 3 5</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>3</code></pre><hr><p>核心思路：</p><p>1.对于重复的理解</p><p>不是单纯的判断==的关系，而是多申请了一个额外的数组，充当一个hash table，把原元素当成key值，记录元素的频率。当频率大于1的时候，就是重复了.</p><p>2.对于间断的时机的理解</p><p>由于推理逻辑是具有连续性的，所以，由于前一个i到j的区间是不重复的，但是之后出现了重复。只有一种可能，那就是最新的p[i]与之前区间里面的数据重复了。即只需要“恰头”，一个循环一直丢头，直到p[i]的频率为1为止。</p><pre class="line-numbers language-c++"><code class="language-c++">#include <bits/stdc++.h>using namespace std ;#define read(x) scanf("%d",&x) ;const int N = 100010 ;int main()&#123;    int n ; int r = 0 ;  int p[N] ; int s[N] = &#123;0&#125; ;    read(n) ;     for(int i = 0 ,j = 0 ; i< n ;++i)&#123;        read(p[i]) ;        s[p[i]] ++ ;        while(s[p[i]] > 1) --s[p[j++]] ;        r = max(r, i-j+1) ;    &#125;    cout<< r<< endl ;    return 0 ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针算法专题</title>
      <link href="/2021/09/09/shuang-zhi-zhen-suan-fa-zhuan-ti/"/>
      <url>/2021/09/09/shuang-zhi-zhen-suan-fa-zhuan-ti/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串算法专题</title>
      <link href="/2021/09/08/zi-fu-chuan-suan-fa-zhuan-ti/"/>
      <url>/2021/09/08/zi-fu-chuan-suan-fa-zhuan-ti/</url>
      
        <content type="html"><![CDATA[<p>节选了字符串部分的一些有共性和特性的一些题目</p><h2 id="5-最长回文字符串"><a href="#5-最长回文字符串" class="headerlink" title="5.最长回文字符串"></a>5.最长回文字符串</h2><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><hr><p>示例1：</p><p>输入：s = “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。<br>示例 2：</p><p>输入：s = “cbbd”<br>输出：”bb”<br>示例 3：</p><p>输入：s = “a”<br>输出：”a”<br>示例 4：</p><p>输入：s = “ac”<br>输出：”a”</p><hr><hr><p>提示：</p><p>1 &lt;= s.length &lt;= 1000<br>s 仅由数字和英文字母（大写和/或小写）组成</p><hr><p>法一：中心扩散法</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    vector<int> maxlength(string s, int start, int end)&#123;        int n  = s.size() ;        vector<int> ans(2) ;        while(start>= 0 && end<n )&#123;            if(s[start]  == s[end])&#123;                start -- ; end++ ;            &#125;            else             break;        &#125;            start++ ; end-- ;            ans[0] = start ; ans[1] = end-start+1 ;            return ans ;    &#125;    string longestPalindrome(string s) &#123;        vector<int> ji(2) ; vector<int> ou(2)  ; vector<int> result(2) ;         int n = s.size() ;        if(n == 1) return s ;        int max =0  ;         for(int i = 0 ;i<n-1 ;++i)&#123;            ji = maxlength(s,i,i) ;            ou = maxlength(s,i,i+1) ;            int length = ji[1]>ou[1] ? ji[1]:ou[1] ;            if(length>max)&#123;                max = length ;                result = ji[1]>ou[1] ? ji:ou ;            &#125;        &#125;         return s.substr (result[0], result[1]) ;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>法二：动态规划法</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    string longestPalindrome(string s) &#123;        int n = s.size();        if (n < 2) &#123;            return s;        &#125;        int maxLen = 1;        int begin = 0;        // dp[i][j] 表示 s[i..j] 是否是回文串        vector<vector<int>>  dp(n, vector<int>(n));        // 初始化：所有长度为 1 的子串都是回文串        for (int i = 0; i < n; i++) &#123;            dp[i][i] = true;        &#125;        // 递推开始        // 先枚举子串长度        for (int L = 2; L <= n; L++) &#123;            // 枚举左边界，左边界的上限设置可以宽松一些            for (int i = 0; i < n; i++) &#123;                // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得                int j = L + i - 1;                // 如果右边界越界，就可以退出当前循环                if (j >= n) &#123;                    break;                &#125;                if (s[i] != s[j]) &#123;                    dp[i][j] = false;                &#125; else &#123;                    if (j - i < 3) &#123;                        dp[i][j] = true;                    &#125; else &#123;                        dp[i][j] = dp[i + 1][j - 1];                    &#125;                &#125;                // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置                if (dp[i][j] && j - i + 1 > maxLen) &#123;                    maxLen = j - i + 1;                    begin = i;                &#125;            &#125;        &#125;        return s.substr(begin, maxLen);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516.最长回文子序列"></a>516.最长回文子序列</h2><hr><p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><hr><hr><p>示例 1：</p><p>输入：s = “bbbab”<br>输出：4<br>解释：一个可能的最长回文子序列为 “bbbb” 。<br>示例 2：</p><p>输入：s = “cbbd”<br>输出：2<br>解释：一个可能的最长回文子序列为 “bb” 。</p><hr><hr><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul><hr><p>法一：动态规划法</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    int longestPalindromeSubseq(string s) &#123;        int n = s.size() ;        vector<vector<int>> dp(n,vector<int>(n,0)); //初始化二维的容器        for(int i = 0;i<n;i++)&#123;    //给每一个一个元素的附上初值            dp[i][i] = 1 ;        &#125;        for(int j = 0;j<n;j++)&#123;            for(int i = j-1;i>=0;i--)&#123;                if(s[i] == s[j])                dp[i][j] = dp[i+1][j-1] +2 ;                else                dp[i][j] = max(dp[i+1][j],dp[i][j-1]) ;            &#125;        &#125;       return dp[0][n-1] ;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="541-反转字符串II"><a href="#541-反转字符串II" class="headerlink" title="541.反转字符串II"></a>541.反转字符串II</h2><hr><p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每 2k 个字符反转前 k 个字符。</p><p>如果剩余字符少于 k 个，则将剩余字符全部反转。<br>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p><hr><hr><p>示例 1：</p><p>输入：s = “abcdefg”, k = 2<br>输出：”bacdfeg”<br>示例 2：</p><p>输入：s = “abcd”, k = 2<br>输出：”bacd”</p><hr><p>提示：</p><p>1 &lt;= s.length &lt;= 104<br>s 仅由小写英文组成<br>1 &lt;= k &lt;= 104</p><hr><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    string reverseStr(string s, int k) &#123;        int n = s.size() ;        for(int i = 0;i<n;i+=2*k)&#123;            reverse(s.begin()+i,s.begin()+min(n,k+i)) ;        &#125;        return s ;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763.划分字母区间"></a>763.划分字母区间</h2><hr><p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p><hr><hr><p>示例：</p><p>输入：S = “ababcbacadefegdehijhklij”<br>输出：[9,7,8]<br>解释：<br>划分结果为 “ababcbaca”, “defegde”, “hijhklij”。<br>每个字母最多出现在一个片段中。<br>像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。</p><hr><hr><p><strong>提示：</strong></p><ul><li><code>S</code>的长度在<code>[1, 500]</code>之间。</li><li><code>S</code>只包含小写字母 <code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code> 。</li></ul><hr><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    vector<int> partitionLabels(string s) &#123;       vector<int>ans,ends(26,-1) ;          //这一步是申请两个vector，一个是用来return，一个是用来反映元素最后出现的位置信号       for(int i = 0;i<s.length();i++)&#123;           ends[s[i]-'a'] = i ;                          &#125;       int i = 0 ;       int end = 0 ;       while(i<s.length())&#123;           end = ends[s[i]-'a'] ;           for(int k = i+1;k<end;k++)&#123;               end = max(end,ends[s[k]-'a']) ;           &#125;           ans.push_back(end-i+1) ;           i = end+1 ;       &#125;      return ans ;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="680-验证回文字符串II"><a href="#680-验证回文字符串II" class="headerlink" title="680.验证回文字符串II"></a>680.验证回文字符串II</h2><hr><p>给定一个非空字符串 <code>s</code>，<strong>最多</strong>删除一个字符。判断是否能成为回文字符串。</p><hr><hr><p>示例 1:</p><p>输入: s = “aba”<br>输出: true<br>示例 2:</p><p>输入: s = “abca”<br>输出: true<br>解释: 你可以删除c字符。<br>示例 3:</p><p>输入: s = “abc”<br>输出: false</p><hr><hr><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s</code> 由小写英文字母组成</li></ul><hr><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    bool validPalindrome(string s) &#123;    if(s.length() <= 2)    return true ;    else&#123;      int left = 0 ;      int right = s.length()-1 ;      while(left<right)&#123;        if(s[left] != s[right])&#123;            if(isornot(s,left+1,right) ||isornot(s,left,right-1))            return true ;            else            return false ;        &#125;        left++ ;        right-- ;      &#125;    &#125;    return true ;    &#125;    public:bool isornot(string t,int l,int r)&#123;    while(l<r)&#123;     if(t[l] == t[r])&#123;     l++ ;     r-- ;     &#125;     else     return false ;    &#125;    return true ;&#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49.字母异位词分组"></a>49.字母异位词分组</h2><hr><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p><p>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母都恰好只用一次。</p><hr><hr><p>示例 1:</p><p>输入: strs = [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]<br>输出: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]<br>示例 2:</p><p>输入: strs = [“”]<br>输出: [[“”]]<br>示例 3:</p><p>输入: strs = [“a”]<br>输出: [[“a”]]</p><hr><hr><p><strong>提示：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 104</code></li><li><code>0 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code> 仅包含小写字母</li></ul><hr><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    vector<vector<string>> groupAnagrams(vector<string>& strs) &#123;        int num[26] = &#123;2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101&#125; ;        unordered_map<unsigned long long ,vector<string>> mp ;        vector<vector<string>> result ;        for(string s : strs)&#123;            unsigned long long key = 1 ;            for(char c: s)&#123;                key *= num[c-'a'] ;            &#125;            mp[key].push_back(s) ;        &#125;        for(auto p : mp)&#123;            result.push_back(p.second) ;        &#125;        return result ;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="524-通过删除字母匹配到字典里最长单词"><a href="#524-通过删除字母匹配到字典里最长单词" class="headerlink" title="524.通过删除字母匹配到字典里最长单词"></a>524.通过删除字母匹配到字典里最长单词</h2><hr><p>给你一个字符串 s 和一个字符串数组 dictionary 作为字典，找出并返回字典中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。</p><p>如果答案不止一个，返回长度最长且字典序最小的字符串。如果答案不存在，则返回空字符串。</p><hr><hr><p>示例 1：</p><p>输入：s = “abpcplea”, dictionary = [“ale”,”apple”,”monkey”,”plea”]<br>输出：”apple”<br>示例 2：</p><p>输入：s = “abpcplea”, dictionary = [“a”,”b”,”c”]<br>输出：”a”</p><hr><hr><p>提示：</p><p>1 &lt;= s.length &lt;= 1000<br>1 &lt;= dictionary.length &lt;= 1000<br>1 &lt;= dictionary[i].length &lt;= 1000<br>s 和 dictionary[i] 仅由小写英文字母组成</p><hr><pre class="line-numbers language-c++"><code class="language-c++">class Solution &#123;public:    string findLongestWord(string s, vector<string>& dictionary) &#123;     sort(dictionary.begin(),dictionary.end(),[](string a,string b)&#123;         if(a.length() == b.length())         return a<b ;         return a.length()>b.length() ;     &#125;) ;     for(string str:dictionary)&#123;        int i = 0 ;        for(char c: s)&#123;            if(i<str.size() && c == str[i])            i++ ;           if(i == str.size())           return str ;        &#125;     &#125;     return "" ;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76.最小覆盖子串"></a>76.最小覆盖子串</h2><h2 id="443-压缩字符串"><a href="#443-压缩字符串" class="headerlink" title="443.压缩字符串"></a>443.压缩字符串</h2>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法专题</title>
      <link href="/2021/09/08/tan-xin-suan-fa-zhuan-ti/"/>
      <url>/2021/09/08/tan-xin-suan-fa-zhuan-ti/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>luolin-first-blog</title>
      <link href="/2021/09/05/luolin-first-blog/"/>
      <url>/2021/09/05/luolin-first-blog/</url>
      
        <content type="html"><![CDATA[<p>这是我的第一篇博客，等熟悉了流程之后会频繁的更新博客，因为这也算是自己学习的过程的记录。</p><p>我是罗林 来自南京农业大学 专业是数据科学与大数据技术 </p><p>这个博客是为了记录我的学习生活，以及生活中的一些有趣的事情。</p><p>应该会先分为两个板块：机器学习，数据结构与算法。</p><p>之后有新的认知或者是对新的领域有兴趣可能会在追加几个板块。</p><p>我的座右铭是 一直学习，做一个有趣的人！希望有同样热爱计算机的geek们与我交流！！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
